Directory structure:
└── mavdotso-monolink/
    ├── README.md
    ├── components.json
    ├── eslint.config.mjs
    ├── middleware.ts
    ├── next.config.ts
    ├── package.json
    ├── postcss.config.mjs
    ├── tsconfig.json
    ├── .prettierrc
    ├── app/
    │   ├── globals.css
    │   ├── layout.tsx
    │   ├── (dashboard)/
    │   │   └── dashboard/
    │   │       ├── layout.tsx
    │   │       ├── page.tsx
    │   │       ├── [profileId]/
    │   │       │   └── page.tsx
    │   │       └── subscription/
    │   │           └── page.tsx
    │   ├── (pages)/
    │   │   ├── layout.tsx
    │   │   ├── page.tsx
    │   │   ├── sign-in/
    │   │   │   └── page.tsx
    │   │   └── sign-up/
    │   │       └── page.tsx
    │   └── [handle]/
    │       ├── layout.tsx
    │       └── page.tsx
    ├── assets/
    │   └── monolink-logo.tsx
    ├── components/
    │   ├── auth/
    │   │   ├── sign-in-form.tsx
    │   │   └── sign-out-button.tsx
    │   ├── common/
    │   │   ├── animated-tabs.tsx
    │   │   ├── logo.tsx
    │   │   ├── radial-progress.tsx
    │   │   └── theme-switch.tsx
    │   ├── dashboard/
    │   │   ├── content-tab.tsx
    │   │   ├── layout-tab.tsx
    │   │   ├── monetization-tab.tsx
    │   │   ├── profile-content-tabs.tsx
    │   │   ├── profile-customisation-tabs.tsx
    │   │   ├── profile-preview.tsx
    │   │   └── layout/
    │   │       └── dashboard-header.tsx
    │   ├── forms/
    │   │   ├── item-form.tsx
    │   │   ├── link-form.tsx
    │   │   └── profile-form.tsx
    │   ├── layout/
    │   │   └── main-header.tsx
    │   ├── media/
    │   │   ├── avatar-upload.tsx
    │   │   └── image-upload.tsx
    │   ├── monetization/
    │   │   ├── donate-button.tsx
    │   │   ├── payment-list.tsx
    │   │   ├── stripe-connect-section.tsx
    │   │   ├── stripe-earnings-dashboard.tsx
    │   │   └── subscribe-button.tsx
    │   ├── profile/
    │   │   ├── cards/
    │   │   │   ├── enhanced-profile-card.tsx
    │   │   │   ├── profile-card-skeleton.tsx
    │   │   │   ├── profile-card.tsx
    │   │   │   └── profile-selector.tsx
    │   │   ├── editor/
    │   │   │   ├── appearance-manager.tsx
    │   │   │   ├── create-profile.tsx
    │   │   │   ├── profile-settings.tsx
    │   │   │   └── template-customizer.tsx
    │   │   └── sections/
    │   │       ├── donation-section.tsx
    │   │       ├── draggable-section.tsx
    │   │       ├── profile-content-dnd.tsx
    │   │       ├── profile-content.tsx
    │   │       └── public-profile-content.tsx
    │   ├── providers/
    │   │   ├── client-providers.tsx
    │   │   ├── convex-client-provider.tsx
    │   │   └── theme-provider.tsx
    │   ├── templates/
    │   │   ├── default-profile-layout.tsx
    │   │   ├── profile-template-renderer.tsx
    │   │   └── components/
    │   │       ├── bio-component.tsx
    │   │       ├── contact-component.tsx
    │   │       ├── donation-component.tsx
    │   │       ├── gallery-component.tsx
    │   │       ├── header-component.tsx
    │   │       ├── items-component.tsx
    │   │       ├── links-component.tsx
    │   │       └── social-component.tsx
    │   └── ui/
    │       ├── accordion.tsx
    │       ├── alert.tsx
    │       ├── avatar.tsx
    │       ├── badge.tsx
    │       ├── button.tsx
    │       ├── card.tsx
    │       ├── checkbox.tsx
    │       ├── dialog.tsx
    │       ├── dropdown-menu.tsx
    │       ├── input.tsx
    │       ├── label.tsx
    │       ├── progress.tsx
    │       ├── radio-group.tsx
    │       ├── scroll-area.tsx
    │       ├── select.tsx
    │       ├── separator.tsx
    │       ├── skeleton.tsx
    │       ├── slider.tsx
    │       ├── sonner.tsx
    │       ├── switch.tsx
    │       ├── tabs.tsx
    │       └── textarea.tsx
    ├── convex/
    │   ├── auth.config.ts
    │   ├── auth.ts
    │   ├── files.ts
    │   ├── http.ts
    │   ├── items.ts
    │   ├── links.ts
    │   ├── payments.ts
    │   ├── profileLayouts.ts
    │   ├── profiles.ts
    │   ├── profileTemplates.ts
    │   ├── profileThemes.ts
    │   ├── router.ts
    │   ├── schema.ts
    │   ├── stripe.ts
    │   ├── stripeConnect.ts
    │   ├── subscriptions.ts
    │   ├── tsconfig.json
    │   ├── _generated/
    │   │   ├── api.d.ts
    │   │   ├── api.js
    │   │   ├── dataModel.d.ts
    │   │   ├── server.d.ts
    │   │   └── server.js
    │   ├── helpers/
    │   │   ├── common/
    │   │   │   ├── auth.ts
    │   │   │   └── url.ts
    │   │   ├── profiles/
    │   │   │   └── utils.ts
    │   │   ├── stripe/
    │   │   │   ├── eventHelpers.ts
    │   │   │   ├── paymentHelpers.ts
    │   │   │   └── types.ts
    │   │   └── subscriptions/
    │   │       ├── limitHelpers.ts
    │   │       ├── types.ts
    │   │       └── validators.ts
    │   ├── lib/
    │   │   ├── plans.ts
    │   │   └── stripe.ts
    │   ├── seed/
    │   │   ├── index.ts
    │   │   ├── profileTemplates.ts
    │   │   ├── profileThemes.ts
    │   │   └── seeder.ts
    │   └── types/
    │       └── profileSections.ts
    ├── hooks/
    │   ├── useFileUpload.ts
    │   └── usePlanLimits.ts
    ├── lib/
    │   ├── server-functions.ts
    │   ├── template-mappings.ts
    │   ├── theme-defaults.ts
    │   ├── theme-mappings.ts
    │   └── utils.ts
    ├── types/
    │   ├── profile.ts
    │   ├── template.ts
    │   └── theme.ts
    └── .cursor/
        └── rules/
            └── convex_rules.mdc

================================================
FILE: README.md
================================================
# Monolink

A modern "link in bio" platform with monetization features and customizable profiles.

## Overview

Monolink allows users to create personalized profile pages with customizable links and digital products. It combines the functionality of traditional "link in bio" tools with powerful monetization features through Stripe integration.

## Features

- **Customizable Profiles**: Create profiles with unique handles, bios, and visual styles
- **Link Management**: Add, organize, and track links to any external content
- **Digital Products**: Sell digital items directly from your profile
- **Monetization**: Accept donations and sell products through Stripe Connect
- **Templates & Themes**: Choose from various templates and themes or create your own
- **Subscription Tiers**: Access different feature sets based on subscription level

## Tech Stack

- **Frontend**: Next.js 15.3 (App Router), React 19, TailwindCSS 4, Shadcn UI
- **Backend**: Convex (real-time database, API, and authentication)
- **Payments**: Stripe for subscriptions, one-time purchases, and creator payments

## Getting Started

### Prerequisites

- Node.js (v18 or higher)
- Yarn package manager
- Convex account
- Stripe account (for payment features)

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/monolink.git
   cd monolink
   ```

2. Install dependencies:
   ```bash
   yarn install
   ```

3. Set up environment variables:
   Create a `.env.local` file in the root directory with the following variables:
   ```
   NEXT_PUBLIC_CONVEX_URL=your_convex_deployment_url
   NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_publishable_key
   CLERK_SECRET_KEY=your_clerk_secret_key
   STRIPE_SECRET_KEY=your_stripe_secret_key
   STRIPE_WEBHOOK_SECRET=your_stripe_webhook_secret
   ```

### Development

Start the development servers:

```bash
# In one terminal:
yarn dev

# In another terminal:
yarn convex
```

The application will be available at `http://localhost:3000`.

### Database Seeding

To seed the database with initial data:

```bash
# Seed all data
yarn seed

# Seed only profile templates
yarn seed:templates
```

### Building for Production

```bash
yarn build
yarn start
```

## Subscription Tiers

Monolink offers three subscription tiers:

- **Starter**: Basic features with limited profiles and links
- **Pro**: More profiles, links, and advanced customization options
- **Business**: Team capabilities and enterprise features

## License

[MIT License](LICENSE)


================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: middleware.ts
================================================
import {
  convexAuthNextjsMiddleware,
  createRouteMatcher,
  nextjsMiddlewareRedirect,
} from "@convex-dev/auth/nextjs/server";

const isSignInPage = createRouteMatcher(["/signin"]);
const isProtectedRoute = createRouteMatcher(["/protected(.*)"]);

export default convexAuthNextjsMiddleware(async (request, { convexAuth }) => {
  if (isSignInPage(request) && (await convexAuth.isAuthenticated())) {
    return nextjsMiddlewareRedirect(request, "/protected");
  }
  if (isProtectedRoute(request) && !(await convexAuth.isAuthenticated())) {
    return nextjsMiddlewareRedirect(request, "/signin");
  }
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};


================================================
FILE: next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [new URL('https://cool-dodo-803.convex.cloud/**')],
    dangerouslyAllowSVG: true,
  },
};

export default nextConfig;



================================================
FILE: package.json
================================================
{
  "name": "monolink",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "convex": "convex dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "knip": "knip",
    "seed": "convex run seed/seeder:seedAll",
    "seed:templates": "convex run seed/seeder:templates"
  },
  "dependencies": {
    "@auth/core": "^0.37.4",
    "@convex-dev/auth": "^0.0.82",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-avatar": "^1.1.7",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-dialog": "^1.1.11",
    "@radix-ui/react-dropdown-menu": "^2.1.12",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-progress": "^1.1.6",
    "@radix-ui/react-radio-group": "^1.3.6",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-separator": "^1.1.4",
    "@radix-ui/react-slider": "^1.3.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.11",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.23.0",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.503.0",
    "motion": "^12.9.2",
    "next": "15.3.1",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "resend": "^4.4.1",
    "sonner": "^2.0.3",
    "stripe": "^18.1.0",
    "tailwind-merge": "^3.2.0",
    "zod": "^3.24.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.17.46",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "knip": "^5.55.1",
    "prettier": "^3.5.3",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "tw-animate-css": "^1.2.8",
    "typescript": "^5.8.3"
  }
}



================================================
FILE: postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: .prettierrc
================================================
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 100
}


================================================
FILE: app/globals.css
================================================
@import 'tailwindcss';
@import 'tw-animate-css';

:root {
  --background: oklch(0.99 0 0);
  --foreground: oklch(0 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0 0 0);
  --popover: oklch(0.99 0 0);
  --popover-foreground: oklch(0 0 0);
  --primary: oklch(0 0 0);
  --primary-foreground: oklch(1 0 0);
  --secondary: oklch(0.94 0 0);
  --secondary-foreground: oklch(0 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.44 0 0);
  --accent: oklch(0.94 0 0);
  --accent-foreground: oklch(0 0 0);
  --destructive: oklch(0.63 0.19 23.03);
  --destructive-foreground: oklch(1 0 0);
  --border: oklch(0.81 0 0 /0.2);
  --input: oklch(0.94 0 0);
  --ring: oklch(0 0 0);
  --chart-1: oklch(0.81 0.17 75.35);
  --chart-2: oklch(0.55 0.22 264.53);
  --chart-3: oklch(0.72 0 0);
  --chart-4: oklch(0.92 0 0);
  --chart-5: oklch(0.56 0 0);
  --sidebar: oklch(0.99 0 0);
  --sidebar-foreground: oklch(0 0 0);
  --sidebar-primary: oklch(0 0 0);
  --sidebar-primary-foreground: oklch(1 0 0);
  --sidebar-accent: oklch(0.94 0 0);
  --sidebar-accent-foreground: oklch(0 0 0);
  --sidebar-border: oklch(0.94 0 0);
  --sidebar-ring: oklch(0 0 0);
  --font-sans: Geist, sans-serif;
  --font-serif: Georgia, serif;
  --font-mono: Geist Mono, monospace;
  --radius: 0.75rem;
  --shadow-2xs: 0px 1px 2px 0px hsl(0 0% 0% / 0.09);
  --shadow-xs: 0px 1px 2px 0px hsl(0 0% 0% / 0.09);
  --shadow-sm: 0px 1px 2px 0px hsl(0 0% 0% / 0.18), 0px 1px 2px -1px hsl(0 0% 0% / 0.18);
  --shadow: 0px 1px 2px 0px hsl(0 0% 0% / 0.18), 0px 1px 2px -1px hsl(0 0% 0% / 0.18);
  --shadow-md: 0px 1px 2px 0px hsl(0 0% 0% / 0.18), 0px 2px 4px -1px hsl(0 0% 0% / 0.18);
  --shadow-lg: 0px 1px 2px 0px hsl(0 0% 0% / 0.18), 0px 4px 6px -1px hsl(0 0% 0% / 0.18);
  --shadow-xl: 0px 1px 2px 0px hsl(0 0% 0% / 0.18), 0px 8px 10px -1px hsl(0 0% 0% / 0.18);
  --shadow-2xl: 0px 1px 2px 0px hsl(0 0% 0% / 0.45);
}

.dark {
  --background: oklch(0 0 0);
  --foreground: oklch(1 0 0);
  --card: oklch(0.14 0 0);
  --card-foreground: oklch(1 0 0);
  --popover: oklch(0.18 0 0);
  --popover-foreground: oklch(1 0 0);
  --primary: oklch(1 0 0);
  --primary-foreground: oklch(0 0 0);
  --secondary: oklch(0.25 0 0);
  --secondary-foreground: oklch(1 0 0);
  --muted: oklch(0.23 0 0);
  --muted-foreground: oklch(0.72 0 0);
  --accent: oklch(0.32 0 0);
  --accent-foreground: oklch(1 0 0);
  --destructive: oklch(0.69 0.2 23.91);
  --destructive-foreground: oklch(0 0 0);
  --border: oklch(0.4 0 0 / 0.2);
  --input: oklch(0.32 0 0);
  --ring: oklch(0.72 0 0);
  --chart-1: oklch(0.81 0.17 75.35);
  --chart-2: oklch(0.58 0.21 260.84);
  --chart-3: oklch(0.56 0 0);
  --chart-4: oklch(0.44 0 0);
  --chart-5: oklch(0.92 0 0);
  --sidebar: oklch(0.18 0 0);
  --sidebar-foreground: oklch(1 0 0);
  --sidebar-primary: oklch(1 0 0);
  --sidebar-primary-foreground: oklch(0 0 0);
  --sidebar-accent: oklch(0.32 0 0);
  --sidebar-accent-foreground: oklch(1 0 0);
  --sidebar-border: oklch(0.32 0 0);
  --sidebar-ring: oklch(0.72 0 0);
  --font-sans: Geist, sans-serif;
  --font-serif: Georgia, serif;
  --font-mono: Geist Mono, monospace;
  --radius: 0.75rem;
  --shadow-2xs: 0px 1px 2px 0px hsl(0 0% 0% / 0.09);
  --shadow-xs: 0px 1px 2px 0px hsl(0 0% 0% / 0.09);
  --shadow-sm: 0px 1px 2px 0px hsl(0 0% 0% / 0.15), 0px 1px 2px -1px hsl(0 0% 0% / 0.15);
  --shadow: 0px 1px 2px 0px hsl(0 0% 0% / 0.15), 0px 1px 2px -1px hsl(0 0% 0% / 0.15);
  --shadow-md: 0px 1px 2px 0px hsl(0 0% 0% / 0.15), 0px 2px 4px -1px hsl(0 0% 0% / 0.15);
  --shadow-lg: 0px 1px 2px 0px hsl(0 0% 0% / 0.15), 0px 4px 6px -1px hsl(0 0% 0% / 0.15);
  --shadow-xl: 0px 1px 2px 0px hsl(0 0% 0% / 0.15), 0px 8px 10px -1px hsl(0 0% 0% / 0.15);
  --shadow-2xl: 0px 1px 2px 0px hsl(0 0% 0% / 0.45);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);

  --font-sans: var(--font-sans);
  --font-mono: var(--font-mono);
  --font-serif: var(--font-serif);

  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);

  --shadow-2xs: var(--shadow-2xs);
  --shadow-xs: var(--shadow-xs);
  --shadow-sm: var(--shadow-sm);
  --shadow: var(--shadow);
  --shadow-md: var(--shadow-md);
  --shadow-lg: var(--shadow-lg);
  --shadow-xl: var(--shadow-xl);
  --shadow-2xl: var(--shadow-2xl);
}



================================================
FILE: app/layout.tsx
================================================
import './globals.css'

import { Geist, Geist_Mono } from 'next/font/google'
import { Toaster } from 'sonner'
import { ConvexAuthNextjsServerProvider } from '@convex-dev/auth/nextjs/server'
import ClientProviders from '@/components/providers/client-providers'

import type { Metadata } from 'next'

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
})

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
})

export const metadata: Metadata = {
  title: 'monolink.cc',
  description: 'The home for your digital business',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased  text-balance`}>
        <ConvexAuthNextjsServerProvider>
          <ClientProviders>{children}</ClientProviders>
          <Toaster />
        </ConvexAuthNextjsServerProvider>
      </body>
    </html>
  )
}



================================================
FILE: app/(dashboard)/dashboard/layout.tsx
================================================
'use client'

import { ReactNode } from 'react'
import { DashboardHeader } from "@/components/dashboard/layout/dashboard-header"
import { cn } from '@/lib/utils'

export default function DashboardLayout({
  children,
  className,
}: {
  children: ReactNode
  className?: string
}) {
  return (
    <div
      className={cn(
        'flex flex-col flex-1 w-full h-screen text-balance p-2 pt-0 overflow-hidden',
        className,
      )}
    >
      <DashboardHeader />
      <div className="flex justify-center flex-1 w-full h-full min-h-0 overflow-auto border border-border bg-muted/80 rounded-xl">
        {children}
      </div>
    </div>
  )
}



================================================
FILE: app/(dashboard)/dashboard/page.tsx
================================================
'use client'

import { CreateProfileModal } from '@/components/profile/editor/create-profile'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { ProfileCardSkeleton } from '@/components/profile/cards/profile-card-skeleton'
import { ProfileCard } from '@/components/profile/cards/profile-card'
import { useProfileLimits } from '@/hooks/usePlanLimits'
import { Badge } from '@/components/ui/badge'
import { Progress } from '@/components/ui/progress'
import { Button } from '@/components/ui/button'
import Link from 'next/link'

export default function DashboardPage() {
  const profiles = useQuery(api.profiles.listByUserWithThemesAndTemplates, {})
  const profileLimits = useProfileLimits()
  const subscription = useQuery(api.subscriptions.getUserSubscription, {})
  const planName = subscription?.plan?.name || 'Free'

  return (
    <div className="max-w-4xl p-6 mx-auto">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-xl font-bold">Profiles</h1>
          <div className="flex items-center mt-1">
            <Badge variant="outline" className="mr-2">
              {planName} Plan
            </Badge>
            <span className="text-sm text-muted-foreground">
              {profileLimits.currentCount} of {profileLimits.maxProfiles} profiles used
            </span>
          </div>
        </div>
        {profileLimits.canCreate ? (
          <CreateProfileModal />
        ) : (
          <div className="flex flex-col items-end">
            <Button variant="outline" className="mb-1" disabled>
              Profile Limit Reached
            </Button>
            <Link href="/dashboard/subscription" className="text-xs text-blue-500 hover:underline">
              Upgrade Plan
            </Link>
          </div>
        )}
      </div>

      {/* Profile usage progress bar */}
      <div className="mb-6">
        <Progress value={profileLimits.percentUsed} className="h-2" />
      </div>

      <div className="grid grid-cols-1 gap-3 mb-6 sm:grid-cols-2">
        {profiles === undefined ? (
          Array.from({ length: 4 }).map((_, i) => <ProfileCardSkeleton key={i} />)
        ) : profiles.length > 0 ? (
          profiles.map((profile) => <ProfileCard key={profile._id} profile={profile} />)
        ) : (
          <div className="flex flex-col items-center justify-center">
            <p className="mb-4 text-lg">You don&apos;t have any profiles yet.</p>
            <CreateProfileModal />
          </div>
        )}
      </div>
    </div>
  )
}



================================================
FILE: app/(dashboard)/dashboard/[profileId]/page.tsx
================================================
'use client'

import { api } from '@/convex/_generated/api'
import { useQuery } from 'convex/react'
import { useParams } from 'next/navigation'
import { Id } from '@/convex/_generated/dataModel'
import { ProfilePreview } from '@/components/dashboard/profile-preview'

export default function ProfileDashboardPage() {
  const params = useParams()
  const profileId = params.profileId as Id<'profiles'>

  const profile = useQuery(api.profiles.getComplete, { profileId })

  if (!profile) {
    return null // TODO: Handle loading state here
  }

  return <ProfilePreview profile={profile} />
}



================================================
FILE: app/(dashboard)/dashboard/subscription/page.tsx
================================================
'use client'

import { api } from '@/convex/_generated/api'
import { useQuery } from 'convex/react'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Check, ExternalLink } from 'lucide-react'
import { SubscribeButton } from "@/components/monetization/subscribe-button"
import { PaymentList } from "@/components/monetization/payment-list"
import { Button } from '@/components/ui/button'
import { useAction } from 'convex/react'
import { useState } from 'react'
import { toast } from 'sonner'

export default function SubscriptionPage() {
  const subscription = useQuery(api.subscriptions.getUserSubscription)
  const plans = useQuery(api.subscriptions.getSubscriptionPlans)
  const createPortalSession = useAction(api.subscriptions.createCustomerPortalSession)
  const [isLoading, setIsLoading] = useState(false)

  const handleManageSubscription = async () => {
    if (!subscription) return

    setIsLoading(true)
    try {
      const portalUrl = await createPortalSession({})
      if (portalUrl) {
        window.location.href = portalUrl
      } else {
        toast.error('Could not access subscription management')
      }
    } catch (error) {
      console.error('Error opening customer portal:', error)
      toast.error('Failed to open subscription management portal')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="container mx-auto max-w-7xl py-6">
      <div className="mb-6 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h1 className="text-2xl font-bold">Subscription Management</h1>
        </div>

        {subscription && ['active', 'trialing'].includes(subscription.status) && (
          <Button
            onClick={handleManageSubscription}
            disabled={isLoading}
            variant="outline"
            className="flex items-center gap-2"
          >
            <ExternalLink className="h-4 w-4" />
            {isLoading ? 'Loading...' : 'Manage in Stripe'}
          </Button>
        )}
      </div>

      <div className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle>Subscription Plans</CardTitle>
            <CardDescription>Choose a plan that works for you</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid gap-6 md:grid-cols-3">
              {/* Starter Plan */}
              <Card
                className={`border-2 ${subscription?.planType === 'STARTER' ? 'border-primary shadow-lg' : 'hover:border-primary/50'} transition-all`}
              >
                <CardHeader>
                  <CardTitle className="text-xl">Starter</CardTitle>
                  <div className="mt-2">
                    <span className="text-3xl font-bold">$9</span>
                    <span className="text-muted-foreground ml-1">/month</span>
                  </div>
                </CardHeader>
                <CardContent className="flex flex-col justify-between h-[320px]">
                  <div className="space-y-2 text-sm">
                    {plans?.STARTER.features.map((feature, index) => (
                      <div key={index} className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{feature}</span>
                      </div>
                    ))}
                    <div className="pt-2 mt-3 border-t border-border">
                      <p className="text-xs font-medium mb-1 text-muted-foreground">PLAN LIMITS:</p>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{plans?.STARTER.limits.profiles} Profile</span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>Up to {plans?.STARTER.limits.linksPerProfile} Links per Profile</span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>Up to {plans?.STARTER.limits.itemsPerProfile} Items per Profile</span>
                      </div>
                    </div>
                  </div>
                  <SubscribeButton planType="STARTER" className="w-full mt-4">
                    {subscription?.planType === 'STARTER' ? 'Current Plan' : 'Subscribe'}
                  </SubscribeButton>
                </CardContent>
              </Card>

              {/* Pro Plan */}
              <Card
                className={`border-2 ${subscription?.planType === 'PRO' ? 'border-primary shadow-lg' : subscription?.planType !== 'STARTER' ? 'border-primary shadow-lg' : 'hover:border-primary/50'} transition-all`}
              >
                <CardHeader>
                  {subscription?.planType !== 'PRO' && (
                    <div className="bg-primary text-primary-foreground text-xs font-medium px-3 py-1 rounded-full w-fit mb-2">
                      Popular
                    </div>
                  )}
                  <CardTitle className="text-xl">Pro</CardTitle>
                  <div className="mt-2">
                    <span className="text-3xl font-bold">$19</span>
                    <span className="text-muted-foreground ml-1">/month</span>
                  </div>
                </CardHeader>
                <CardContent className="flex flex-col justify-between h-[320px]">
                  <div className="space-y-2 text-sm">
                    {plans?.PRO.features.map((feature, index) => (
                      <div key={index} className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{feature}</span>
                      </div>
                    ))}
                    <div className="pt-2 mt-3 border-t border-border">
                      <p className="text-xs font-medium mb-1 text-muted-foreground">PLAN LIMITS:</p>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{plans?.PRO.limits.profiles} Profiles</span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>Up to {plans?.PRO.limits.linksPerProfile} Links per Profile</span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>Up to {plans?.PRO.limits.itemsPerProfile} Items per Profile</span>
                      </div>
                    </div>
                  </div>
                  <SubscribeButton planType="PRO" className="w-full mt-4">
                    {subscription?.planType === 'PRO' ? 'Current Plan' : 'Subscribe'}
                  </SubscribeButton>
                </CardContent>
              </Card>

              {/* Business Plan */}
              <Card
                className={`border-2 ${subscription?.planType === 'BUSINESS' ? 'border-primary shadow-lg' : 'hover:border-primary/50'} transition-all`}
              >
                <CardHeader>
                  <CardTitle className="text-xl">Business</CardTitle>
                  <div className="mt-2">
                    <span className="text-3xl font-bold">$49</span>
                    <span className="text-muted-foreground ml-1">/month</span>
                  </div>
                </CardHeader>
                <CardContent className="flex flex-col justify-between h-[320px]">
                  <div className="space-y-2 text-sm">
                    {plans?.BUSINESS.features.map((feature, index) => (
                      <div key={index} className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{feature}</span>
                      </div>
                    ))}
                    <div className="pt-2 mt-3 border-t border-border">
                      <p className="text-xs font-medium mb-1 text-muted-foreground">PLAN LIMITS:</p>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>{plans?.BUSINESS.limits.profiles} Profiles</span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>
                          Up to {plans?.BUSINESS.limits.linksPerProfile} Links per Profile
                        </span>
                      </div>
                      <div className="flex items-center">
                        <Check className="w-4 h-4 mr-2 text-green-500" />
                        <span>
                          Up to {plans?.BUSINESS.limits.itemsPerProfile} Items per Profile
                        </span>
                      </div>
                    </div>
                  </div>
                  <SubscribeButton planType="BUSINESS" className="w-full mt-4">
                    {subscription?.planType === 'BUSINESS' ? 'Current Plan' : 'Subscribe'}
                  </SubscribeButton>
                </CardContent>
              </Card>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Payment History</CardTitle>
            <CardDescription>View your payment history and receipts</CardDescription>
          </CardHeader>
          <CardContent>
            <PaymentList />
          </CardContent>
        </Card>
      </div>
    </div>
  )
}



================================================
FILE: app/(pages)/layout.tsx
================================================
import { LandingHeader } from '@/components/layout/main-header'
import { ReactNode } from 'react'

export default function MainLayout({ children }: { children: ReactNode }) {
  return (
    <main className="flex flex-col flex-1 w-full h-screen">
      <LandingHeader />
      <div className="flex flex-col justify-center w-full h-full">{children}</div>
    </main>
  )
}



================================================
FILE: app/(pages)/page.tsx
================================================
'use client'

import { useEffect, useState } from 'react'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Check, ChevronRight, Loader2, UserCircle, X } from 'lucide-react'
import { Card } from '@/components/ui/card'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { toKebabCase } from '@/lib/utils'

export default function LandingPage() {
  const [handle, setHandle] = useState('')
  const [debouncedHandle, setDebouncedHandle] = useState(handle)

  useEffect(() => {
    const handler = setTimeout(() => setDebouncedHandle(handle), 400)
    return () => clearTimeout(handler)
  }, [handle])

  const shouldCheck = debouncedHandle.length > 0
  const profile = useQuery(
    api.profiles.getByHandle,
    shouldCheck ? { handle: debouncedHandle } : 'skip',
  )

  const isAvailable = shouldCheck && profile === null
  const isTaken = shouldCheck && profile !== undefined && profile !== null

  return (
    <div className="flex flex-col items-center w-full text-foreground">
      <section className="flex flex-col items-center w-full max-w-4xl px-4 py-16">
        <h1 className="max-w-5xl mb-2 text-5xl font-extrabold leading-tight text-center md:text-7xl">
          The home for your digital business
        </h1>
        <p className="max-w-4xl text-xl font-medium text-center md:text-2xl text-muted-foreground">
          Sell digital products, accept payments, and grow your audience — all in one place.
        </p>
        <form
          className="flex flex-col items-center w-full max-w-2xl gap-4 mt-10 md:flex-row"
          onSubmit={(e) => {
            e.preventDefault()
            // TODO: handle claim logic here
          }}
        >
          <div className="flex-1 w-full">
            <Card className="flex flex-row items-center gap-2 px-5 py-3 border rounded-md border-border focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2 focus-within:ring-offset-background group md:text-sm">
              <UserCircle className="w-4 transition-colors text-muted-foreground group-focus-within:text-primary md:h-4" />
              <span className="font-semibold transition-colors text-muted-foreground group-focus-within:text-primary">
                monolink.cc/
              </span>
              <Input
                type="text"
                placeholder="your-handle"
                autoComplete="off"
                value={handle}
                onChange={(e) => {
                  setHandle(toKebabCase(e.target.value))
                }}
                className="font-semibold pl-0 flex-1 text-left !bg-transparent border-0 shadow-none focus-visible:ring-0 focus-visible:ring-offset-0"
                required
              />
              {shouldCheck &&
                (profile === undefined ? (
                  <Loader2 className="w-5 h-5 animate-spin text-muted-foreground" />
                ) : isAvailable ? (
                  <Check className="w-5 h-5 text-green-300" />
                ) : isTaken ? (
                  <X className="w-5 h-5 text-red-300" />
                ) : null)}
            </Card>
          </div>
          <Button type="submit" size="huge">
            Claim your handle <ChevronRight />
          </Button>
        </form>
        <div className="mt-4 text-xs text-center text-muted-foreground">
          It&apos;s free, and takes less than a minute.
        </div>
      </section>
    </div>
  )
}



================================================
FILE: app/(pages)/sign-in/page.tsx
================================================
import { SignInForm } from '@/components/auth/sign-in-form'

export default function SignInPage() {
  return <SignInForm />
}



================================================
FILE: app/(pages)/sign-up/page.tsx
================================================
import { SignInForm } from '@/components/auth/sign-in-form'

export default function SignUpPage() {
  return <SignInForm />
}



================================================
FILE: app/[handle]/layout.tsx
================================================
import { ReactNode } from 'react'
import { Doc } from '@/convex/_generated/dataModel'
import { Metadata } from 'next'

export const dynamicParams = true

export const revalidate = 3600 // Revalidate every hour

// Pre-generate static pages for popular profiles
export async function generateStaticParams() {
  try {
    // This would normally fetch popular profiles to pre-render
    // For demonstration, we'll use a limited set
    const popularHandles = ['demo', 'test']

    return popularHandles.map((handle) => ({
      handle,
    }))
  } catch (error) {
    console.error('Error generating static params:', error)
    return []
  }
}

type MetadataProps = {
  params: Promise<{ handle: Doc<'profiles'>['handle'] }>
}

export async function generateMetadata({ params }: MetadataProps): Promise<Metadata> {
  const { handle } = await params

  return {
    title: `${handle} | MonoLink Profile`,
    description: `View ${handle}'s MonoLink profile`,
    openGraph: {
      title: `${handle} | MonoLink Profile`,
      description: `View ${handle}'s MonoLink profile`,
      type: 'profile',
    },
  }
}

type LayoutProps = {
  children: ReactNode
  params: Promise<{ handle: Doc<'profiles'>['handle'] }>
}

export default async function PublicProfileLayout({ children }: LayoutProps) {
  return (
    <div className="container mx-auto py-8">
      <div className="max-w-screen-md mx-auto">{children}</div>
    </div>
  )
}


================================================
FILE: app/[handle]/page.tsx
================================================
import { api } from '@/convex/_generated/api'
import { fetchQuery } from 'convex/nextjs'
import { Doc } from '@/convex/_generated/dataModel'
import { PublicProfileContent } from '@/components/profile/sections/public-profile-content'

type PageProps = {
  params: Promise<{ handle: Doc<'profiles'>['handle'] }>
}

export default async function UserPage({ params }: PageProps) {
  const { handle } = await params

  const profile = await fetchQuery(api.profiles.getComplete, { handle })

  if (!profile) {
    return (
      <div className="flex items-center justify-center p-8">
        <p className="text-lg font-medium">Profile not found</p>
      </div>
    )
  }

  return <PublicProfileContent profile={profile} />
}



================================================
FILE: assets/monolink-logo.tsx
================================================
const MonolinkLogo = ({ className }: { className?: string }) => {
  return (
    <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" fill="none">
      <title>link</title>
      <g>
        <path
          d="M8.5,6.827c-.352,.168-.682,.398-.973,.69l-.01,.01c-1.381,1.381-1.381,3.619,0,5l2.175,2.175c1.381,1.381,3.619,1.381,5,0l.01-.01c1.381-1.381,1.381-3.619,0-5l-.931-.931"
          stroke="currentColor"
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth="1.5"
        />
        <path
          d="M9.5,11.173c.352-.168,.682-.398,.973-.69l.01-.01c1.381-1.381,1.381-3.619,0-5l-2.175-2.175c-1.381-1.381-3.619-1.381-5,0l-.01,.01c-1.381,1.381-1.381,3.619,0,5l.931,.931"
          stroke="currentColor"
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth="1.5"
        />
      </g>
    </svg>
  )
}

export default MonolinkLogo



================================================
FILE: components/auth/sign-in-form.tsx
================================================
'use client'

import { useAuthActions } from '@convex-dev/auth/react'
import { useState } from 'react'
import { toast } from 'sonner'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Eye, EyeOff, Link, Lock, Mail, User } from 'lucide-react'
import { useRouter } from 'next/navigation'
import { Label } from '@/components/ui/label'
import { Checkbox } from '@/components/ui/checkbox'

import GoogleIcon from '@/assets/logos/google-icon.svg'
import Image from 'next/image'

export function SignInForm() {
  const { signIn } = useAuthActions()
  const [submitting, setSubmitting] = useState(false)
  const [showPassword, setShowPassword] = useState(false)
  const [magicLink, setMagicLink] = useState(false)
  const router = useRouter()

  const handleLogin = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setSubmitting(true)
    const formData = new FormData(e.currentTarget)
    try {
      await signIn('password', formData)
      router.push('/dashboard')
    } catch {
      toast.error('Could not sign in. Please check your credentials and try again.')
      setSubmitting(false)
    }
  }

  const handleMagicLink = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setSubmitting(true)
    const formData = new FormData(e.currentTarget)
    try {
      await signIn('resend', formData)
      toast.success('Magic link sent! Check your email.')
    } catch {
      toast.error('Could not send magic link. Please try again.')
      setSubmitting(false)
    }
  }

  return (
    <>
      <Card className="w-full max-w-sm mx-auto">
        <CardHeader className="flex flex-col items-center gap-2">
          <div className="relative flex items-center justify-center mb-2">
            <div
              className="p-1 rounded-full"
              style={{
                background: 'radial-gradient(circle, var(--muted) 60%, var(--background) 100%)',
              }}
            >
              <div className="flex items-center justify-center w-16 h-16 bg-white rounded-full dark:bg-background">
                <User size={40} className="text-muted-foreground" />
              </div>
            </div>
          </div>
          <CardTitle className="text-2xl text-center">Login to your account</CardTitle>
          <CardDescription className="text-center">Enter your details to login</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex gap-2">
            <Button
              type="button"
              variant="outline"
              className="flex-1 gap-3 py-4"
              onClick={() => void signIn('google')}
              disabled={submitting}
            >
              <Image src={GoogleIcon} alt="Google Icon" width={16} height={16} />
              Google
            </Button>
            <Button
              type="button"
              variant="outline"
              className="flex-1 gap-3 py-4"
              onClick={() => setMagicLink((v) => !v)}
              disabled={submitting}
            >
              {magicLink ? <Lock width={16} height={16} /> : <Link width={16} height={16} />}
              {magicLink ? 'Password' : 'Magic Link'}
            </Button>
          </div>
          <div className="flex items-center py-4">
            <div className="flex-1 h-px bg-border" />
            <span className="mx-4 text-xs font-medium text-muted-foreground">OR</span>
            <div className="flex-1 h-px bg-border" />
          </div>
          {!magicLink ? (
            <form className="flex flex-col gap-3" onSubmit={handleLogin}>
              <div className="flex flex-col gap-1.5">
                <Label htmlFor="email">Email Address</Label>
                <div className="relative">
                  <span className="absolute -translate-y-1/2 text-muted-foreground left-3 top-1/2">
                    <Mail size={18} />
                  </span>
                  <Input
                    id="email"
                    type="email"
                    name="email"
                    placeholder="hello@example.com"
                    required
                    className="pl-10"
                    disabled={submitting}
                  />
                </div>
              </div>
              <div className="flex flex-col gap-1.5">
                <Label htmlFor="password">Password</Label>
                <div className="relative">
                  <span className="absolute -translate-y-1/2 left-3 top-1/2 text-muted-foreground">
                    <Lock size={18} />
                  </span>
                  <Input
                    id="password"
                    type={showPassword ? 'text' : 'password'}
                    name="password"
                    placeholder="Password"
                    required
                    className="pl-10 pr-10"
                    disabled={submitting}
                  />
                  <button
                    type="button"
                    tabIndex={-1}
                    className="absolute -translate-y-1/2 right-3 top-1/2 text-muted-foreground"
                    onClick={() => setShowPassword((v) => !v)}
                    aria-label={showPassword ? 'Hide password' : 'Show password'}
                  >
                    {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                  </button>
                </div>
              </div>
              <div className="flex items-center justify-between">
                <Label className="flex items-center gap-2 text-xs">
                  <Checkbox />
                  Keep me logged in
                </Label>
                <Button
                  variant="link"
                  className="p-0 text-xs"
                  type="button"
                  onClick={() => router.push('/forgot-password')}
                >
                  Forgot password?
                </Button>
              </div>
              <Button type="submit" disabled={submitting}>
                Login
              </Button>
            </form>
          ) : (
            <form className="flex flex-col gap-3" onSubmit={handleMagicLink}>
              <div className="flex flex-col gap-1.5">
                <Label htmlFor="magic-email">Email Address</Label>
                <div className="relative">
                  <span className="absolute -translate-y-1/2 text-muted-foreground left-3 top-1/2">
                    <Mail size={18} />
                  </span>
                  <Input
                    id="magic-email"
                    type="email"
                    name="email"
                    placeholder="hello@example.com"
                    required
                    className="pl-10"
                    disabled={submitting}
                  />
                </div>
              </div>
              <Button type="submit" disabled={submitting}>
                Send Magic Link
              </Button>
            </form>
          )}
        </CardContent>
      </Card>
      <div className="items-center pt-4 text-xs text-center text-muted-foreground">
        <span>Don&apos;t have an account? </span>
        <Button
          variant="link"
          size="sm"
          className="p-0 text-xs"
          onClick={() => router.push('/sign-up')}
        >
          Sign up instead
        </Button>
      </div>
    </>
  )
}



================================================
FILE: components/auth/sign-out-button.tsx
================================================
"use client"

import { Button } from "@/components/ui/button";
import { useAuthActions } from "@convex-dev/auth/react";
import { redirect } from "next/navigation";

export function SignOutButton() {
  const { signOut } = useAuthActions();

  return (
    <Button onClick={() => signOut().then(() => redirect("/"))}>
      Sign out
    </Button>
  );
}


================================================
FILE: components/common/animated-tabs.tsx
================================================
'use client'

import React, { useEffect } from 'react'
import { motion } from 'motion/react'

import { cn } from '@/lib/utils'
import { useRouter, usePathname } from 'next/navigation'

interface Tab {
  label: string
  value: string
  subRoutes?: string[]
  href?: string
  icon?: React.ReactNode
}

interface AnimatedTabsProps {
  tabs: Tab[]
}

const transition = {
  type: 'tween',
  ease: 'easeOut',
  duration: 0.15,
}

const getHoverAnimationProps = (hoveredRect: DOMRect, navRect: DOMRect) => ({
  x: hoveredRect.left - navRect.left - 16,
  y: hoveredRect.top - navRect.top - 5,
  width: hoveredRect.width + 32,
  height: hoveredRect.height + 12,
})

const Tabs = ({
  tabs,
  selectedTabIndex,
  setSelectedTab,
}: {
  tabs: Tab[]
  selectedTabIndex: number
  setSelectedTab: (input: [number, number]) => void
}): React.ReactElement => {
  const router = useRouter()
  const [buttonRefs, setButtonRefs] = React.useState<Array<HTMLButtonElement | null>>([])

  useEffect(() => {
    setButtonRefs((prev) => prev.slice(0, tabs.length))
  }, [tabs.length])

  const navRef = React.useRef<HTMLDivElement>(null)
  const navRect = navRef.current?.getBoundingClientRect()

  const selectedRect =
    selectedTabIndex !== -1 ? buttonRefs[selectedTabIndex]?.getBoundingClientRect() : undefined

  const [hoveredTabIndex, setHoveredTabIndex] = React.useState<number | null>(null)
  const hoveredRect = buttonRefs[hoveredTabIndex ?? -1]?.getBoundingClientRect()

  return (
    <nav
      ref={navRef}
      className="relative z-0 flex items-center justify-center flex-shrink-0 py-2"
      onPointerLeave={() => setHoveredTabIndex(null)}
    >
      {tabs.map((item, i) => {
        const isActive = selectedTabIndex === i

        return (
          <button
            key={item.value}
            className={cn(
              'relative z-20 flex items-center h-8 px-4 text-sm transition-colors bg-transparent rounded-md cursor-pointer select-none',
            )}
            onPointerEnter={() => setHoveredTabIndex(i)}
            onFocus={() => setHoveredTabIndex(i)}
            onClick={() => {
              setSelectedTab([i, i > selectedTabIndex ? 1 : -1])
              if (item.href) {
                router.push(item.href)
              }
            }}
            type="button"
          >
            <motion.span
              ref={(el) => {
                buttonRefs[i] = el as HTMLButtonElement
              }}
              className={cn('flex items-center font-semibold transition-colors duration-300', {
                'text-primary/60': !isActive,
                'text-primary': isActive,
              })}
            >
              {item.icon}
              <small>{item.label}</small>
            </motion.span>
          </button>
        )
      })}

      {hoveredRect && navRect && (
        <motion.div
          key="hover"
          className="absolute top-0 left-0 z-10 p-0 m-0 rounded-sm bg-muted"
          initial={{ ...getHoverAnimationProps(hoveredRect, navRect), opacity: 0 }}
          animate={{ ...getHoverAnimationProps(hoveredRect, navRect), opacity: 1 }}
          exit={{ ...getHoverAnimationProps(hoveredRect, navRect), opacity: 0 }}
          transition={transition}
        />
      )}

      {/* Only render underline if a tab is actually selected */}
      {selectedRect && navRect && selectedTabIndex !== -1 && (
        <motion.div
          className={`absolute rounded-t-full z-10 bottom-0 left-0 h-[2px] bg-black dark:bg-white`}
          initial={false}
          animate={{
            width: selectedRect.width + 18,
            x: `calc(${selectedRect.left - navRect.left - 9}px)`,
            opacity: 1,
          }}
          transition={transition}
        />
      )}
    </nav>
  )
}

export function AnimatedTabs({ tabs }: AnimatedTabsProps) {
  const pathname = usePathname()

  const selectedTabIndex = React.useMemo(() => {
    return tabs.findIndex((tab) => tab.href && pathname.startsWith(tab.href))
  }, [tabs, pathname])

  const setSelectedTab = React.useCallback(() => {}, [])

  return (
    <div className="w-full">
      <div className="relative flex items-center justify-between w-full overflow-x-auto overflow-y-hidden">
        <Tabs tabs={tabs} selectedTabIndex={selectedTabIndex} setSelectedTab={setSelectedTab} />
      </div>
    </div>
  )
}



================================================
FILE: components/common/logo.tsx
================================================
import MonolinkLogo from '@/assets/monolink-logo'
import Link from 'next/link'

export default function Logo({ href = '/' }: { href?: string }) {
  return (
    <Link href={href} className="flex items-center gap-2 text-sm font-bold">
      <MonolinkLogo className="w-8 h-8 p-2 rounded-md bg-secondary stroke-primary aspect-square" />
      monolink.cc
    </Link>
  )
}



================================================
FILE: components/common/radial-progress.tsx
================================================
export function RadialProgress({ progress }: { progress: number }) {
  const radius = 30
  const circumference = 2 * Math.PI * radius
  return (
    <div className="inline-flex items-center justify-center overflow-hidden rounded-full relative">
      <svg className="w-20 h-20">
        <circle
          className="text-muted"
          strokeWidth={4}
          stroke="currentColor"
          fill="transparent"
          r={radius}
          cx="40"
          cy="40"
        />
        <circle
          className="text-primary"
          strokeWidth={4}
          strokeDasharray={circumference}
          strokeDashoffset={circumference * (1 - progress / 100)}
          strokeLinecap="round"
          stroke="currentColor"
          fill="transparent"
          r={radius}
          cx="40"
          cy="40"
        />
      </svg>
      <span className="absolute text-sm text-primary">{progress}%</span>
    </div>
  )
}



================================================
FILE: components/common/theme-switch.tsx
================================================
'use client'

import { useTheme } from 'next-themes'
import { Moon, Sun } from 'lucide-react'

import { Button } from '@/components/ui/button'

export default function ThemeSwitch() {
  const { theme, setTheme } = useTheme()
  return (
    <Button variant="ghost" size="icon" onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
      {theme === 'dark' ? <Sun className="w-5 h-5" /> : <Moon className="w-5 h-5" />}
    </Button>
  )
}



================================================
FILE: components/dashboard/content-tab.tsx
================================================
'use client'

import { useState } from 'react'
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { PlusCircle } from 'lucide-react'
import { LinkForm } from '@/components/forms/link-form'
import { ItemForm } from '@/components/forms/item-form'
import { ProfileComplete } from '@/types/profile'

interface ContentTabProps {
  profile: ProfileComplete
}

export function ContentTab({ profile }: ContentTabProps) {
  // Modal state
  const [isAddingLink, setIsAddingLink] = useState(false)
  const [isAddingItem, setIsAddingItem] = useState(false)

  return (
    <>
      <div className="space-y-8">
        {/* Links Section */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <div>
              <CardTitle>Links</CardTitle>
              <CardDescription>Add or manage your profile links</CardDescription>
            </div>
            <Button size="sm" className="gap-1" onClick={() => setIsAddingLink(true)}>
              <PlusCircle className="w-4 h-4" />
              Add Link
            </Button>
          </CardHeader>
          <CardContent>
            {profile.links && profile.links.length > 0 ? (
              <ul className="space-y-3">
                {profile.links.map((link) => (
                  <li
                    key={link._id}
                    className="flex items-center justify-between p-3 border rounded-md"
                  >
                    <div>
                      <div className="font-medium">{link.title}</div>
                      <div className="text-xs text-muted-foreground truncate max-w-[400px]">
                        {link.url}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button variant="ghost" size="sm" className="h-8">
                        Edit
                      </Button>
                    </div>
                  </li>
                ))}
              </ul>
            ) : (
              <div className="py-12 text-center border-2 border-dashed rounded-md border-border">
                <p className="mb-2 text-muted-foreground">No links added yet</p>
                <Button
                  variant="outline"
                  size="sm"
                  className="gap-1"
                  onClick={() => setIsAddingLink(true)}
                >
                  <PlusCircle className="w-4 h-4" />
                  Add Your First Link
                </Button>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Items Section */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <div>
              <CardTitle>Items</CardTitle>
              <CardDescription>Products, services or other profile.items</CardDescription>
            </div>
            <Button size="sm" className="gap-1" onClick={() => setIsAddingItem(true)}>
              <PlusCircle className="w-4 h-4" />
              Add Item
            </Button>
          </CardHeader>
          <CardContent>
            {profile.items && profile.items.length > 0 ? (
              <ul className="space-y-3">
                {profile.items.map((item) => (
                  <li
                    key={item._id}
                    className="flex items-center justify-between p-3 border rounded-md"
                  >
                    <div>
                      <div className="font-medium">{item.title}</div>
                      <div className="text-xs text-muted-foreground line-clamp-1 max-w-[400px]">
                        {item.description}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button variant="ghost" size="sm" className="h-8">
                        Edit
                      </Button>
                    </div>
                  </li>
                ))}
              </ul>
            ) : (
              <div className="py-12 text-center border-2 border-dashed rounded-md border-border">
                <p className="mb-2 text-muted-foreground">No items added yet</p>
                <Button
                  variant="outline"
                  size="sm"
                  className="gap-1"
                  onClick={() => setIsAddingItem(true)}
                >
                  <PlusCircle className="w-4 h-4" />
                  Add Your First Item
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Add Link Dialog */}
      <Dialog open={isAddingLink} onOpenChange={setIsAddingLink}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Link</DialogTitle>
          </DialogHeader>
          <LinkForm profileId={profile._id} onClose={() => setIsAddingLink(false)} />
        </DialogContent>
      </Dialog>

      {/* Add Item Dialog */}
      <Dialog open={isAddingItem} onOpenChange={setIsAddingItem}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Item</DialogTitle>
          </DialogHeader>
          <ItemForm profileId={profile._id} onClose={() => setIsAddingItem(false)} />
        </DialogContent>
      </Dialog>
    </>
  )
}



================================================
FILE: components/dashboard/layout-tab.tsx
================================================
'use client'

import { useState, useEffect } from 'react'
import { ProfileComplete, Section } from '@/types/profile'
import { Switch } from '@/components/ui/switch'
import { Label } from '@/components/ui/label'
import { ArrowUpDown } from 'lucide-react'

interface LayoutTabProps {
  profile: ProfileComplete
  onSectionsChange?: (sections: Section[]) => void
}

export function LayoutTab({ profile, onSectionsChange }: LayoutTabProps) {
  const [localSections, setLocalSections] = useState<Section[]>([])

  // Update local sections when prop changes
  useEffect(() => {
    if (profile.sections) {
      setLocalSections(profile.sections)
    }
  }, [profile.sections])

  const handleVisibilityChange = (sectionId: string, visible: boolean) => {
    const updatedSections = localSections.map((section) =>
      section.id === sectionId ? { ...section, visible } : section,
    )

    setLocalSections(updatedSections)

    if (onSectionsChange) {
      onSectionsChange(updatedSections)
    }
  }

  const getSectionName = (type: string): string => {
    switch (type) {
      case 'avatar':
        return 'Profile Avatar & Bio'
      case 'donation':
        return 'Donation Section'
      case 'links':
        return 'Links List'
      case 'items':
        return 'Items & Products'
      default:
        return type.charAt(0).toUpperCase() + type.slice(1)
    }
  }

  // If no sections are available yet, show loading state
  if (!localSections.length) {
    return <div className="py-4">Loading section settings...</div>
  }

  return (
    <div className="space-y-6">
      <div className="pb-4 border-b">
        <h3 className="text-lg font-medium">Layout Settings</h3>
        <p className="text-sm text-muted-foreground">
          Customize your profile&apos;s section layout
        </p>
      </div>

      <div className="space-y-4">
        <div className="grid gap-2">
          <h4 className="font-medium">Profile Sections</h4>
          <p className="text-sm text-muted-foreground">
            Toggle which sections appear on your profile
          </p>
        </div>

        <div className="space-y-4">
          {localSections
            .sort((a, b) => a.order - b.order)
            .map((section) => (
              <div key={section.id} className="flex items-center justify-between py-2">
                <div className="flex items-center gap-2">
                  <ArrowUpDown className="w-4 h-4 text-muted-foreground" />
                  <Label htmlFor={`toggle-${section.id}`} className="font-medium">
                    {getSectionName(section.type)}
                  </Label>
                </div>
                <Switch
                  id={`toggle-${section.id}`}
                  checked={section.visible}
                  onCheckedChange={(checked) => handleVisibilityChange(section.id, checked)}
                />
              </div>
            ))}
        </div>
      </div>

      <div className="mt-4 p-4 bg-muted/50 rounded-lg">
        <p className="text-sm text-muted-foreground">
          Drag sections in the preview to reorder them. Toggle switches to show or hide sections.
          Click the &quot;Save Layout Changes&quot; button at the top when you&apos;re done.
        </p>
      </div>
    </div>
  )
}



================================================
FILE: components/dashboard/monetization-tab.tsx
================================================
import { Id } from '@/convex/_generated/dataModel'
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'
import { StripeConnectSection } from "@/components/monetization/stripe-connect-section"
import { StripeEarningsDashboard } from "@/components/monetization/stripe-earnings-dashboard"

interface MonetizationTabProps {
  profileId: Id<'profiles'>
}

export function MonetizationTab({ profileId }: MonetizationTabProps) {
  return (
    <Tabs defaultValue="connect" className="flex-1 flex flex-col min-h-0">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="connect">Connect Stripe</TabsTrigger>
        <TabsTrigger value="earnings">Earnings Dashboard</TabsTrigger>
      </TabsList>
      <TabsContent value="connect" className="mt-4 flex-1 min-h-0">
        <StripeConnectSection profileId={profileId} />
      </TabsContent>
      <TabsContent value="earnings" className="mt-4 flex-1 min-h-0">
        <StripeEarningsDashboard profileId={profileId} />
      </TabsContent>
    </Tabs>
  )
}



================================================
FILE: components/dashboard/profile-content-tabs.tsx
================================================
'use client'

import { ProfileSettings } from "@/components/profile/editor/profile-settings"
import { MonetizationTab } from '@/components/dashboard/monetization-tab'
import { AppearanceManager } from "@/components/profile/editor/appearance-manager"
import { ProfileComplete } from '@/types/profile'

interface ProfileTabProps {
  profile: ProfileComplete
}

export function AppearanceTab({ profile }: ProfileTabProps) {
  return <AppearanceManager profile={profile} showFullPreview={true} />
}

export function SettingsTab({ profile }: ProfileTabProps) {
  return <ProfileSettings profile={profile} />
}

export function MonetizationSettingsTab({ profile }: ProfileTabProps) {
  return <MonetizationTab profileId={profile._id} />
}



================================================
FILE: components/dashboard/profile-customisation-tabs.tsx
================================================
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { ContentTab } from '@/components/dashboard/content-tab'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { cn } from '@/lib/utils'
import { ScrollArea } from '@/components/ui/scroll-area'
import { ProfileComplete, Section } from '@/types/profile'
import { useState } from 'react'
import { AppearanceTab, MonetizationSettingsTab, SettingsTab } from './profile-content-tabs'
import { LayoutTab } from './layout-tab'

export default function ProfileCustomisationTabs({
  profile,
  className,
  onTabChange,
  onSectionsChange,
}: {
  profile: ProfileComplete
  className?: string
  onTabChange?: (tab: string) => void
  onSectionsChange?: (sections: Section[]) => void
}) {
  const [activeTab, setActiveTab] = useState('content')

  // Notify parent when tab changes
  const handleTabChange = (value: string) => {
    setActiveTab(value)
    if (onTabChange) {
      onTabChange(value)
    }
  }

  return (
    <Card className={cn('overflow-hidden h-full flex flex-col', className)}>
      <CardHeader>
        <CardTitle>Customize your profile</CardTitle>
      </CardHeader>
      <Tabs
        defaultValue="content"
        className="flex flex-col flex-1 min-h-0"
        value={activeTab}
        onValueChange={handleTabChange}
      >
        <CardContent className="flex flex-col flex-1 min-h-0">
          <TabsList className="grid w-full grid-cols-5 mb-6">
            <TabsTrigger value="content" className="gap-1.5">
              <span>Content</span>
            </TabsTrigger>
            <TabsTrigger value="appearance" className="gap-1.5">
              <span>Appearance</span>
            </TabsTrigger>
            <TabsTrigger value="layout" className="gap-1.5">
              <span>Layout</span>
            </TabsTrigger>
            <TabsTrigger value="monetization" className="gap-1.5">
              <span>Monetization</span>
            </TabsTrigger>
            <TabsTrigger value="settings" className="gap-1.5">
              <span>Settings</span>
            </TabsTrigger>
          </TabsList>

          <ScrollArea className="flex-1 min-h-0">
            <TabsContent value="content" className="h-full m-0">
              <ContentTab profile={profile} />
            </TabsContent>

            <TabsContent value="appearance" className="h-full m-0">
              <AppearanceTab profile={profile} />
            </TabsContent>

            <TabsContent value="layout" className="h-full m-0">
              <LayoutTab profile={profile} onSectionsChange={onSectionsChange} />
            </TabsContent>

            <TabsContent value="monetization" className="h-full m-0">
              <MonetizationSettingsTab profile={profile} />
            </TabsContent>

            <TabsContent value="settings" className="h-full m-0">
              <SettingsTab profile={profile} />
            </TabsContent>
          </ScrollArea>
        </CardContent>
      </Tabs>
    </Card>
  )
}



================================================
FILE: components/dashboard/profile-preview.tsx
================================================
'use client'

import { useEffect, useState } from 'react'
import { Smartphone, Monitor } from 'lucide-react'
import { getProfileCardClasses } from '@/lib/theme-mappings'
import ProfileCustomisationTabs from './profile-customisation-tabs'
import { ProfileContent } from '@/components/profile/sections/profile-content'
import { ProfileComplete, Section } from '@/types/profile'
import { useMutation, useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { toast } from 'sonner'
import { Button } from '../ui/button'

interface ProfilePreviewProps {
  profile: ProfileComplete
}

export function ProfilePreview({ profile }: ProfilePreviewProps) {
  const [activeView, setActiveView] = useState<'mobile' | 'desktop'>('mobile')
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

  // Get saved sections from the backend
  const savedSections = useQuery(api.profileLayouts.getProfileSections, {
    profileId: profile._id,
  })

  const updateSections = useMutation(api.profileLayouts.updateProfileSections)

  // Track current sections being edited
  const [currentSections, setCurrentSections] = useState<Section[] | null>(null)

  // Update local sections when saved sections are loaded from the backend
  useEffect(() => {
    if (savedSections) {
      setCurrentSections(savedSections)
    }
  }, [savedSections])

  // Handle updates to sections from the drag-and-drop content
  const handleSectionsChange = (sections: Section[]) => {
    // Use setTimeout to avoid state updates during rendering
    setTimeout(() => {
      setCurrentSections(sections)
      setHasUnsavedChanges(true)
    }, 0)
  }

  // Save changes to the backend
  const saveLayoutChanges = async () => {
    if (!currentSections) return

    try {
      await updateSections({
        profileId: profile._id,
        sections: currentSections,
      })
      toast.success('Layout saved successfully')
      setHasUnsavedChanges(false)
    } catch (error) {
      console.error('Error saving layout:', error)
      toast.error('Failed to save layout')
    }
  }

  return (
    <>
      <div
        className={`${getProfileCardClasses(profile.theme.settings)} p-6 sm:p-8 gap-12 flex flex-row items-start justify-between w-full h-full`}
      >
        <div className="items-center w-full mx-auto">
          <div className="flex justify-between mb-4">
            <div className="bg-muted rounded-lg p-[3px] flex">
              <button
                className={`px-4 py-1 rounded-md flex items-center gap-1 text-sm font-medium transition-colors ${
                  activeView === 'mobile'
                    ? 'bg-background text-foreground shadow-sm'
                    : 'text-muted-foreground'
                }`}
                onClick={() => setActiveView('mobile')}
              >
                <Smartphone className="w-4 h-4" />
                Mobile
              </button>
              <button
                className={`px-4 py-1 rounded-md flex items-center gap-1 text-sm font-medium transition-colors ${
                  activeView === 'desktop'
                    ? 'bg-background text-foreground shadow-sm'
                    : 'text-muted-foreground'
                }`}
                onClick={() => setActiveView('desktop')}
              >
                <Monitor className="w-4 h-4" />
                Desktop
              </button>
            </div>

            {hasUnsavedChanges && (
              <Button size="sm" onClick={saveLayoutChanges}>
                Save Layout Changes
              </Button>
            )}
          </div>

          <div className="items-center mx-auto">
            <div
              className="items-center w-full mx-auto transition-all duration-300"
              style={{
                maxWidth: activeView === 'mobile' ? '320px' : '672px',
                width: activeView === 'desktop' ? '100%' : 'auto',
              }}
            >
              <ProfileContent
                profile={profile}
                isPreview={false}
                onSectionsChange={handleSectionsChange}
              />
            </div>
          </div>
        </div>

        <ProfileCustomisationTabs
          profile={profile}
          className="flex flex-col w-full h-full max-w-xl shadow-sm"
          onSectionsChange={setCurrentSections}
        />
      </div>
    </>
  )
}



================================================
FILE: components/dashboard/layout/dashboard-header.tsx
================================================
import { ProfileSelector } from "@/components/profile/cards/profile-selector"
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { AnimatedTabs } from "@/components/common/animated-tabs"
import Logo from "@/components/common/logo"
import ThemeSwitch from "@/components/common/theme-switch"

export function DashboardHeader() {
  const baseTabs = [
    { label: 'Subscription', value: 'subscription', href: '/dashboard/subscription' },
    { label: 'Feedback', value: 'feedback' },
    { label: 'Changelog', value: 'changelog' },
    { label: 'Help Center', value: 'help-center' },
  ]

  return (
    <header className="sticky top-0 z-30 flex items-center justify-between px-2">
      <div className="flex items-center gap-6">
        <Logo href="/dashboard" />
        <ProfileSelector />
      </div>
      <div className="flex items-center gap-6">
        <AnimatedTabs tabs={baseTabs} />
        <div className="relative">
          <Avatar>
            <AvatarImage src="/avatar.png" alt="User" />
            <AvatarFallback>U</AvatarFallback>
          </Avatar>
          <span className="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 border-2 border-background rounded-full" />
        </div>
        <ThemeSwitch />
      </div>
    </header>
  )
}



================================================
FILE: components/forms/item-form.tsx
================================================
"use client";
import { useState } from "react";
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Doc, Id } from "@/convex/_generated/dataModel";
import { toast } from "sonner";
import { useFileUpload } from "@/hooks/useFileUpload";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";

export function ItemForm({ profileId, onClose }: { profileId: Id<"profiles">; onClose: () => void }) {
  const addItem = useMutation(api.items.add);
  const { uploadFile } = useFileUpload();

  const [form, setForm] = useState({
    title: "",
    description: "",
    itemType: "free" as "paid" | "free" | "link",
    price: "",
    url: "",
    file: null as File | null,
  });

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setForm((prev) => ({ ...prev, file: e.target.files?.[0] || null }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
  
    const toastId = toast.loading("Uploading item...");
  
    try {
      let type: Doc<"items">["type"];
  
      if (form.itemType === "link") {
        type = { kind: "link", url: form.url };
      } else {
        if (!form.file) {
          toast.error("Please select a file", { id: toastId });
          return;
        }
        const fileId = await uploadFile(form.file);
        type =
          form.itemType === "paid"
            ? { kind: "paid", price: Math.round(parseFloat(form.price) * 100), fileId }
            : { kind: "free", fileId };
      }
  
      await addItem({ profileId, title: form.title, description: form.description, type });
      toast.success("Item added successfully", { id: toastId });
      onClose();
    } catch {
      toast.error("Failed to add item", { id: toastId });
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="title">Title</Label>
        <Input id="title" name="title" placeholder="Title" value={form.title} onChange={handleChange} required />
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description</Label>
        <Textarea id="description" name="description" placeholder="Description" value={form.description} onChange={handleChange} required />
      </div>

      <div className="space-y-2">
        <Label htmlFor="itemType">Item Type</Label>
        <Select value={form.itemType} onValueChange={(value) => setForm((prev) => ({ ...prev, itemType: value as "paid" | "free" | "link" }))}>
          <SelectTrigger id="itemType">
            <SelectValue placeholder="Select item type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="free">Free</SelectItem>
            <SelectItem value="paid">Paid</SelectItem>
            <SelectItem value="link">Link</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {form.itemType === "paid" && (
        <div className="space-y-2">
          <Label htmlFor="price">Price (USD)</Label>
          <Input id="price" name="price" type="number" step="0.01" placeholder="Price" value={form.price} onChange={handleChange} required />
        </div>
      )}

      {form.itemType === "link" ? (
        <div className="space-y-2">
          <Label htmlFor="url">URL</Label>
          <Input id="url" name="url" placeholder="URL" value={form.url} onChange={handleChange} required />
        </div>
      ) : (
        <div className="space-y-2">
          <Label htmlFor="file">File</Label>
          <Input id="file" type="file" onChange={handleFileChange} required />
        </div>
      )}

      <div className="flex justify-end gap-2 pt-4">
        <Button type="button" variant="ghost" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit">Add Item</Button>
      </div>
    </form>
  );
}


================================================
FILE: components/forms/link-form.tsx
================================================
"use client";
import { useState } from "react";
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Id } from "@/convex/_generated/dataModel";

export function LinkForm({ profileId, onClose }: { profileId: Id<"profiles">; onClose: () => void }) {
  const addLink = useMutation(api.links.add);
  const [title, setTitle] = useState("");
  const [url, setUrl] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
  
    const toastId = toast.loading("Adding link...");
  
    try {
      await addLink({ profileId, title, url });
      toast.success("Link added successfully", { id: toastId });
      onClose();
    } catch {
      toast.error("Failed to add link", { id: toastId });
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          placeholder="Title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="url">URL</Label>
        <Input
          id="url"
          placeholder="URL"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          required
        />
      </div>

      <div className="flex justify-end gap-2 pt-4">
        <Button type="button" variant="ghost" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit">Add Link</Button>
      </div>
    </form>
  );
}


================================================
FILE: components/forms/profile-form.tsx
================================================
'use client'

import { useState } from 'react'
import { useMutation } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { toast } from 'sonner'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { User, AlignLeft, LinkIcon } from 'lucide-react'
import { useProfileLimits } from '@/hooks/usePlanLimits'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Progress } from '@/components/ui/progress'
import Link from 'next/link'
import { AvatarUpload } from '../media/avatar-upload'

export function ProfileForm({ onSuccess }: { onSuccess?: () => void }) {
  const createProfile = useMutation(api.profiles.create)
  const profileLimits = useProfileLimits()
  const [handle, setHandle] = useState('')
  const [name, setName] = useState('')
  const [bio, setBio] = useState('')
  const [avatarUrl, setAvatarUrl] = useState<string>('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    try {
      await createProfile({
        handle,
        name,
        bio,
        avatarUrl,
      })
      toast.success('Profile created successfully!')
      if (onSuccess) onSuccess()
    } catch (error: unknown) {
      if (error instanceof Error) {
        toast.error(error.message)
      } else {
        toast.error('Failed to create profile')
      }
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {!profileLimits.canCreate && (
        <Alert variant="warning" className="mb-4">
          <AlertDescription>
            <div className="mb-2">
              You have used {profileLimits.currentCount} of {profileLimits.maxProfiles} profiles on
              your current plan.
            </div>
            <Progress value={profileLimits.percentUsed} className="h-1.5 mb-2" />
            <div className="mt-1 text-xs">
              <Link href="/dashboard/subscription" className="text-blue-500 hover:underline">
                Upgrade your plan
              </Link>
              to create more profiles.
            </div>
          </AlertDescription>
        </Alert>
      )}

      <div className="flex gap-4">
        <AvatarUpload handle={handle} onChange={setAvatarUrl} size="sm" />
        <div className="flex flex-col gap-4 w-full">
          <div>
            <div className="relative">
              <span className="absolute -translate-y-1/2 text-muted-foreground left-3 top-1/2">
                <LinkIcon size={18} />
              </span>
              <Input
                placeholder="Handle"
                value={handle}
                onChange={(e) => setHandle(e.target.value)}
                className="w-full p-2 pl-10"
                required
              />
            </div>
          </div>
          <div>
            <div className="relative">
              <span className="absolute -translate-y-1/2 text-muted-foreground left-3 top-1/2">
                <User size={18} />
              </span>
              <Input
                placeholder="Name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="w-full p-2 pl-10"
              />
            </div>
          </div>
        </div>
      </div>
      <div className="relative">
        <span className="absolute -translate-y-1/2 text-muted-foreground left-3 top-4.5">
          <AlignLeft size={18} />
        </span>
        <Textarea
          placeholder="Bio"
          value={bio}
          onChange={(e) => setBio(e.target.value)}
          className="w-full p-2 pl-10"
        />
      </div>
      <Button type="submit" disabled={!profileLimits.canCreate || profileLimits.isLoading}>
        Create Profile
      </Button>
    </form>
  )
}



================================================
FILE: components/layout/main-header.tsx
================================================
import { Button } from '@/components/ui/button'
import Logo from "@/components/common/logo"
import Link from 'next/link'
import ThemeSwitch from "@/components/common/theme-switch"
import { isAuthenticated } from '@/lib/server-functions'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'

export async function LandingHeader() {
  const auth = await isAuthenticated()

  return (
    <header className="sticky top-0 z-30 flex items-center justify-between p-2">
      <Logo />
      <div className="flex gap-2">
        {!auth ? (
          <>
            <Button asChild variant="outline">
              <Link href="/sign-in">Sign in</Link>
            </Button>
            <Button asChild>
              <Link href="/sign-up">Get started</Link>
            </Button>
          </>
        ) : (
          <Link href={'/dashboard'}>
            <Avatar>
              <AvatarImage src="/avatar.png" alt="User" />
              <AvatarFallback>U</AvatarFallback>
            </Avatar>
          </Link>
        )}
        <ThemeSwitch />
      </div>
    </header>
  )
}



================================================
FILE: components/media/avatar-upload.tsx
================================================
'use client'

import Image from 'next/image'
import { Camera, Trash2Icon } from 'lucide-react'
import { RadialProgress } from "@/components/common/radial-progress"
import { useEffect, useRef, useState } from 'react'
import { useFileUpload } from '@/hooks/useFileUpload'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Doc, Id } from '@/convex/_generated/dataModel'
import { User } from 'lucide-react'
import { Button } from '@/components/ui/button'

interface AvatarUploadProps {
  onChange?: (url: string) => void
  existingImageUrl?: string
  handle: Doc<'profiles'>['handle']
  disabled?: boolean
  size?: 'sm' | 'md' | 'lg'
}

export function AvatarUpload({
  onChange,
  existingImageUrl,
  handle,
  disabled = false,
  size = 'md',
}: AvatarUploadProps) {
  const fileInputRef = useRef<HTMLInputElement>(null)
  const { uploadFile } = useFileUpload()

  const [loading, setLoading] = useState(false)
  const [progress, setProgress] = useState(0)
  const [storageId, setStorageId] = useState<Id<'_storage'> | undefined>(undefined)
  const [isHovering, setIsHovering] = useState(false)
  const [imageUrl, setImageUrl] = useState<string | undefined>(existingImageUrl)

  // Dimensions based on size
  const dimensions = {
    sm: { width: 96, height: 96, iconSize: 'w-8 h-8' },
    md: { width: 128, height: 128, iconSize: 'w-10 h-10' },
    lg: { width: 160, height: 160, iconSize: 'w-12 h-12' },
  }[size]

  // Update image URL when existingImageUrl changes
  useEffect(() => {
    if (existingImageUrl) {
      setImageUrl(existingImageUrl)
    } else {
      // If existingImageUrl is null/undefined/empty, clear the image
      setImageUrl(undefined)
    }
  }, [existingImageUrl])

  const uploadedImagePath = useQuery(api.files.getUrl, storageId ? { storageId } : 'skip')

  useEffect(() => {
    if (uploadedImagePath && !loading) {
      setImageUrl(uploadedImagePath)
      onChange?.(uploadedImagePath)
    }
  }, [uploadedImagePath, loading, onChange])

  const uploadSelectedFile = async (file: File) => {
    setProgress(0)
    setLoading(true)
    try {
      const storageId = await uploadFile(file, setProgress)
      setStorageId(storageId as Id<'_storage'>)
    } catch {
      console.error('Upload failed')
    } finally {
      setLoading(false)
    }
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (disabled) return
    const file = e.target.files?.[0]
    if (file) uploadSelectedFile(file)
  }

  const handleRemoveImage = (e: React.MouseEvent) => {
    e.stopPropagation()
    e.preventDefault()

    if (disabled) return

    // Clear image immediately for better UX
    setImageUrl(undefined)
    setStorageId(undefined)

    // Force a re-render
    setTimeout(() => {
      // Notify parent component last to ensure all state changes are applied
      if (onChange) {
        onChange('')
      }
    }, 10)
  }

  return (
    <div className="relative flex items-center justify-center">
      <div
        className="relative overflow-hidden border-2 border-dashed rounded-full cursor-pointer border-border"
        style={{ width: dimensions.width, height: dimensions.height }}
        onClick={() => !disabled && fileInputRef.current?.click()}
        onMouseEnter={() => !disabled && setIsHovering(true)}
        onMouseLeave={() => setIsHovering(false)}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          className="hidden"
          style={{ display: 'none' }}
          onChange={handleFileChange}
          disabled={disabled}
        />

        {imageUrl ? (
          <Image
            key={imageUrl}
            src={imageUrl}
            alt={handle}
            width={dimensions.width}
            height={dimensions.height}
            className="object-cover w-full h-full"
          />
        ) : (
          <div className="flex items-center justify-center w-full h-full bg-muted">
            <User className={`${dimensions.iconSize} text-muted-foreground`} />
          </div>
        )}

        {!disabled && (
          <div
            className={`absolute inset-0 flex flex-col items-center justify-center transition-all duration-150 ${
              isHovering ? 'bg-muted/80' : imageUrl && 'bg-muted/20'
            }`}
          >
            {/* Control buttons on hover */}
            {isHovering && (
              <div className="flex items-center gap-4">
                {/* Upload button */}
                <Button className="rounded-full" size="icon" variant="outline">
                  <Camera className="w-5 h-5" />
                </Button>

                {/* Delete button - only show if there's an image */}
                {imageUrl && !loading && (
                  <Button
                    type="button"
                    size="icon"
                    variant="destructive"
                    className="rounded-full"
                    onClick={(e) => {
                      e.preventDefault()
                      e.stopPropagation()
                      handleRemoveImage(e)
                    }}
                  >
                    <Trash2Icon className="w-5 h-5" />
                  </Button>
                )}
              </div>
            )}
          </div>
        )}

        {/* Loading overlay */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center bg-white/50">
            <RadialProgress progress={progress} />
          </div>
        )}
      </div>
    </div>
  )
}



================================================
FILE: components/media/image-upload.tsx
================================================
import Image from 'next/image'
import { CloudUploadIcon, Trash2Icon } from 'lucide-react'
import { RadialProgress } from "@/components/common/radial-progress"
import { useEffect, useRef, useState } from 'react'
import { useFileUpload } from '@/hooks/useFileUpload'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Id } from '@/convex/_generated/dataModel'

export function ImageUpload({ onChange }: { onChange?: (url: string) => void }) {
  const fileInputRef = useRef<HTMLInputElement>(null)
  const { uploadFile } = useFileUpload()

  const [loading, setLoading] = useState(false)
  const [progress, setProgress] = useState(0)
  const [storageId, setStorageId] = useState<Id<'_storage'> | undefined>(undefined)
  const [selectedFileName, setSelectedFileName] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [isDragActive, setIsDragActive] = useState(false)

  const uploadedImagePath = useQuery(api.files.getUrl, storageId ? { storageId } : 'skip')

  useEffect(() => {
    if (uploadedImagePath && !loading) {
      onChange?.(uploadedImagePath)
    } else if (!uploadedImagePath && !loading) {
      onChange?.('')
    }
  }, [uploadedImagePath, loading, onChange])

  const uploadSelectedFile = async (file: File) => {
    setSelectedFileName(file.name)
    setError(null)
    setProgress(0)
    setLoading(true)
    try {
      const storageId = await uploadFile(file, setProgress)
      setStorageId(storageId as Id<'_storage'>)
    } catch {
      setError('Upload failed')
    } finally {
      setLoading(false)
    }
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) uploadSelectedFile(file)
  }

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragActive(false)
    const file = e.dataTransfer.files?.[0]
    if (file) uploadSelectedFile(file)
  }

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragActive(true)
  }

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragActive(false)
  }

  return (
    <div
      className={`flex flex-col items-center justify-center w-full p-6 border-2 border-dashed rounded-lg cursor-pointer border-border bg-card hover:bg-primary-foreground ${
        isDragActive ? 'bg-primary/10 border-primary' : ''
      }`}
      onClick={() => fileInputRef.current?.click()}
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        className="hidden"
        style={{ display: 'none' }}
        onChange={handleFileChange}
      />

      {loading && (
        <div className="max-w-md text-center">
          <RadialProgress progress={progress} />
          <p className="text-sm font-semibold">Uploading image</p>
          <p className="text-xs text-muted-foreground">
            Do not refresh or perform any other action while the image is being uploaded
          </p>
        </div>
      )}

      {!loading && !uploadedImagePath && (
        <div className="text-center">
          <div className="p-2 mx-auto border rounded-md border-border max-w-min">
            <CloudUploadIcon />
          </div>

          <p className="mt-2 text-sm text-muted-foreground">
            <span className="font-semibold">
              {selectedFileName ? `Selected: ${selectedFileName}` : 'Drag an image'}
            </span>
          </p>
          <p className="text-xs text-muted-foreground">
            {selectedFileName
              ? 'Click upload to proceed'
              : 'Select an image or drag here to upload directly'}
          </p>
          {error && <p className="mt-2 text-xs text-red-500">{error}</p>}
        </div>
      )}

      {uploadedImagePath && !loading && (
        <div className="relative space-y-2 text-center group">
          <Image
            width={300}
            height={300}
            src={uploadedImagePath}
            className="object-contain w-full opacity-70 max-h-18"
            alt="Uploaded image"
          />
          {/* Hover overlay */}
          <div
            className="absolute inset-0 flex items-center justify-center transition-opacity opacity-0 cursor-pointer group-hover:opacity-100"
            onClick={(e) => {
              e.stopPropagation()
              setStorageId(undefined)
              setSelectedFileName(null)
              setProgress(0)
            }}
          >
            <Trash2Icon className="w-4 h-4 " />
          </div>
        </div>
      )}
    </div>
  )
}



================================================
FILE: components/monetization/donate-button.tsx
================================================
'use client'

import { useState, useEffect, useRef } from 'react'
import { useAction } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { toast } from 'sonner'
import { Doc, Id } from '@/convex/_generated/dataModel'
import { Heart } from 'lucide-react'
import { getLinkButtonClasses } from '@/lib/theme-mappings'
import { useSearchParams } from 'next/navigation'

interface DonateButtonProps {
  profileId: Id<'profiles'>
  handle: Doc<'profiles'>['handle']
  theme: Doc<'profileThemes'>
}

export function DonateButton({ profileId, handle, theme }: DonateButtonProps) {
  const [open, setOpen] = useState(false)
  const [amount, setAmount] = useState('5')
  const [email, setEmail] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  const searchParams = useSearchParams()
  const donationStatus = searchParams.get('donation')

  // Use a ref to track if we've already shown the toast
  const hasShownToast = useRef(false)

  // Show success toast if donation was successful
  useEffect(() => {
    if (donationStatus === 'success' && !hasShownToast.current) {
      hasShownToast.current = true
      toast.success(`Thank you for supporting ${handle}!`)
    }
  }, [donationStatus, handle])

  const createDonationSession = useAction(api.payments.createDonationCheckoutSession)

  // Pre-defined donation amounts
  const donationAmounts = ['5', '10', '25', '50', '100']

  const handleDonate = async () => {
    if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
      toast.error('Please enter a valid donation amount')
      return
    }

    if (!email) {
      toast.error('Please enter your email')
      return
    }

    setIsLoading(true)

    try {
      const donationAmount = parseFloat(amount)
      const result = await createDonationSession({
        profileId,
        amount: donationAmount * 100, // Convert to cents for Stripe
        email,
      })

      // Redirect to Stripe checkout
      if (result.checkoutUrl) {
        window.location.href = result.checkoutUrl
      } else {
        toast.error('Unable to process donation at this time')
      }
    } catch (error) {
      console.error('Error creating donation session:', error)
      toast.error('Unable to process donation at this time')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <>
      <Button
        onClick={() => setOpen(true)}
        className={getLinkButtonClasses(theme.settings)}
      >
        <Heart className="w-4 h-4 mr-2" /> Support {handle}
      </Button>

      <Dialog open={open} onOpenChange={setOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Support {handle}</DialogTitle>
            <DialogDescription>
              Make a donation to support this creator&apos;s work.
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="email">Email address</Label>
              <Input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="you@example.com"
              />
            </div>

            <div className="grid gap-2">
              <Label>Choose an amount</Label>
              <div className="flex flex-wrap gap-2">
                {donationAmounts.map((amt) => (
                  <Button
                    key={amt}
                    type="button"
                    variant={amount === amt ? 'default' : 'outline'}
                    onClick={() => setAmount(amt)}
                    className="flex-1"
                  >
                    ${amt}
                  </Button>
                ))}
              </div>
            </div>

            <div className="grid gap-2">
              <Label htmlFor="custom-amount">Or enter a custom amount</Label>
              <div className="flex items-center">
                <span className="mr-2">$</span>
                <Input
                  id="custom-amount"
                  type="number"
                  min="1"
                  step="1"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  className="flex-1"
                />
              </div>
            </div>
          </div>

          <DialogFooter>
            <Button onClick={handleDonate} disabled={isLoading} className="w-full">
              {isLoading ? 'Processing...' : `Donate $${amount}`}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  )
}


================================================
FILE: components/monetization/payment-list.tsx
================================================
'use client'

import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Card } from '@/components/ui/card'
import { formatDistance } from 'date-fns'
import { Badge } from '@/components/ui/badge'

export function PaymentList() {
  const payments = useQuery(api.payments.listByUser)
  const subscription = useQuery(api.subscriptions.getUserSubscription)

  if (payments === undefined) {
    return (
      <Card className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold">Payment History</h2>
        </div>
        <div className="space-y-2">
          {[1, 2, 3].map((i) => (
            <div key={i} className="h-16 bg-muted rounded-md animate-pulse" />
          ))}
        </div>
      </Card>
    )
  }

  const hasSubscriptionOrPayments =
    (subscription && subscription.subscriptionId) || payments.length > 0

  if (!hasSubscriptionOrPayments) {
    return (
      <Card className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold">Payment History</h2>
        </div>
        <div className="text-center py-6 text-muted-foreground">No payments yet</div>
      </Card>
    )
  }

  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold">Payment History</h2>
      </div>
      <div className="space-y-4">
        {/* Subscription entry (if active) */}
        {subscription && subscription.subscriptionId && subscription.planType && (
          <div className="flex justify-between items-center p-3 border rounded-md hover:bg-accent/5 transition-colors bg-accent/5">
            <div>
              <p className="font-medium">{subscription.plan?.name} Subscription</p>
              <p className="text-sm text-muted-foreground">
                {subscription.currentPeriodStart
                  ? `Renewed ${formatDistance(new Date(subscription.currentPeriodStart * 1000), new Date(), { addSuffix: true })}`
                  : 'Active subscription'}
              </p>
              {subscription.currentPeriodEnd && (
                <p className="text-xs text-muted-foreground">
                  Next billing:{' '}
                  {new Date(subscription.currentPeriodEnd * 1000).toLocaleDateString()}
                  {subscription.cancelAtPeriodEnd ? ' (Cancels after this period)' : ''}
                </p>
              )}
            </div>
            <div className="flex items-center gap-4">
              <p className="font-medium">
                ${((subscription.plan?.price || 0) / 100).toFixed(2)}/mo
              </p>
              <SubscriptionStatusBadge
                status={subscription.status}
                cancelAtPeriodEnd={subscription.cancelAtPeriodEnd}
              />
            </div>
          </div>
        )}

        {/* Regular payments */}
        {payments.map((payment) => (
          <div
            key={payment._id}
            className="flex justify-between items-center p-3 border rounded-md hover:bg-accent/5 transition-colors"
          >
            <div>
              <p className="text-sm text-muted-foreground">
                {payment.createdAt
                  ? formatDistance(new Date(payment.createdAt), new Date(), { addSuffix: true })
                  : 'Unknown date'}
              </p>
            </div>
            <div className="flex items-center gap-4">
              <p className="font-medium">${((payment.amount || 0) / 100).toFixed(2)}</p>
              <StatusBadge status={payment.status || 'created'} />
            </div>
          </div>
        ))}
      </div>
    </Card>
  )
}

function StatusBadge({ status }: { status: string }) {
  switch (status) {
    case 'completed':
      return <Badge className="bg-green-500">Completed</Badge>
    case 'pending':
      return <Badge className="bg-yellow-500">Pending</Badge>
    case 'failed':
      return <Badge className="bg-red-500">Failed</Badge>
    default:
      return <Badge>Created</Badge>
  }
}

function SubscriptionStatusBadge({
  status,
  cancelAtPeriodEnd,
}: {
  status: string
  cancelAtPeriodEnd?: boolean
}) {
  if (status === 'active') {
    if (cancelAtPeriodEnd) {
      return <Badge className="bg-orange-500">Canceling</Badge>
    }
    return <Badge className="bg-green-500">Active</Badge>
  }
  if (status === 'trialing') {
    return <Badge className="bg-blue-500">Trial</Badge>
  }
  if (status === 'past_due') {
    return <Badge className="bg-red-500">Past Due</Badge>
  }
  if (status === 'canceled') {
    return <Badge className="bg-gray-500">Canceled</Badge>
  }
  if (status === 'incomplete') {
    return <Badge className="bg-yellow-500">Pending</Badge>
  }
  return <Badge>{status}</Badge>
}



================================================
FILE: components/monetization/stripe-connect-section.tsx
================================================
'use client'

import React, { useState, useEffect, useRef } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { useQuery, useAction } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import { toast } from 'sonner'
import { Id } from '@/convex/_generated/dataModel'

export function StripeConnectSection({ profileId }: { profileId: Id<'profiles'> }) {
  const router = useRouter()
  const searchParams = useSearchParams()
  const success = searchParams.get('success')
  const refresh = searchParams.get('refresh')

  const [isConnecting, setIsConnecting] = useState(false)
  const connectAccount = useQuery(api.stripeConnect.getConnectAccountForProfile, { profileId })

  const createConnectAccount = useAction(api.stripeConnect.createConnectAccount)
  const getAccountLink = useAction(api.stripeConnect.getAccountLink)
  const syncConnectAccountDetails = useAction(api.stripeConnect.syncConnectAccountDetails)

  // Use a ref to track if we've already shown the toast
  const hasShownToast = useRef(false)

  // Check for success or refresh params to sync data
  useEffect(() => {
    if ((success === 'true' || refresh === 'true') && connectAccount && !hasShownToast.current) {
      hasShownToast.current = true

      const accountId = connectAccount.stripeConnectAccountId
      syncConnectAccountDetails({ accountId })
        .then(() => {
          if (success === 'true') {
            toast.success('Stripe Connect account successfully updated')
          }
          // Clean up URL - redirect back to profile page without the query parameters
          router.replace(`/dashboard/${profileId}`)
        })
        .catch(() => {
          hasShownToast.current = false // Reset on error
          toast.error('Failed to sync Stripe Connect account details')
        })
    }
  }, [success, refresh, connectAccount, router, syncConnectAccountDetails, profileId])

  const handleConnectStripe = async () => {
    try {
      setIsConnecting(true)
      const result = await createConnectAccount({ profileId })
      window.location.href = result.accountLinkUrl
    } catch (error) {
      console.error('Error connecting Stripe:', error)
      toast.error('Failed to connect Stripe account')
    } finally {
      setIsConnecting(false)
    }
  }

  const handleReconnectStripe = async (accountId: string) => {
    try {
      setIsConnecting(true)
      const result = await getAccountLink({ accountId })
      window.location.href = result.accountLinkUrl
    } catch (error) {
      console.error('Error reconnecting Stripe:', error)
      toast.error('Failed to reconnect Stripe account')
    } finally {
      setIsConnecting(false)
    }
  }

  return (
    <div>
      <div className="flex items-center justify-between mb-2">
        <div className="font-medium">Stripe Connect</div>
      </div>

      <p className="text-sm text-muted-foreground mb-4">
        Connect your Stripe account to sell products and receive payments directly.
      </p>

      <Separator className="my-4" />

      {connectAccount === undefined ? (
        <div className="h-24 bg-muted rounded-md animate-pulse" />
      ) : connectAccount ? (
        <div className="flex items-center justify-between">
          <div>
            <div className="flex items-center gap-2">
              <h3 className="font-medium">Stripe Connected Account</h3>
              {connectAccount.isOnboarded ? (
                <Badge className="bg-green-500">Verified</Badge>
              ) : (
                <Badge variant="outline">Pending Verification</Badge>
              )}
            </div>
            <p className="text-sm text-muted-foreground">
              Account ID: {connectAccount.stripeConnectAccountId}
            </p>
          </div>
          <Button
            variant="outline"
            onClick={() => handleReconnectStripe(connectAccount.stripeConnectAccountId)}
            disabled={isConnecting}
          >
            {isConnecting
              ? 'Connecting...'
              : connectAccount.isOnboarded
                ? 'Dashboard'
                : 'Complete Setup'}
          </Button>
        </div>
      ) : (
        <div className="flex flex-col items-center">
          <p className="mb-4 text-center">
            You haven&apos;t connected a Stripe account for this profile yet. Connect to start
            selling products.
          </p>
          <Button onClick={handleConnectStripe} disabled={isConnecting}>
            {isConnecting ? 'Connecting...' : 'Connect Stripe'}
          </Button>
        </div>
      )}
    </div>
  )
}



================================================
FILE: components/monetization/stripe-earnings-dashboard.tsx
================================================
'use client'

import { useEffect, useState } from 'react'
import { useAction, useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import { toast } from 'sonner'
import { ExternalLink, RefreshCw } from 'lucide-react'
import { formatDistance, format } from 'date-fns'
import { Id } from '@/convex/_generated/dataModel'
import { Skeleton } from '@/components/ui/skeleton'
import { ScrollArea } from '@/components/ui/scroll-area'

interface StripeEarningsDashboardProps {
  profileId: Id<'profiles'>
}

type Payout = {
  id: string
  amount: number
  status: string
  created: number
  arrival_date?: number
  currency: string
}

export function StripeEarningsDashboard({ profileId }: StripeEarningsDashboardProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [payoutHistory, setPayoutHistory] = useState<Payout[]>([])

  const connectAccount = useQuery(api.stripeConnect.getConnectAccountForProfile, { profileId })
  const balanceData = useQuery(
    api.stripeConnect.getAccountBalance,
    connectAccount ? { accountId: connectAccount.stripeConnectAccountId } : 'skip',
  )

  const getPayoutHistory = useAction(api.stripeConnect.getPayoutHistory)
  const syncBalance = useAction(api.stripeConnect.syncAccountBalance)
  const createPayout = useAction(api.stripeConnect.createPayout)

  useEffect(() => {
    if (connectAccount) {
      getPayoutHistory({ accountId: connectAccount.stripeConnectAccountId }).then(setPayoutHistory)
    }
  }, [connectAccount, getPayoutHistory])

  const handleSyncBalance = async () => {
    if (!connectAccount) return

    setIsLoading(true)
    try {
      await syncBalance({ accountId: connectAccount.stripeConnectAccountId })
      toast.success('Balance updated successfully')
    } catch (error) {
      console.error('Error syncing balance:', error)
      toast.error('Failed to sync balance')
    } finally {
      setIsLoading(false)
    }
  }

  const handleCreatePayout = async () => {
    if (!connectAccount || !balanceData) return

    setIsLoading(true)
    try {
      await createPayout({ accountId: connectAccount.stripeConnectAccountId })
      toast.success('Payout initiated successfully')
      // Refresh balance after payout
      await syncBalance({ accountId: connectAccount.stripeConnectAccountId })
    } catch (error) {
      console.error('Error creating payout:', error)
      toast.error('Failed to create payout')
    } finally {
      setIsLoading(false)
    }
  }

  const openStripeDashboard = () => {
    if (!connectAccount) return

    window.open('https://dashboard.stripe.com/express', '_blank')
  }

  // If the creator doesn't have Stripe connected
  if (!connectAccount) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Earnings Dashboard</CardTitle>
          <CardDescription>
            Connect your Stripe account to view earnings and manage payouts.
          </CardDescription>
        </CardHeader>
      </Card>
    )
  }

  // If account is not fully onboarded
  if (!connectAccount.isOnboarded) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Earnings Dashboard</CardTitle>
          <CardDescription>
            Please complete your Stripe account setup to view earnings and manage payouts.
          </CardDescription>
        </CardHeader>
      </Card>
    )
  }

  return (
    <>
      <div className="flex justify-end px-6 pb-6 gap-2 h-full">
        <Button variant="outline" onClick={openStripeDashboard}>
          <ExternalLink className="w-4 h-4 mr-2" />
          Stripe Dashboard
        </Button>
        <Button variant="outline" size="icon" onClick={handleSyncBalance} disabled={isLoading}>
          <RefreshCw className={`${isLoading ? 'animate-spin' : ''}`} />
        </Button>
      </div>
      <CardContent className="space-y-6">
        <div className="grid gap-4 md:grid-cols-2">
          {/* Current Balance */}
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="flex text-sm font-medium justify-between">
                Available Balance
              </CardTitle>
            </CardHeader>
            <CardContent>
              {balanceData ? (
                <div className="flex justify-between items-center">
                  <div>
                    <div className="text-2xl font-bold">
                      ${((balanceData.available[0]?.amount || 0) / 100).toFixed(2)}
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Last updated:{' '}
                      {balanceData.lastUpdated
                        ? formatDistance(new Date(balanceData.lastUpdated), new Date(), {
                            addSuffix: true,
                          })
                        : 'Never'}
                    </p>
                  </div>
                </div>
              ) : (
                <div className="space-y-2">
                  <Skeleton className="h-8 w-24" />
                  <Skeleton className="h-4 w-32" />
                </div>
              )}
            </CardContent>
          </Card>

          {/* Pending Balance */}
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm font-medium">Pending Balance</CardTitle>
            </CardHeader>
            <CardContent>
              {balanceData ? (
                <div>
                  <div className="text-2xl font-bold">
                    ${((balanceData.pending[0]?.amount || 0) / 100).toFixed(2)}
                  </div>
                  <p className="text-xs text-muted-foreground">
                    Available in {balanceData.pending[0]?.amount ? '~2-5 business days' : 'N/A'}
                  </p>
                </div>
              ) : (
                <div className="space-y-2">
                  <Skeleton className="h-8 w-24" />
                  <Skeleton className="h-4 w-32" />
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        <Separator />

        {/* Payout Button */}
        <div className="flex flex-col items-center">
          <p className="mb-4 text-sm text-center text-muted-foreground">
            Request a payout to transfer your available balance to your bank account.
          </p>
          <Button
            onClick={handleCreatePayout}
            disabled={isLoading || !balanceData || (balanceData.available[0]?.amount || 0) <= 0}
            className="px-8"
          >
            {isLoading ? 'Processing...' : 'Request Payout'}
          </Button>
          {balanceData && (balanceData.available[0]?.amount || 0) <= 0 && (
            <p className="mt-2 text-xs text-center text-muted-foreground">
              You need to have funds in your available balance to request a payout.
            </p>
          )}
        </div>

        <Separator />

        {/* Payout History */}
        <div className="flex flex-col h-full">
          <h3 className="font-medium mb-4">Recent Payouts</h3>
          <ScrollArea className="flex-1 h-[300px]">
            {payoutHistory === undefined ? (
              <div className="space-y-3">
                {[1, 2, 3].map((i) => (
                  <Skeleton key={i} className="h-16 w-full" />
                ))}
              </div>
            ) : payoutHistory.length > 0 ? (
              <div className="space-y-3 pr-4">
                {payoutHistory.map((payout) => (
                  <div
                    key={payout.id}
                    className="flex justify-between items-center p-3 border rounded"
                  >
                    <div>
                      <div className="flex items-center gap-2">
                        <span className="font-medium">${(payout.amount / 100).toFixed(2)}</span>
                        <Badge variant={payout.status === 'paid' ? 'default' : 'outline'}>
                          {payout.status === 'paid' ? 'Completed' : 'Processing'}
                        </Badge>
                      </div>
                      <p className="text-xs text-muted-foreground">
                        {format(new Date(payout.created * 1000), 'MMM d, yyyy')}
                      </p>
                    </div>
                    <div className="text-sm">
                      {payout.arrival_date && (
                        <span className="text-muted-foreground">
                          Arrives: {format(new Date(payout.arrival_date * 1000), 'MMM d')}
                        </span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-center text-muted-foreground py-6">
                No payouts have been processed yet.
              </p>
            )}
          </ScrollArea>
        </div>
      </CardContent>
    </>
  )
}



================================================
FILE: components/monetization/subscribe-button.tsx
================================================
'use client'

import { ReactNode, useState } from 'react'
import { Button } from '@/components/ui/button'
import { useAction, useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { toast } from 'sonner'
import { PlanType } from '@/convex/lib/plans'

interface SubscribeButtonProps {
  planType: PlanType
  className?: string
  children?: ReactNode
}

export function SubscribeButton({ planType, className, children, ...props }: SubscribeButtonProps) {
  const [isLoading, setIsLoading] = useState(false)
  const subscription = useQuery(api.subscriptions.getUserSubscription)
  const subscribe = useAction(api.subscriptions.subscribe)
  const cancelSubscription = useAction(api.subscriptions.cancelSubscription)
  const reactivateSubscription = useAction(api.subscriptions.reactivateSubscription)

  const isCurrentPlan = subscription?.planType === planType
  const isCanceling = subscription?.cancelAtPeriodEnd === true

  const handleSubscription = async () => {
    setIsLoading(true)
    try {
      const checkoutUrl = await subscribe({ planType })
      if (checkoutUrl) {
        window.location.href = checkoutUrl
      }
    } catch (error) {
      console.error('Subscription error:', error)
      toast.error('Failed to process subscription')
    } finally {
      setIsLoading(false)
    }
  }

  const handleCancellation = async () => {
    setIsLoading(true)
    try {
      const result = await cancelSubscription()
      if (result.success) {
        toast.success('Your subscription will be canceled at the end of the billing period')
      }
    } catch (error) {
      console.error('Cancellation error:', error)
      toast.error('Failed to cancel subscription')
    } finally {
      setIsLoading(false)
    }
  }

  const handleReactivation = async () => {
    setIsLoading(true)
    try {
      const result = await reactivateSubscription()
      if (result.success) {
        toast.success('Your subscription has been reactivated')
      }
    } catch (error) {
      console.error('Reactivation error:', error)
      toast.error('Failed to reactivate subscription')
    } finally {
      setIsLoading(false)
    }
  }

  // If this is current plan and canceling, show Reactivate button
  if (isCurrentPlan && isCanceling) {
    return (
      <Button
        onClick={handleReactivation}
        disabled={isLoading}
        variant="outline"
        className={className}
        {...props}
      >
        {isLoading ? 'Processing...' : 'Reactivate'}
      </Button>
    )
  }

  // If this is current plan, show Cancel button
  if (isCurrentPlan) {
    return (
      <Button
        onClick={handleCancellation}
        disabled={isLoading}
        variant="outline"
        className={className}
        {...props}
      >
        {isLoading ? 'Processing...' : 'Cancel Plan'}
      </Button>
    )
  }

  return (
    <Button
      onClick={handleSubscription}
      disabled={isLoading || (!!subscription && !isCanceling)}
      className={className}
      {...props}
    >
      {isLoading ? 'Processing...' : children || 'Subscribe'}
    </Button>
  )
}



================================================
FILE: components/profile/cards/enhanced-profile-card.tsx
================================================
'use client'

import { Card, CardContent } from '@/components/ui/card'
import Image from 'next/image'
import { UserIcon, Settings, Globe, Users, ExternalLink } from 'lucide-react'
import Link from 'next/link'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { ProfileWithStats } from '@/types/profile'
import { getThemeSettings } from '@/lib/theme-defaults'

export function EnhancedProfileCard({ profile }: { profile: ProfileWithStats }) {
  // Get theme settings with validation from profile theme
  const theme = getThemeSettings(profile.theme)

  // Helper to get theme-specific classes
  const getThemeClasses = () => {
    // Base classes that are always applied
    let classes = 'transition-all duration-200 hover:shadow-md'

    // Color classes
    switch (theme.color) {
      case 'blue':
        classes += ' hover:border-blue-200 hover:bg-blue-50'
        break
      case 'purple':
        classes += ' hover:border-purple-200 hover:bg-purple-50'
        break
      case 'green':
        classes += ' hover:border-green-200 hover:bg-green-50'
        break
      case 'pink':
        classes += ' hover:border-pink-200 hover:bg-pink-50'
        break
      case 'orange':
        classes += ' hover:border-orange-200 hover:bg-orange-50'
        break
      default:
        classes += ' hover:border-indigo-200 hover:bg-indigo-50'
    }

    // Style classes
    switch (theme.style) {
      case 'gradient':
        classes += getGradientBackground()
        break
      case 'soft':
        classes += ' bg-background/90 backdrop-blur-sm'
        break
      case 'outlined':
        classes += ' border-2 border-border'
        break
      default:
        classes += ' bg-background'
    }

    return classes
  }

  const getGradientBackground = () => {
    switch (theme.color) {
      case 'blue':
        return ' bg-gradient-to-br from-blue-50 to-background'
      case 'purple':
        return ' bg-gradient-to-br from-purple-50 to-background'
      case 'green':
        return ' bg-gradient-to-br from-green-50 to-background'
      case 'pink':
        return ' bg-gradient-to-br from-pink-50 to-background'
      case 'orange':
        return ' bg-gradient-to-br from-orange-50 to-background'
      default:
        return ' bg-gradient-to-br from-indigo-50 to-background'
    }
  }

  const getBadgeClass = () => {
    switch (theme.color) {
      case 'blue':
        return 'bg-blue-100 text-blue-800'
      case 'purple':
        return 'bg-purple-100 text-purple-800'
      case 'green':
        return 'bg-green-100 text-green-800'
      case 'pink':
        return 'bg-pink-100 text-pink-800'
      case 'orange':
        return 'bg-orange-100 text-orange-800'
      default:
        return 'bg-indigo-100 text-indigo-800'
    }
  }

  const getButtonStyle = () => {
    const classes = 'text-xs py-1 px-2 h-auto'

    switch (theme.color) {
      case 'blue':
        return `${classes} bg-blue-100 text-blue-800 hover:bg-blue-200`
      case 'purple':
        return `${classes} bg-purple-100 text-purple-800 hover:bg-purple-200`
      case 'green':
        return `${classes} bg-green-100 text-green-800 hover:bg-green-200`
      case 'pink':
        return `${classes} bg-pink-100 text-pink-800 hover:bg-pink-200`
      case 'orange':
        return `${classes} bg-orange-100 text-orange-800 hover:bg-orange-200`
      default:
        return `${classes} bg-indigo-100 text-indigo-800 hover:bg-indigo-200`
    }
  }

  const renderIcon = () => {
    // Avatar or default user icon
    if (profile.avatarUrl) {
      return (
        <Image
          src={profile.avatarUrl}
          alt={profile.handle}
          width={theme.layout === 'compact' ? 36 : 48}
          height={theme.layout === 'compact' ? 36 : 48}
          className="object-cover rounded-full"
        />
      )
    } else {
      return (
        <div
          className={`flex items-center justify-center ${theme.layout === 'compact' ? 'w-9 h-9' : 'w-12 h-12'} border rounded-full bg-background border-border`}
        >
          <UserIcon
            className={`${theme.layout === 'compact' ? 'w-5 h-5' : 'w-7 h-7'} text-muted-foreground`}
          />
        </div>
      )
    }
  }

  // Layout rendering based on selected layout
  const renderCompactLayout = () => (
    <CardContent className="flex items-center justify-between p-4">
      <div className="flex items-center gap-3">
        {renderIcon()}
        <span className="font-medium truncate max-w-[120px]">{profile.handle}</span>
      </div>

      <div className="flex items-center gap-2">
        <Badge variant="outline" className={getBadgeClass()}>
          <Globe className="w-3 h-3 mr-1" />/{profile.handle}
        </Badge>

        <Button variant="ghost" size="icon" className="w-8 h-8">
          <Settings className="w-4 h-4" />
        </Button>
      </div>
    </CardContent>
  )

  const renderStandardLayout = () => (
    <CardContent className="flex items-start gap-4 p-4">
      <div className="flex-shrink-0">{renderIcon()}</div>

      <div className="flex flex-col flex-1 min-w-0">
        <div className="flex items-center justify-between">
          <span className="text-lg font-medium">{profile.handle}</span>
          <Button variant="ghost" size="icon" className="w-8 h-8">
            <Settings className="w-4 h-4" />
          </Button>
        </div>

        <Badge variant="outline" className={`mb-2 ${getBadgeClass()}`}>
          <Globe className="w-3 h-3 mr-1" />/{profile.handle}
        </Badge>

        {profile.bio && (
          <p className="mb-2 text-sm text-muted-foreground line-clamp-2">{profile.bio}</p>
        )}

        {profile.stats && (
          <div className="flex gap-3 mt-1">
            {profile.stats.views !== undefined && (
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <Users className="w-3 h-3" />
                <span>{profile.stats.views} views</span>
              </div>
            )}
            {profile.stats.links !== undefined && (
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <ExternalLink className="w-3 h-3" />
                <span>{profile.stats.links} links</span>
              </div>
            )}
          </div>
        )}
      </div>
    </CardContent>
  )

  const renderExpandedLayout = () => (
    <div>
      <div className="relative w-full h-20 bg-gradient-to-r from-gray-100 to-gray-200">
        {/* Cover image would go here */}
      </div>

      <CardContent className="relative px-5 pt-5 pb-4">
        <div className="absolute -top-10 left-5">
          <div className="rounded-full ring-4 ring-background">{renderIcon()}</div>
        </div>

        <div className="mt-8">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="text-lg font-semibold">{profile.handle}</h3>
              <Badge variant="outline" className={getBadgeClass()}>
                <Globe className="w-3 h-3 mr-1" />/{profile.handle}
              </Badge>
            </div>

            <div className="flex gap-2">
              <Button className={getButtonStyle()}>View Public</Button>
              <Button variant="ghost" size="icon" className="w-8 h-8">
                <Settings className="w-4 h-4" />
              </Button>
            </div>
          </div>

          {profile.bio && <p className="mt-3 text-sm text-muted-foreground">{profile.bio}</p>}

          {profile.stats && (
            <div className="flex gap-4 pt-3 mt-4 border-t">
              {profile.stats.views !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.views}</span>
                  <span className="text-xs text-muted-foreground">Views</span>
                </div>
              )}
              {profile.stats.links !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.links}</span>
                  <span className="text-xs text-muted-foreground">Links</span>
                </div>
              )}
              {profile.stats.items !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.items}</span>
                  <span className="text-xs text-muted-foreground">Items</span>
                </div>
              )}
            </div>
          )}
        </div>
      </CardContent>
    </div>
  )

  // Construct the link destination - use profileId if available
  const linkDestination = `/dashboard/${profile._id}`

  return (
    <Link key={profile._id} href={linkDestination}>
      <Card className={`w-full ${getThemeClasses()}`}>
        {theme.layout === 'compact' && renderCompactLayout()}
        {theme.layout === 'standard' && renderStandardLayout()}
        {theme.layout === 'expanded' && renderExpandedLayout()}
      </Card>
    </Link>
  )
}



================================================
FILE: components/profile/cards/profile-card-skeleton.tsx
================================================
import { Card, CardContent } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'

/**
 * Loading skeleton for profile cards
 */
export function ProfileCardSkeleton() {
  return (
    <Card className="w-full min-w-xs">
      <CardContent className="flex items-center gap-3">
        <Skeleton className="w-12 h-12 rounded-full" />
        <div className="flex flex-col min-w-0 gap-2">
          <Skeleton className="w-32 h-4" />
          <Skeleton className="w-20 h-3" />
        </div>
      </CardContent>
    </Card>
  )
}


================================================
FILE: components/profile/cards/profile-card.tsx
================================================
'use client'

import { Card, CardContent } from '@/components/ui/card'
import Image from 'next/image'
import { UserIcon, Settings, Globe } from 'lucide-react'
import Link from 'next/link'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { ProfileWithThemeAndTemplate } from '@/types/profile'
import { ThemeColor, ThemeStyle, LayoutStyle, ThemeSettings } from '@/types/theme'
import { getProfileCardClasses } from '@/lib/theme-mappings'

/**
 * A unified profile card component with different display variants
 */
export function ProfileCard({
  profile,
  variant = 'standard',
  showSettings = false,
  showActions = false,
  defaultTheme = { color: 'default', style: 'minimal', layout: 'standard' },
  linkTo,
}: {
  profile: ProfileWithThemeAndTemplate
  variant?: 'compact' | 'standard' | 'expanded'
  showSettings?: boolean
  showActions?: boolean
  defaultTheme?: { color: ThemeColor; style: ThemeStyle; layout: LayoutStyle }
  linkTo?: string
}) {
  // Determine theme settings - handle both ProfileWithStats and ProfileWithThemeSettings types
  const themeSettings: ThemeSettings = {
    color: defaultTheme.color,
    style: defaultTheme.style,
    layout: variant as LayoutStyle,
  }

  // If profile has theme property (ProfileWithTheme), use those settings
  if ('theme' in profile && profile.theme) {
    if (profile.theme.settings) {
      const theme = profile.theme.settings
      if ('color' in theme) themeSettings.color = theme.color as ThemeColor
      if ('style' in theme) themeSettings.style = theme.style as ThemeStyle
      if ('layout' in theme) themeSettings.layout = theme.layout as LayoutStyle
    }
  }

  // Helper to get theme-specific badge classes
  const getBadgeClass = () => {
    switch (themeSettings.color) {
      case 'blue':
        return 'bg-blue-100 text-blue-800'
      case 'purple':
        return 'bg-purple-100 text-purple-800'
      case 'green':
        return 'bg-green-100 text-green-800'
      case 'pink':
        return 'bg-pink-100 text-pink-800'
      case 'orange':
        return 'bg-orange-100 text-orange-800'
      default:
        return 'bg-indigo-100 text-indigo-800'
    }
  }

  const getButtonStyle = () => {
    const classes = 'text-xs py-1 px-2 h-auto'

    switch (themeSettings.color) {
      case 'blue':
        return `${classes} bg-blue-100 text-blue-800 hover:bg-blue-200`
      case 'purple':
        return `${classes} bg-purple-100 text-purple-800 hover:bg-purple-200`
      case 'green':
        return `${classes} bg-green-100 text-green-800 hover:bg-green-200`
      case 'pink':
        return `${classes} bg-pink-100 text-pink-800 hover:bg-pink-200`
      case 'orange':
        return `${classes} bg-orange-100 text-orange-800 hover:bg-orange-200`
      default:
        return `${classes} bg-indigo-100 text-indigo-800 hover:bg-indigo-200`
    }
  }

  const renderIcon = () => {
    // Avatar or default user icon
    if (profile.avatarUrl) {
      return (
        <Image
          src={profile.avatarUrl}
          alt={profile.handle}
          width={variant === 'compact' ? 36 : 48}
          height={variant === 'compact' ? 36 : 48}
          className="object-cover rounded-full"
        />
      )
    } else {
      return (
        <div
          className={`flex items-center justify-center ${variant === 'compact' ? 'w-9 h-9' : 'w-12 h-12'} border rounded-full bg-background border-border`}
        >
          <UserIcon
            className={`${variant === 'compact' ? 'w-5 h-5' : 'w-7 h-7'} text-muted-foreground`}
          />
        </div>
      )
    }
  }

  // Layout rendering based on selected layout
  const renderCompactLayout = () => (
    <CardContent className="flex items-center justify-between p-4">
      <div className="flex items-center gap-3">
        {renderIcon()}
        <span className="font-medium truncate max-w-[120px]">{profile.handle}</span>
      </div>

      <div className="flex items-center gap-2">
        <Badge variant="outline" className={getBadgeClass()}>
          <Globe className="w-3 h-3 mr-1" />/{profile.handle}
        </Badge>

        {showSettings && (
          <Button variant="ghost" size="icon" className="w-8 h-8">
            <Settings className="w-4 h-4" />
          </Button>
        )}
      </div>
    </CardContent>
  )

  const renderStandardLayout = () => (
    <CardContent className="flex items-start gap-4 p-4">
      <div className="flex-shrink-0">{renderIcon()}</div>

      <div className="flex flex-col flex-1 min-w-0">
        <div className="flex items-center justify-between">
          <span className="text-lg font-medium">{profile.handle}</span>
          {showSettings && (
            <Button variant="ghost" size="icon" className="w-8 h-8">
              <Settings className="w-4 h-4" />
            </Button>
          )}
        </div>

        <Badge variant="outline" className={`mb-2 ${getBadgeClass()}`}>
          <Globe className="w-3 h-3 mr-1" />/{profile.handle}
        </Badge>

        {profile.bio && (
          <p className="mb-2 text-sm text-muted-foreground line-clamp-2">{profile.bio}</p>
        )}
        {/* 
        TODO: Implement later
        {showStats && 'stats' in profile && profile.stats && (
          <div className="flex gap-3 mt-1">
            {profile.stats.views !== undefined && (
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <Users className="w-3 h-3" />
                <span>{profile.stats.views} views</span>
              </div>
            )}
            {profile.stats.links !== undefined && (
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <ExternalLink className="w-3 h-3" />
                <span>{profile.stats.links} links</span>
              </div>
            )}
          </div>
        )} */}
      </div>
    </CardContent>
  )

  const renderExpandedLayout = () => (
    <div>
      <div className="relative w-full h-20 bg-gradient-to-r from-gray-100 to-gray-200">
        {/* Cover image would go here */}
      </div>

      <CardContent className="relative px-5 pt-5 pb-4">
        <div className="absolute -top-10 left-5">
          <div className="rounded-full ring-4 ring-background">{renderIcon()}</div>
        </div>

        <div className="mt-8">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="text-lg font-semibold">{profile.handle}</h3>
              <Badge variant="outline" className={getBadgeClass()}>
                <Globe className="w-3 h-3 mr-1" />/{profile.handle}
              </Badge>
            </div>

            {showActions && (
              <div className="flex gap-2">
                <Button className={getButtonStyle()}>View Public</Button>
                {showSettings && (
                  <Button variant="ghost" size="icon" className="w-8 h-8">
                    <Settings className="w-4 h-4" />
                  </Button>
                )}
              </div>
            )}
          </div>
          {profile.bio && <p className="mt-3 text-sm text-muted-foreground">{profile.bio}</p>}
          {/* {showStats && 'stats' in profile && profile.stats && (
          TODO: Implement later
            <div className="flex gap-4 pt-3 mt-4 border-t">
              {profile.stats.views !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.views}</span>
                  <span className="text-xs text-muted-foreground">Views</span>
                </div>
              )}
              {profile.stats.links !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.links}</span>
                  <span className="text-xs text-muted-foreground">Links</span>
                </div>
              )}
              {'items' in profile.stats && profile.stats.items !== undefined && (
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{profile.stats.items}</span>
                  <span className="text-xs text-muted-foreground">Items</span>
                </div>
              )}
            </div>
          )} */}
        </div>
      </CardContent>
    </div>
  )

  // Construct the link destination
  const linkDestination = linkTo || `/dashboard/${profile._id}`

  // Get card classes from theme mappings
  const cardClasses = getProfileCardClasses(themeSettings)

  // Render card with wrapper if linkTo is provided
  const cardContent = (
    <Card className={`w-full ${cardClasses}`}>
      {variant === 'compact' && renderCompactLayout()}
      {variant === 'standard' && renderStandardLayout()}
      {variant === 'expanded' && renderExpandedLayout()}
    </Card>
  )

  // If linkTo is provided, wrap in a Link
  if (linkTo) {
    return <Link href={linkDestination}>{cardContent}</Link>
  }

  // Otherwise return just the card
  return cardContent
}



================================================
FILE: components/profile/cards/profile-selector.tsx
================================================
'use client'

import { ChevronsUpDown, Plus, UserIcon } from 'lucide-react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { useEffect, useState } from 'react'
import { Doc } from '@/convex/_generated/dataModel'
import { useParams, useRouter } from 'next/navigation'

export function ProfileSelector() {
  const profiles = useQuery(api.profiles.listByUser, {})
  const router = useRouter()
  const params = useParams()
  const selectedProfileId = typeof params?.profileId === 'string' ? params.profileId : null

  const [activeProfile, setActiveProfile] = useState<Doc<'profiles'> | undefined>(undefined)

  useEffect(() => {
    if (profiles && profiles.length > 0) {
      setActiveProfile(profiles.find((p) => p._id === selectedProfileId))
    }
  }, [profiles, selectedProfileId])

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button
          type="button"
          className="flex items-center gap-2 p-1 pr-3 text-sm font-semibold text-left transition border rounded-sm border-border bg-background hover:bg-accent w-38"
          disabled={profiles?.length === 0}
        >
          <div className="flex items-center justify-center rounded-sm aspect-square size-6 bg-muted text-muted-foreground">
            {activeProfile ? (
              activeProfile.handle.charAt(0).toUpperCase()
            ) : (
              <UserIcon className="w-4 h-4 text-muted-foreground" />
            )}
          </div>

          <div className="flex-1 truncate">
            <span className="block text-xs truncate">
              {activeProfile ? activeProfile.handle : 'Select profile'}
            </span>
          </div>
          <ChevronsUpDown className="ml-auto size-4" />
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        className="w-[--radix-dropdown-menu-trigger-width] min-w-56 rounded-lg"
        align="start"
        side="bottom"
        sideOffset={4}
      >
        <DropdownMenuLabel className="text-xs text-muted-foreground">Profiles</DropdownMenuLabel>
        {profiles?.map((profile, index) => (
          <DropdownMenuItem
            key={profile._id}
            onClick={() => {
              setActiveProfile(profile)
              router.push(`/dashboard/${profile._id}`)
            }}
            className="gap-2 p-2"
          >
            <div className="flex items-center justify-center border rounded-sm size-6 border-border bg-muted text-muted-foreground">
              {profile.handle.charAt(0).toUpperCase()}
            </div>
            {profile.handle}
            <DropdownMenuShortcut>⌘{index + 1}</DropdownMenuShortcut>
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuItem className="gap-2 p-2">
          <div className="flex items-center justify-center border rounded-md size-6 border-border bg-background">
            <Plus className="size-4" />
          </div>
          <div className="font-medium text-muted-foreground">Add profile</div>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}



================================================
FILE: components/profile/editor/appearance-manager.tsx
================================================
'use client'

import { useState } from 'react'
import { useQuery, useMutation } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Doc, Id } from '@/convex/_generated/dataModel'
import { Button } from '@/components/ui/button'
import { Card, CardContent } from '@/components/ui/card'
import {
  Check,
  LayoutTemplate,
  Plus,
  Paintbrush,
  Palette,
  PaintBucket,
  Trash,
  LayoutGrid,
  ArrowRight,
  ThumbsUp,
  Search,
} from 'lucide-react'
import { toast } from 'sonner'
import Image from 'next/image'
import { TemplateCustomizer } from './template-customizer'
import { getDefaultThemeSettings } from '@/lib/theme-defaults'
import {
  getProfileCardClasses,
  getLinkButtonClasses,
  normalizeThemeSettings,
} from '@/lib/theme-mappings'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { Label } from '@/components/ui/label'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import { EnhancedProfileCard } from '@/components/profile/cards/enhanced-profile-card'
import { Input } from '@/components/ui/input'
import { ProfileComplete } from '@/types/profile'
import { ThemeSettings } from '@/types/theme'

export function AppearanceManager({
  profile,
  showFullPreview = false,
}: {
  profile: ProfileComplete
  showFullPreview?: boolean
}) {
  // State management
  const [view, setView] = useState<'templates' | 'themes' | 'template-customize' | 'theme-create'>(
    'templates',
  )
  const [selectedThemeId, setSelectedThemeId] = useState<Id<'profileThemes'> | null>(null)
  const [activeCategory, setActiveCategory] = useState('all')
  const [searchQuery, setSearchQuery] = useState('')
  const [currentSettings, setCurrentSettings] = useState<ThemeSettings>(getDefaultThemeSettings())
  const [isSaving, setIsSaving] = useState(false)
  const [showMyThemesOnly, setShowMyThemesOnly] = useState(false)

  const publicTemplates =
    useQuery(
      api.profileTemplates.listPublic,
      view === 'templates' ? { category: activeCategory } : 'skip',
    ) || []

  const publicThemes =
    useQuery(api.profileThemes.listPublic, view === 'themes' && !showMyThemesOnly ? {} : 'skip') ||
    []

  const myThemes =
    useQuery(
      api.profileThemes.listByCreator,
      view === 'themes' && profile ? { creatorProfileId: profile._id } : 'skip',
    ) || []

  // Template categories
  const templateCategories = ['all', 'business', 'creator', 'portfolio', 'minimal', 'professional']

  // Mutations
  const updateProfileTemplate = useMutation(api.profileTemplates.setProfileTemplate)
  const updateProfileTheme = useMutation(api.profiles.update)
  const createTheme = useMutation(api.profileThemes.create)
  const removeTheme = useMutation(api.profileThemes.remove)

  // Current selections
  const currentThemeId = profile?.profileThemeId
  const currentTemplateId = profile?.profileTemplateId

  // Apply a template to the profile
  const applyTemplate = async (templateId: Id<'profileTemplates'>) => {
    try {
      await updateProfileTemplate({
        profileId: profile._id,
        profileTemplateId: templateId,
      })
      toast.success('Template applied successfully')
      // We don't use selectedTemplateId for highlighting - we use currentTemplateId from the profile
    } catch (error) {
      toast.error('Failed to apply template')
      console.error(error)
    }
  }

  // Apply a theme to the profile
  const applyTheme = async (themeId: Id<'profileThemes'>) => {
    try {
      await updateProfileTheme({
        profileId: profile._id,
        profileThemeId: themeId,
      })
      toast.success('Theme applied successfully')
      // We don't need to update selectedThemeId as we use currentThemeId from the profile for highlighting
    } catch (error) {
      toast.error('Failed to apply theme')
      console.error(error)
    }
  }

  // Delete a theme
  const deleteTheme = async (themeId: Id<'profileThemes'>) => {
    try {
      await removeTheme({ profileThemeId: themeId })
      toast.success('Theme deleted')

      // If this was the selected theme, clear selection
      if (selectedThemeId === themeId) {
        setSelectedThemeId(null)
      }
    } catch (error) {
      toast.error('Failed to delete theme')
      console.error(error)
    }
  }

  // Create a new theme
  const createNewTheme = async () => {
    setIsSaving(true)
    try {
      const newThemeId = await createTheme({
        name: 'My Custom Theme',
        description: 'A custom theme I created',
        creatorProfileId: profile._id,
        isPublic: false,
        settings: currentSettings,
      })

      toast.success('Theme created successfully')
      setSelectedThemeId(newThemeId)
      setView('themes')
      setShowMyThemesOnly(true)
    } catch (error) {
      toast.error('Failed to create theme')
      console.error(error)
    } finally {
      setIsSaving(false)
    }
  }

  // Filter templates by category and search query
  const filteredTemplates = publicTemplates.filter((template) => {
    if (searchQuery === '') return true
    return (
      template.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (template.description &&
        template.description.toLowerCase().includes(searchQuery.toLowerCase()))
    )
  })

  // Filter themes by search query
  const themesToDisplay = (showMyThemesOnly ? myThemes : publicThemes).filter((theme) => {
    if (searchQuery === '') return true
    return (
      theme.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (theme.description && theme.description.toLowerCase().includes(searchQuery.toLowerCase()))
    )
  })

  // Helper function to get color class
  const getColorClass = (color: string): string => {
    switch (color) {
      case 'blue':
        return 'bg-blue-500'
      case 'purple':
        return 'bg-purple-500'
      case 'green':
        return 'bg-green-500'
      case 'pink':
        return 'bg-pink-500'
      case 'orange':
        return 'bg-orange-500'
      default:
        return 'bg-indigo-500'
    }
  }

  // Theme Preview Component
  const ThemePreview = ({
    settings,
    isSelected,
    onClick,
  }: {
    settings: Doc<'profileThemes'>['settings']
    isSelected?: boolean
    onClick?: () => void
  }) => (
    <div
      className={`border border-border rounded-md cursor-pointer transition-all ${
        isSelected ? 'ring-2 ring-primary' : 'hover:border-primary'
      }`}
      onClick={onClick}
    >
      <div className={getProfileCardClasses(settings) + ' !shadow-none !p-3 !space-y-2'}>
        <div className="w-12 h-12 bg-gray-200 rounded-full"></div>
        <div className="text-center">
          <div className="font-medium truncate">Handle</div>
          <div className="text-xs text-gray-500">Bio text</div>
        </div>
      </div>
      <div className="p-2 space-y-1">
        <div className={getLinkButtonClasses(settings) + ' !py-1 text-xs'}>Link 1</div>
        <div className={getLinkButtonClasses(settings) + ' !py-1 text-xs'}>Link 2</div>
      </div>
    </div>
  )

  if (!profile) {
    return <div className="flex justify-center py-8">Loading profile...</div>
  }

  // Render Template Customizer
  if (view === 'template-customize') {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <Button
            variant="ghost"
            onClick={() => setView('templates')}
            className="text-muted-foreground hover:text-foreground"
          >
            <ArrowRight className="w-4 h-4 mr-2 rotate-180" />
            Back to Templates
          </Button>
          <h2 className="text-xl font-semibold">Customize Template</h2>
        </div>

        <Separator />

        {profile?.profileTemplateId ? (
          <TemplateCustomizer profile={profile} />
        ) : (
          <div className="flex flex-col items-center justify-center p-8 border border-dashed rounded-md border-border">
            <LayoutTemplate className="w-12 h-12 mb-4 text-muted-foreground" />
            <p className="text-center text-muted-foreground">
              No template selected. Please select a template first.
            </p>
            <Button variant="outline" onClick={() => setView('templates')} className="mt-4">
              Browse Templates
            </Button>
          </div>
        )}
      </div>
    )
  }

  // Render Theme Creator
  if (view === 'theme-create') {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <Button
            variant="ghost"
            onClick={() => setView('themes')}
            className="text-muted-foreground hover:text-foreground"
          >
            <ArrowRight className="w-4 h-4 mr-2 rotate-180" />
            Back to Themes
          </Button>
          <h2 className="text-xl font-semibold">Create New Theme</h2>
        </div>

        <Separator />

        <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
          {/* Theme preview */}
          <div>
            <h3 className="mb-3 text-sm font-medium">Theme Preview</h3>
            <ThemePreview settings={currentSettings} />
          </div>

          {/* Theme options */}
          <div className="space-y-4">
            <div>
              <h3 className="flex items-center mb-2 text-sm font-medium">
                <Palette className="w-4 h-4 mr-1" />
                Color Options
              </h3>
              <RadioGroup
                value={currentSettings.color}
                onValueChange={(value) =>
                  setCurrentSettings({
                    ...currentSettings,
                    color: value as ThemeSettings['color'],
                  })
                }
                className="grid grid-cols-3 gap-2"
              >
                {(['default', 'blue', 'purple', 'green', 'pink', 'orange'] as const).map(
                  (color) => (
                    <div key={color}>
                      <RadioGroupItem
                        value={color}
                        id={`color-${color}`}
                        className="sr-only peer"
                      />
                      <Label
                        htmlFor={`color-${color}`}
                        className="flex flex-col items-center justify-between rounded-md border-2 border-muted bg-background p-2 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary"
                      >
                        <div className={`w-6 h-6 rounded-full ${getColorClass(color)} mb-1`}></div>
                        <span className="text-xs capitalize">{color}</span>
                      </Label>
                    </div>
                  ),
                )}
              </RadioGroup>
            </div>

            <div>
              <h3 className="flex items-center mb-2 text-sm font-medium">
                <PaintBucket className="w-4 h-4 mr-1" />
                Style Options
              </h3>
              <RadioGroup
                value={currentSettings.style}
                onValueChange={(value) =>
                  setCurrentSettings({
                    ...currentSettings,
                    style: value as ThemeSettings['style'],
                  })
                }
                className="grid grid-cols-2 gap-2"
              >
                {(['minimal', 'gradient', 'soft', 'outlined'] as const).map((style) => (
                  <div key={style}>
                    <RadioGroupItem value={style} id={`style-${style}`} className="sr-only peer" />
                    <Label
                      htmlFor={`style-${style}`}
                      className="flex flex-col items-center justify-between rounded-md border-2 border-muted bg-background p-2 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary"
                    >
                      <span className="text-xs capitalize">{style}</span>
                      <div
                        className={`w-full h-6 mt-1 rounded ${
                          style === 'minimal'
                            ? 'bg-background border'
                            : style === 'gradient'
                              ? 'bg-gradient-to-b from-blue-50 to-white'
                              : style === 'soft'
                                ? 'bg-background/90'
                                : 'bg-background border-2'
                        }`}
                      ></div>
                    </Label>
                  </div>
                ))}
              </RadioGroup>
            </div>

            <div>
              <h3 className="flex items-center mb-2 text-sm font-medium">
                <LayoutGrid className="w-4 h-4 mr-1" />
                Layout Options
              </h3>
              <RadioGroup
                value={currentSettings.layout}
                onValueChange={(value) =>
                  setCurrentSettings({
                    ...currentSettings,
                    layout: value as ThemeSettings['layout'],
                  })
                }
                className="grid grid-cols-3 gap-2"
              >
                {(['compact', 'standard', 'expanded'] as const).map((layout) => (
                  <div key={layout}>
                    <RadioGroupItem
                      value={layout}
                      id={`layout-${layout}`}
                      className="sr-only peer"
                    />
                    <Label
                      htmlFor={`layout-${layout}`}
                      className="flex flex-col items-center justify-between rounded-md border-2 border-muted bg-background p-2 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary"
                    >
                      <span className="text-xs capitalize">{layout}</span>
                      <div
                        className={`w-full mt-1 rounded border ${
                          layout === 'compact' ? 'h-5' : layout === 'expanded' ? 'h-12' : 'h-8'
                        }`}
                      ></div>
                    </Label>
                  </div>
                ))}
              </RadioGroup>
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <Button variant="outline" onClick={() => setView('themes')} disabled={isSaving}>
                Cancel
              </Button>
              <Button onClick={createNewTheme} disabled={isSaving}>
                {isSaving ? (
                  'Creating...'
                ) : (
                  <>
                    <Plus className="w-4 h-4 mr-1" />
                    Create Theme
                  </>
                )}
              </Button>
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Main navigation */}
      <div className="flex items-center justify-between pb-4 border-b">
        <div className="flex items-center gap-1">
          <Button
            variant={view === 'templates' ? 'default' : 'ghost'}
            onClick={() => setView('templates')}
            className="rounded-r-none"
          >
            <LayoutTemplate className="w-4 h-4 mr-2" />
            Templates
          </Button>
          <Button
            variant={view === 'themes' ? 'default' : 'ghost'}
            onClick={() => setView('themes')}
            className="rounded-l-none"
          >
            <Palette className="w-4 h-4 mr-2" />
            Themes
          </Button>
        </div>

        <div className="flex items-center gap-2">
          {view === 'templates' && (
            <Button
              variant="outline"
              onClick={() => setView('template-customize')}
              size="sm"
              className="ml-auto text-xs"
            >
              <Paintbrush className="w-3.5 h-3.5 mr-1.5" />
              Customize Template
            </Button>
          )}

          {view === 'themes' && (
            <Button
              variant="outline"
              onClick={() => setView('theme-create')}
              size="sm"
              className="ml-auto text-xs"
            >
              <Plus className="w-3.5 h-3.5 mr-1.5" />
              Create Theme
            </Button>
          )}
        </div>
      </div>

      {/* Template view */}
      {view === 'templates' && (
        <div className="space-y-6">
          {/* Search & Filter controls */}
          <div className="flex flex-col justify-between gap-3 sm:flex-row">
            <div className="relative flex-1 max-w-sm">
              <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search templates..."
                className="pl-9"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>

            <div className="flex flex-wrap gap-2">
              {templateCategories.map((category) => (
                <Button
                  key={category}
                  variant={activeCategory === category ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setActiveCategory(category)}
                  className="capitalize"
                >
                  {category}
                </Button>
              ))}
            </div>
          </div>

          {/* Current template highlight */}
          {currentTemplateId && (
            <div className="p-4 border rounded-lg border-border">
              <div className="flex items-start justify-between mb-3">
                <div>
                  <h3 className="text-base font-medium">Current Template</h3>
                  <p className="text-sm text-muted-foreground">
                    {profile.template?.name || 'Custom Template'}
                  </p>
                </div>
                <Button variant="outline" size="sm" onClick={() => setView('template-customize')}>
                  <Paintbrush className="w-4 h-4 mr-2" />
                  Customize
                </Button>
              </div>
            </div>
          )}

          {/* Templates grid */}
          <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
            {filteredTemplates.map((template) => (
              <Card
                key={template._id}
                className={`overflow-hidden transition-all ${currentTemplateId === template._id ? 'ring-2 ring-primary' : ''}`}
              >
                {/* Template preview image */}
                <div className="relative bg-gray-100 aspect-video">
                  {template.previewImage ? (
                    <Image
                      src={template.previewImage}
                      alt={template.name}
                      fill
                      className="object-cover"
                    />
                  ) : (
                    <div className="flex items-center justify-center h-full">
                      <LayoutTemplate className="w-12 h-12 text-muted-foreground" />
                    </div>
                  )}

                  {/* Selected indicator */}
                  {currentTemplateId === template._id && (
                    <div className="absolute p-1 text-white bg-green-500 rounded-full top-2 right-2">
                      <Check className="w-4 h-4" />
                    </div>
                  )}
                </div>

                <CardContent className="p-4">
                  <div className="mb-2">
                    <div className="flex justify-between">
                      <h3 className="font-medium">{template.name}</h3>
                      {currentTemplateId === template._id && (
                        <Badge variant="outline" className="ml-2">
                          Current
                        </Badge>
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground line-clamp-1">
                      {template.description}
                    </p>
                  </div>

                  <div className="flex items-center justify-between mt-3">
                    <div className="flex flex-wrap gap-1">
                      <span className="inline-block px-2 py-1 text-xs capitalize rounded-md bg-muted">
                        {template.category}
                      </span>
                      {template.themeId && (
                        <span className="inline-flex items-center px-2 py-1 text-xs rounded-md bg-muted">
                          <Palette className="w-3 h-3 mr-1" />
                          Themed
                        </span>
                      )}
                    </div>

                    <Button
                      size="sm"
                      variant={currentTemplateId === template._id ? 'secondary' : 'default'}
                      onClick={() => applyTemplate(template._id)}
                      disabled={currentTemplateId === template._id}
                    >
                      {currentTemplateId === template._id ? (
                        <>
                          <ThumbsUp className="w-3 h-3 mr-1.5" />
                          Applied
                        </>
                      ) : (
                        'Apply'
                      )}
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>

          {filteredTemplates.length === 0 && (
            <div className="flex flex-col items-center justify-center gap-4 p-8 border-2 border-dashed rounded-md border-border">
              <LayoutTemplate className="w-12 h-12 text-muted-foreground" />
              <p className="text-center text-muted-foreground">
                {searchQuery
                  ? `No templates found matching "${searchQuery}"`
                  : 'No templates found in this category'}
              </p>
              {searchQuery && (
                <Button variant="outline" size="sm" onClick={() => setSearchQuery('')}>
                  Clear Search
                </Button>
              )}
            </div>
          )}
        </div>
      )}

      {/* Themes view */}
      {view === 'themes' && (
        <div className="space-y-6">
          {/* Search & Filter controls */}
          <div className="flex flex-col justify-between gap-3 sm:flex-row">
            <div className="relative flex-1 max-w-sm">
              <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search themes..."
                className="pl-9"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>

            <div className="flex gap-2">
              <Button
                variant={!showMyThemesOnly ? 'default' : 'outline'}
                size="sm"
                onClick={() => setShowMyThemesOnly(false)}
              >
                All Themes
              </Button>
              <Button
                variant={showMyThemesOnly ? 'default' : 'outline'}
                size="sm"
                onClick={() => setShowMyThemesOnly(true)}
              >
                My Themes
              </Button>
            </div>
          </div>

          {/* Current theme highlight */}
          {currentThemeId && profile.theme && (
            <div className="p-4 border rounded-lg border-border">
              <div className="flex items-start justify-between mb-3">
                <div>
                  <h3 className="text-base font-medium">Current Theme</h3>
                  <p className="text-sm text-muted-foreground">
                    {profile.theme.name || 'Default Theme'}
                  </p>
                </div>
              </div>

              <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
                <div className="relative">
                  {showFullPreview ? (
                    <div className="overflow-hidden border rounded-md border-border">
                      <EnhancedProfileCard profile={profile} />
                    </div>
                  ) : (
                    <ThemePreview
                      settings={normalizeThemeSettings(profile.theme.settings)}
                      isSelected={true}
                    />
                  )}
                </div>

                <div className="flex items-center justify-center">
                  <Button
                    variant="outline"
                    onClick={() => setView('theme-create')}
                    className="shadow-sm"
                  >
                    <Plus className="w-4 h-4 mr-2" />
                    Create Similar Theme
                  </Button>
                </div>
              </div>
            </div>
          )}

          {/* No themes message for "My Themes" */}
          {showMyThemesOnly && myThemes.length === 0 && (
            <div className="flex flex-col items-center justify-center gap-4 p-8 border-2 border-dashed rounded-md border-border">
              <div className="p-4 rounded-full bg-muted">
                <PaintBucket className="w-8 h-8 text-muted-foreground" />
              </div>
              <div className="text-center">
                <p className="text-base font-medium">No custom themes yet</p>
                <p className="text-sm text-muted-foreground">
                  Create your first theme to see it here
                </p>
              </div>
              <Button onClick={() => setView('theme-create')}>
                <Plus className="w-4 h-4 mr-2" />
                Create New Theme
              </Button>
            </div>
          )}

          {/* Themes grid */}
          {themesToDisplay.length > 0 && (
            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              {themesToDisplay.map((theme) => (
                <div
                  key={theme._id}
                  className={`border rounded-lg overflow-hidden transition-all ${currentThemeId === theme._id ? 'ring-2 ring-primary' : ''}`}
                >
                  <div className="relative">
                    {showFullPreview ? (
                      <div
                        className="overflow-hidden transition-all border-b cursor-pointer"
                        onClick={() => setSelectedThemeId(theme._id)}
                      >
                        <EnhancedProfileCard profile={profile} />
                      </div>
                    ) : (
                      <div className="p-3 border-b">
                        <ThemePreview
                          settings={theme.settings}
                          isSelected={currentThemeId === theme._id}
                          onClick={() => setSelectedThemeId(theme._id)}
                        />
                      </div>
                    )}

                    {currentThemeId === theme._id && (
                      <div className="absolute p-1 text-white bg-green-500 rounded-full top-2 right-2">
                        <Check className="w-4 h-4" />
                      </div>
                    )}
                  </div>

                  <div className="flex items-center justify-between p-4">
                    <div>
                      <div className="flex items-center gap-2">
                        <h3 className="text-sm font-medium">{theme.name}</h3>
                        {currentThemeId === theme._id && (
                          <Badge variant="outline" className="text-xs">
                            Current
                          </Badge>
                        )}
                        {theme.isDefault && (
                          <Badge variant="outline" className="text-xs">
                            Default
                          </Badge>
                        )}
                      </div>
                      {theme.description && (
                        <p className="text-xs text-muted-foreground line-clamp-1">
                          {theme.description}
                        </p>
                      )}
                    </div>

                    <div className="flex gap-2">
                      <Button
                        size="sm"
                        variant={currentThemeId === theme._id ? 'secondary' : 'default'}
                        onClick={() => applyTheme(theme._id)}
                        disabled={currentThemeId === theme._id}
                      >
                        {currentThemeId === theme._id ? (
                          <>
                            <ThumbsUp className="w-3 h-3 mr-1.5" />
                            Applied
                          </>
                        ) : (
                          'Apply'
                        )}
                      </Button>

                      {showMyThemesOnly && (
                        <Button
                          size="sm"
                          variant="destructive"
                          onClick={() => deleteTheme(theme._id)}
                          disabled={currentThemeId === theme._id}
                        >
                          <Trash className="w-4 h-4" />
                        </Button>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* No themes found message */}
          {themesToDisplay.length === 0 && !showMyThemesOnly && (
            <div className="flex flex-col items-center justify-center gap-4 p-8 border-2 border-dashed rounded-md border-border">
              <Palette className="w-12 h-12 text-muted-foreground" />
              <p className="text-center text-muted-foreground">
                {searchQuery ? `No themes found matching "${searchQuery}"` : 'No themes available'}
              </p>
              {searchQuery && (
                <Button variant="outline" size="sm" onClick={() => setSearchQuery('')}>
                  Clear Search
                </Button>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  )
}



================================================
FILE: components/profile/editor/create-profile.tsx
================================================
'use client'

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { ProfileForm } from '@/components/forms/profile-form'

export function CreateProfileModal() {
  const [open, setOpen] = useState(false)

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button onClick={() => setOpen(true)}>Create Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Create Profile</DialogTitle>
        </DialogHeader>
        <ProfileForm onSuccess={() => setOpen(false)} />
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: components/profile/editor/profile-settings.tsx
================================================
'use client'

import { useState, useEffect, useRef } from 'react'
import { useMutation } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { toast } from 'sonner'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Card, CardContent } from '@/components/ui/card'
import { AvatarUpload } from '@/components/media/avatar-upload'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Profile, ProfileComplete } from '@/types/profile'

export function ProfileSettings({ profile }: { profile: ProfileComplete }) {
  const updateProfile = useMutation(api.profiles.update)

  const [bio, setBio] = useState('')
  const [handle, setHandle] = useState('')
  const [name, setName] = useState('')
  const [avatarUrl, setAvatarUrl] = useState('')
  const [loading, setLoading] = useState(false)
  const [isDirty, setIsDirty] = useState(false)

  const isUpdatingAvatar = useRef(false)

  useEffect(() => {
    if (profile) {
      if (handle === '') {
        setHandle(profile.handle || '')
      }

      if (name === '') {
        setName(profile.name || '')
      }

      if (bio === '') {
        setBio(profile.bio || '')
      }

      if (avatarUrl === '' && profile.avatarUrl) {
        setAvatarUrl(profile.avatarUrl)
      }

      setIsDirty(false)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [profile])

  const handleAvatarChange = (url: string) => {
    console.log('Avatar change called with URL:', url)

    if (url === '') {
      console.log('Removing avatar')
      setAvatarUrl('')
    } else {
      /*
       * Prevent duplicate updates
       */
      if (url === avatarUrl) return
      if (isUpdatingAvatar.current) return
      isUpdatingAvatar.current = true

      setAvatarUrl(url)

      setTimeout(() => {
        isUpdatingAvatar.current = false
      }, 100)
    }
    setIsDirty(true)
  }

  const handleHandleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setHandle(e.target.value)
    setIsDirty(true)
  }

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value)
    setIsDirty(true)
  }

  const handleBioChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setBio(e.target.value)
    setIsDirty(true)
  }

  const handleSaveAll = async () => {
    setLoading(true)

    try {
      await saveProfileChanges({
        bio,
        handle,
        name,
        avatarUrl,
      })

      setIsDirty(false)
    } finally {
      setLoading(false)
    }
  }

  const saveProfileChanges = async (changes: Partial<Profile>) => {
    try {
      await updateProfile({
        profileId: profile._id,
        ...changes,
      })
      toast.success('Profile updated')
      return true
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to update profile'
      toast.error(errorMsg)
      console.error(error)
      return false
    }
  }

  if (!profile) {
    return (
      <Card>
        <CardContent className="p-6 text-center">Loading profile...</CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-end">
        <div className="text-sm text-muted-foreground">
          {isDirty && !loading && (
            <span className="text-amber-500 animate-pulse">● Unsaved changes</span>
          )}
        </div>
      </div>

      <div className="flex flex-col gap-6 md:flex-row">
        <div className="flex-shrink-0">
          <Label className="block mb-2">Profile Picture</Label>
          <AvatarUpload
            onChange={handleAvatarChange}
            existingImageUrl={avatarUrl || profile.avatarUrl}
            handle={profile.handle}
            size="lg"
            disabled={false}
            key={`avatar-${avatarUrl || 'none'}`}
          />
        </div>

        <div className="flex-1 space-y-4">
          <div>
            <Label className="block mb-2">Name</Label>
            <Input
              value={name}
              onChange={handleNameChange}
              placeholder={profile.handle || 'your-custom-link'}
            />

            <div>
              <Label className="block mb-2">Handle</Label>
              <div className="flex items-center">
                <span className="mr-2">/</span>
                <Input
                  value={handle}
                  onChange={handleHandleChange}
                  placeholder={profile.handle || 'Your handle'}
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      <div>
        <Label className="block mb-2">Bio</Label>
        <Textarea
          value={bio}
          onChange={handleBioChange}
          placeholder={profile.bio || 'Write something about yourself'}
          className="min-h-[100px]"
        />
      </div>

      {/* Save All Button */}
      <div className="flex justify-end mt-6">
        <Button onClick={handleSaveAll} disabled={loading || !isDirty}>
          {loading ? 'Saving...' : 'Save Changes'}
        </Button>
      </div>
    </div>
  )
}



================================================
FILE: components/profile/editor/template-customizer.tsx
================================================
'use client'

import { useState } from 'react'
import { useMutation } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'
import { Switch } from '@/components/ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion'
import { toast } from 'sonner'
import {
  Box,
  PanelTop,
  Link as LinkIcon,
  Image as ImageIcon,
  FileText,
  Heart,
  MessageSquare,
} from 'lucide-react'
import { ProfileTemplateRenderer } from '@/components/templates/profile-template-renderer'
import { ProfileComplete } from '@/types/profile'

export function TemplateCustomizer({ profile }: { profile: ProfileComplete }) {
  const [activeTab, setActiveTab] = useState('layout')
  const [previewMode, setPreviewMode] = useState<'mobile' | 'desktop'>('mobile')
  const [expandedComponent, setExpandedComponent] = useState<string | undefined>(undefined)

  const updateComponentSettings = useMutation(api.profileTemplates.updateComponentSettings)

  const handleComponentUpdate = async (
    componentType: string,
    settings: Record<string, unknown>,
  ) => {
    try {
      await updateComponentSettings({
        profileId: profile._id,
        componentType,
        settings,
      })
      toast.success('Component settings updated')
    } catch (error) {
      toast.error('Failed to update component settings')
      console.error(error)
    }
  }

  const template = profile.template
  const components = template.components || []

  // Sort components by order
  const sortedComponents = [...components].sort((a, b) => a.order - b.order)

  // Toggle component enabled state
  const toggleComponentEnabled = (componentType: string, isEnabled: boolean) => {
    const componentToUpdate = components.find((c) => c.type === componentType)
    if (componentToUpdate) {
      const updatedSettings = { ...componentToUpdate.settings, isEnabled }
      handleComponentUpdate(componentType, updatedSettings)
    }
  }

  // Get icon for component type
  const getComponentIcon = (type: string) => {
    switch (type) {
      case 'header':
        return <PanelTop className="w-4 h-4" />
      case 'bio':
        return <FileText className="w-4 h-4" />
      case 'links':
        return <LinkIcon className="w-4 h-4" />
      case 'social':
        return <LinkIcon className="w-4 h-4" />
      case 'gallery':
        return <ImageIcon className="w-4 h-4" />
      case 'items':
        return <Box className="w-4 h-4" />
      case 'contact':
        return <MessageSquare className="w-4 h-4" />
      case 'donation':
        return <Heart className="w-4 h-4" />
      default:
        return <Box className="w-4 h-4" />
    }
  }

  // Get formatted name for component type
  const getComponentName = (type: string) => {
    switch (type) {
      case 'header':
        return 'Header'
      case 'bio':
        return 'Biography'
      case 'links':
        return 'Links'
      case 'social':
        return 'Social Media'
      case 'gallery':
        return 'Gallery'
      case 'items':
        return 'Items & Products'
      case 'contact':
        return 'Contact Form'
      case 'donation':
        return 'Donation Section'
      default:
        return type.charAt(0).toUpperCase() + type.slice(1)
    }
  }

  return (
    <div className="grid grid-cols-1 gap-6 md:grid-cols-5">
      {/* Preview section */}
      <Card className="md:col-span-3">
        <CardHeader className="p-4 pb-0">
          <div className="flex items-center justify-between">
            <CardTitle className="text-lg">Template Preview</CardTitle>
            <div className="flex gap-1">
              <Button
                variant={previewMode === 'mobile' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setPreviewMode('mobile')}
              >
                Mobile
              </Button>
              <Button
                variant={previewMode === 'desktop' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setPreviewMode('desktop')}
              >
                Desktop
              </Button>
            </div>
          </div>
        </CardHeader>

        <CardContent className="p-6">
          <div
            className={`mx-auto ${previewMode === 'mobile' ? 'max-w-[375px]' : 'max-w-full'} border rounded-md overflow-hidden`}
          >
            <ProfileTemplateRenderer profile={profile} editable={false} />
          </div>
        </CardContent>
      </Card>

      {/* Editing controls */}
      <Card className="md:col-span-2">
        <CardHeader className="p-4 pb-0">
          <CardTitle className="text-lg">Template Settings</CardTitle>
        </CardHeader>

        <CardContent className="p-4">
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="w-full mb-4">
              <TabsTrigger value="layout">Layout</TabsTrigger>
              <TabsTrigger value="style">Style</TabsTrigger>
              <TabsTrigger value="fonts">Fonts</TabsTrigger>
            </TabsList>

            <TabsContent value="layout" className="space-y-4">
              <div className="space-y-2">
                <h3 className="text-sm font-medium">Components</h3>
                <p className="text-xs text-muted-foreground">
                  Enable, disable, and customize components
                </p>
              </div>

              <Accordion
                type="single"
                collapsible
                value={expandedComponent}
                onValueChange={setExpandedComponent}
              >
                {sortedComponents.map((component) => (
                  <AccordionItem key={component.type} value={component.type}>
                    <div className="flex items-center justify-between py-2">
                      <div className="flex items-center gap-2">
                        <div className="flex items-center justify-center w-8 h-8 border rounded-md">
                          {getComponentIcon(component.type)}
                        </div>
                        <div>
                          <p className="text-sm font-medium">{getComponentName(component.type)}</p>
                        </div>
                      </div>

                      <div className="flex items-center gap-2">
                        <Switch
                          checked={component.isEnabled}
                          onCheckedChange={(checked) =>
                            toggleComponentEnabled(component.type, checked)
                          }
                        />
                        <AccordionTrigger className="w-8 h-8 p-0 rounded-md hover:bg-muted">
                          <span className="sr-only">Toggle {component.type} settings</span>
                        </AccordionTrigger>
                      </div>
                    </div>

                    <AccordionContent className="pt-2">
                      <Card className="overflow-hidden">
                        <CardContent className="p-3">
                          <ProfileTemplateRenderer
                            profile={profile}
                            editable={true}
                            onComponentUpdate={handleComponentUpdate}
                          />
                        </CardContent>
                      </Card>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </TabsContent>

            <TabsContent value="style" className="space-y-4">
              <div className="space-y-2">
                <h3 className="text-sm font-medium">Style Customization</h3>
                <p className="text-xs text-muted-foreground">
                  Adjust spacing, borders, and shadows
                </p>
              </div>

              <div className="space-y-4">
                <div>
                  <Label htmlFor="cardPadding" className="text-sm">
                    Card Padding
                  </Label>
                  <Select
                    value={template.customizations?.spacing?.cardPadding || 'medium'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="cardPadding">
                      <SelectValue placeholder="Select padding" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                      <SelectItem value="small">Small</SelectItem>
                      <SelectItem value="medium">Medium</SelectItem>
                      <SelectItem value="large">Large</SelectItem>
                      <SelectItem value="xlarge">Extra Large</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="elementSpacing" className="text-sm">
                    Element Spacing
                  </Label>
                  <Select
                    value={template.customizations?.spacing?.elementSpacing || 'md'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="elementSpacing">
                      <SelectValue placeholder="Select spacing" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                      <SelectItem value="xs">Extra Small</SelectItem>
                      <SelectItem value="sm">Small</SelectItem>
                      <SelectItem value="md">Medium</SelectItem>
                      <SelectItem value="lg">Large</SelectItem>
                      <SelectItem value="xl">Extra Large</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="cardBorderRadius" className="text-sm">
                    Border Radius
                  </Label>
                  <Select
                    value={template.customizations?.shape?.cardBorderRadius || 'medium'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="cardBorderRadius">
                      <SelectValue placeholder="Select border radius" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                      <SelectItem value="small">Small</SelectItem>
                      <SelectItem value="medium">Medium</SelectItem>
                      <SelectItem value="large">Large</SelectItem>
                      <SelectItem value="full">Full (Rounded)</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="cardShadow" className="text-sm">
                    Shadow
                  </Label>
                  <Select
                    value={template.customizations?.shadows?.cardShadow || 'medium'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="cardShadow">
                      <SelectValue placeholder="Select shadow" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                      <SelectItem value="small">Small</SelectItem>
                      <SelectItem value="medium">Medium</SelectItem>
                      <SelectItem value="large">Large</SelectItem>
                      <SelectItem value="xl">Extra Large</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </TabsContent>

            <TabsContent value="fonts" className="space-y-4">
              <div className="space-y-2">
                <h3 className="text-sm font-medium">Font Settings</h3>
                <p className="text-xs text-muted-foreground">
                  Customize typography throughout your profile
                </p>
              </div>

              <div className="space-y-4">
                <div>
                  <Label htmlFor="headingFont" className="text-sm">
                    Heading Font
                  </Label>
                  <Select
                    value={template.customizations?.fonts?.heading || 'inter'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="headingFont">
                      <SelectValue placeholder="Select font" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="inter">Inter</SelectItem>
                      <SelectItem value="roboto">Roboto</SelectItem>
                      <SelectItem value="playfair">Playfair Display</SelectItem>
                      <SelectItem value="montserrat">Montserrat</SelectItem>
                      <SelectItem value="oswald">Oswald</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="bodyFont" className="text-sm">
                    Body Font
                  </Label>
                  <Select
                    value={template.customizations?.fonts?.body || 'inter'}
                    onValueChange={() => {
                      // Update template customizations
                    }}
                  >
                    <SelectTrigger id="bodyFont">
                      <SelectValue placeholder="Select font" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="inter">Inter</SelectItem>
                      <SelectItem value="roboto">Roboto</SelectItem>
                      <SelectItem value="playfair">Playfair Display</SelectItem>
                      <SelectItem value="montserrat">Montserrat</SelectItem>
                      <SelectItem value="oswald">Oswald</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  )
}



================================================
FILE: components/profile/sections/donation-section.tsx
================================================
'use client'

import { Doc, Id } from '@/convex/_generated/dataModel'
import dynamic from 'next/dynamic'
import { api } from '@/convex/_generated/api'
import { useQuery } from 'convex/react'

// Dynamically import the donate button with client-side only rendering
const DonateButton = dynamic(
  () => import('@/components/monetization/donate-button').then((mod) => mod.DonateButton),
  { ssr: false, loading: () => null },
)

interface DonationSectionProps {
  profileId: Id<'profiles'>
  handle: Doc<'profiles'>['handle']
  theme: Doc<'profileThemes'>
}

export function DonationSection({ profileId, handle, theme }: DonationSectionProps) {
  const hasStripeConnected = useQuery(api.profiles.hasStripeConnected, {
    profileId,
  })

  if (hasStripeConnected === undefined || !hasStripeConnected) {
    return null
  }

  return <DonateButton profileId={profileId} handle={handle} theme={theme} />
}



================================================
FILE: components/profile/sections/draggable-section.tsx
================================================
'use client'

import { useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { GripVertical } from 'lucide-react'

interface DraggableSectionProps {
  id: string
  children: React.ReactNode
  className?: string
}

export function DraggableSection({ id, children, className = '' }: DraggableSectionProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  return (
    <div 
      ref={setNodeRef} 
      style={style}
      className={`relative ${className} group`}
    >
      <div 
        {...attributes} 
        {...listeners} 
        className="absolute left-0 top-1/2 -translate-y-1/2 -ml-8 opacity-20 group-hover:opacity-100 transition cursor-grab p-2"
      >
        <GripVertical className="h-5 w-5 text-muted-foreground" />
      </div>
      {children}
    </div>
  )
}


================================================
FILE: components/profile/sections/profile-content-dnd.tsx
================================================
'use client'

import { useState, useEffect, useRef } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { ExternalLink, UserIcon } from 'lucide-react'
import {
  getAvatarClasses,
  getAvatarPlaceholderClasses,
  getItemCardClasses,
  getLinkButtonClasses,
  getProfileCardClasses,
} from '@/lib/theme-mappings'
import { DonationSection } from '@/components/profile/sections/donation-section'
import { cn } from '@/lib/utils'
import { ProfileComplete, Section } from '@/types/profile'
import { defaultTheme } from '@/convex/seed/profileThemes'
import { DraggableSection } from './draggable-section'
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable'

interface ProfileContentDnDProps {
  profile: ProfileComplete
  isPreview?: boolean
  onSectionsChange?: (sections: Section[]) => void
}

export function ProfileContentDnD({
  profile,
  isPreview = false,
  onSectionsChange,
}: ProfileContentDnDProps) {
  const { theme, links, items, sections } = profile
  const isFirstRender = useRef(true)

  // Create a proper theme object from settings for components requiring a full theme object
  const profileTheme = theme ?? defaultTheme

  // Initialize with defaults
  const [newSections, setNewSections] = useState<Section[]>(sections)

  // Update sections when external sources change - but don't call onSectionsChange
  useEffect(() => {
    if (newSections) {
      // If prop sections are provided, use those
      setNewSections(newSections)
    } else if (sections && isFirstRender.current) {
      // Otherwise, use saved sections from backend (only on first render)
      setNewSections(sections)
      isFirstRender.current = false

      // Notify parent component about the initial sections, but only if they came from the backend
      // and there were no prop sections provided
      if (onSectionsChange && !newSections) {
        // Use setTimeout to ensure this happens after render is complete
        setTimeout(() => {
          onSectionsChange(sections)
        }, 0)
      }
    }
  }, [profile.sections, sections, newSections, onSectionsChange])

  // Set up DnD sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      // Disable sensor when in preview mode
      activationConstraint: {
        distance: isPreview ? 999999 : 5, // Effectively disabled in preview mode
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  )

  // Handle drag end to reorder sections (only in edit mode)
  const handleDragEnd = (event: DragEndEvent) => {
    if (isPreview) return // Don't process drag in preview mode

    const { active, over } = event

    if (over && active.id !== over.id) {
      // Find the current indices
      const oldIndex = newSections.findIndex((section) => section.id === active.id)
      const newIndex = newSections.findIndex((section) => section.id === over.id)

      if (oldIndex !== -1 && newIndex !== -1) {
        // Create a new array with the moved item
        const updatedSections = arrayMove([...newSections], oldIndex, newIndex)

        // Find the avatar section if it exists
        const avatarSectionIndex = updatedSections.findIndex((s) => s.type === 'avatar')
        
        // If avatar section exists but isn't at the top, adjust the array
        if (avatarSectionIndex > 0) {
          // Remove avatar section and reinsert at the beginning
          const avatarSection = updatedSections.splice(avatarSectionIndex, 1)[0]
          updatedSections.unshift(avatarSection)
        }

        // Update order property
        const sectionsWithOrder = updatedSections.map((section, index) => ({
          ...section,
          order: index,
        }))

        // Update local state
        setNewSections(sectionsWithOrder)

        // Notify parent component about the change
        if (onSectionsChange) {
          // Schedule the notification outside of the current call stack
          setTimeout(() => {
            onSectionsChange(sectionsWithOrder)
          }, 0)
        }
      }
    }
  }

  // Render section based on type
  const renderSection = (section: Section) => {
    if (!section.visible) return null

    switch (section.type) {
      case 'avatar':
        return (
          <div className="flex flex-col items-center w-full max-w-md mx-auto mb-8 text-center">
            <div className={getAvatarClasses(profileTheme.settings)}>
              {profile.avatarUrl ? (
                <Image width={200} height={200} src={profile.avatarUrl} alt={profile.handle} />
              ) : (
                <div className={getAvatarPlaceholderClasses(profileTheme.settings)}>
                  <UserIcon className="w-10 h-10 text-muted-foreground" />
                </div>
              )}
            </div>
            <h2 className="text-3xl font-bold">{profile.handle}</h2>
            {profile.bio && <p className="max-w-xs px-4 text-muted-foreground">{profile.bio}</p>}
          </div>
        )

      case 'donation':
        return (
          <DonationSection profileId={profile._id} handle={profile.handle} theme={profileTheme} />
        )

      case 'links':
        if (!links || links.length === 0) return null
        return (
          <div className="flex flex-col max-w-md gap-2 mx-auto whitespace-nowrap">
            {links.map((link) => (
              <Link
                key={link._id}
                href={link.url}
                target="_blank"
                rel="noopener noreferrer"
                passHref
              >
                <Button className={getLinkButtonClasses(profileTheme.settings)}>
                  <span className="font-medium truncate">{link.title}</span>
                  <ExternalLink className="flex-shrink-0 w-4 h-4 text-muted-foreground" />
                </Button>
              </Link>
            ))}
          </div>
        )

      case 'items':
        if (!items || items.length === 0) return null
        return (
          <div className="flex flex-col max-w-md gap-2 mx-auto mt-6 whitespace-nowrap">
            {items.map((item) => (
              <div key={item._id} className={getItemCardClasses(profileTheme.settings)}>
                <div className="mb-2 font-medium text-primary/90">{item.title}</div>
                {item.description && (
                  <div className="flex-grow mt-1 text-xs text-muted-foreground line-clamp-2">
                    {item.description}
                  </div>
                )}
                <div className="pt-2 mt-auto">
                  {item.type?.kind === 'paid' && (
                    <Badge variant="secondary" className="px-3 rounded-full">
                      ${item.type.price}
                    </Badge>
                  )}
                  {item.type?.kind === 'link' && item.type.url && (
                    <a
                      href={item.type.url}
                      className="flex items-center gap-1 text-xs font-medium text-primary hover:underline"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      View <ExternalLink className="w-3 h-3" />
                    </a>
                  )}
                </div>
              </div>
            ))}
          </div>
        )

      default:
        return null
    }
  }

  // Sort sections by order property
  const sortedSections = [...newSections].sort((a, b) => a.order - b.order)

  // Separate avatar section from other sections
  const avatarSection = sortedSections.find((s) => s.type === 'avatar' && s.visible)
  
  // Get all other visible sections that aren't the avatar
  const otherSections = sortedSections.filter((s) => s.type !== 'avatar' && s.visible)
  
  // Get only the visible non-avatar sections for sortable context
  const visibleSectionIds = otherSections.map((s) => s.id)

  // Create the DnD context
  return (
    <div className={cn(isPreview ? '' : getProfileCardClasses(profileTheme.settings))}>
      {/* Render avatar section outside of DnD context */}
      {avatarSection && (
        <div className="mb-6 py-4 px-2">
          {renderSection(avatarSection)}
        </div>
      )}
      
      {/* Only include other sections in the DnD context */}
      {otherSections.length > 0 && (
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
          <SortableContext items={visibleSectionIds} strategy={verticalListSortingStrategy}>
            {otherSections.map((section) => (
              <DraggableSection
                key={section.id}
                id={section.id}
                className="mb-6 py-4 px-2 rounded-lg hover:bg-muted/5 transition-colors"
              >
                {renderSection(section)}
              </DraggableSection>
            ))}
          </SortableContext>
        </DndContext>
      )}
    </div>
  )
}



================================================
FILE: components/profile/sections/profile-content.tsx
================================================
'use client'

import { ProfileComplete, Section } from '@/types/profile'
import { ProfileContentDnD } from './profile-content-dnd'

interface ProfileContentProps {
  profile: ProfileComplete
  isPreview?: boolean
  onSectionsChange?: (sections: Section[]) => void
}

export function ProfileContent({
  profile,
  isPreview = false,
  onSectionsChange,
}: ProfileContentProps) {
  return (
    <ProfileContentDnD
      profile={profile}
      isPreview={isPreview}
      onSectionsChange={onSectionsChange}
    />
  )
}



================================================
FILE: components/profile/sections/public-profile-content.tsx
================================================
'use client'

import Image from 'next/image'
import Link from 'next/link'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { ExternalLink, UserIcon } from 'lucide-react'
import {
  getAvatarClasses,
  getAvatarPlaceholderClasses,
  getItemCardClasses,
  getLinkButtonClasses,
  getProfileCardClasses,
} from '@/lib/theme-mappings'
import { DonationSection } from '@/components/profile/sections/donation-section'
import { ProfileComplete, Section } from '@/types/profile'
import { defaultTheme } from '@/convex/seed/profileThemes'

interface PublicProfileContentProps {
  profile: ProfileComplete
}

export function PublicProfileContent({ profile }: PublicProfileContentProps) {
  const { theme, links, items, sections } = profile

  // Create a proper theme object from settings
  const profileTheme = theme ?? defaultTheme

  // Sort sections by order property
  const sortedSections = [...sections].sort((a, b) => a.order - b.order)

  // Render section based on type
  const renderSection = (section: Section) => {
    if (!section.visible) return null

    switch (section.type) {
      case 'avatar':
        return (
          <div
            key={section.id}
            className="flex flex-col items-center w-full max-w-md mx-auto mb-8 text-center"
          >
            <div className={getAvatarClasses(profileTheme.settings)}>
              {profile.avatarUrl ? (
                <Image width={200} height={200} src={profile.avatarUrl} alt={profile.handle} />
              ) : (
                <div className={getAvatarPlaceholderClasses(profileTheme.settings)}>
                  <UserIcon className="w-10 h-10 text-muted-foreground" />
                </div>
              )}
            </div>
            <h2 className="text-3xl font-bold">{profile.handle}</h2>
            {profile.bio && <p className="max-w-xs px-4 text-muted-foreground">{profile.bio}</p>}
          </div>
        )

      case 'donation':
        return (
          <div key={section.id}>
            <DonationSection profileId={profile._id} handle={profile.handle} theme={profileTheme} />
          </div>
        )

      case 'links':
        if (!links || links.length === 0) return null
        return (
          <div key={section.id} className="flex flex-col max-w-md gap-2 mx-auto whitespace-nowrap">
            {links.map((link) => (
              <Link
                key={link._id}
                href={link.url}
                target="_blank"
                rel="noopener noreferrer"
                passHref
              >
                <Button className={getLinkButtonClasses(profileTheme.settings)}>
                  <span className="font-medium truncate">{link.title}</span>
                  <ExternalLink className="flex-shrink-0 w-4 h-4 text-muted-foreground" />
                </Button>
              </Link>
            ))}
          </div>
        )

      case 'items':
        if (!items || items.length === 0) return null
        return (
          <div
            key={section.id}
            className="flex flex-col max-w-md gap-2 mx-auto mt-6 whitespace-nowrap"
          >
            {items.map((item) => (
              <div key={item._id} className={getItemCardClasses(profileTheme.settings)}>
                <div className="mb-2 font-medium text-primary/90">{item.title}</div>
                {item.description && (
                  <div className="flex-grow mt-1 text-xs text-muted-foreground line-clamp-2">
                    {item.description}
                  </div>
                )}
                <div className="pt-2 mt-auto">
                  {item.type?.kind === 'paid' && (
                    <Badge variant="secondary" className="px-3 rounded-full">
                      ${item.type.price}
                    </Badge>
                  )}
                  {item.type?.kind === 'link' && item.type.url && (
                    <a
                      href={item.type.url}
                      className="flex items-center gap-1 text-xs font-medium text-primary hover:underline"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      View <ExternalLink className="w-3 h-3" />
                    </a>
                  )}
                </div>
              </div>
            ))}
          </div>
        )

      default:
        return null
    }
  }

  return (
    <div className={getProfileCardClasses(profileTheme.settings)}>
      {sortedSections
        .filter((section) => section.visible)
        .map((section) => (
          <div key={section.id} className="mb-6">
            {renderSection(section)}
          </div>
        ))}
    </div>
  )
}



================================================
FILE: components/providers/client-providers.tsx
================================================
'use client'

import { ConvexClientProvider } from '@/components/providers/convex-client-provider'
import { ThemeProvider } from '@/components/providers/theme-provider'

export default function ClientProviders({ children }: { children: React.ReactNode }) {
  return (
    <ConvexClientProvider>
      <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
        {children}
      </ThemeProvider>
    </ConvexClientProvider>
  )
}



================================================
FILE: components/providers/convex-client-provider.tsx
================================================
'use client';

import { ConvexAuthNextjsProvider } from '@convex-dev/auth/nextjs';
import { ConvexReactClient } from 'convex/react';
import { ReactNode } from 'react';

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexAuthNextjsProvider client={convex}>{children}</ConvexAuthNextjsProvider>;
}



================================================
FILE: components/providers/theme-provider.tsx
================================================
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';

export function ThemeProvider({ children, ...props }: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



================================================
FILE: components/templates/default-profile-layout.tsx
================================================
'use client'

import React from 'react'
import { HeaderComponentSettings, LinksComponentSettings } from '@/types/template'
import { HeaderComponent } from './components/header-component'
import { LinksComponent } from './components/links-component'
import { DonationComponent } from './components/donation-component'
import { ProfileComplete } from '@/types/profile'

export function DefaultProfileLayout({ profile }: { profile: ProfileComplete }) {
  const headerSettings: HeaderComponentSettings = {
    showAvatar: true,
    avatarSize: 'medium',
    showBio: true,
    alignment: 'center',
    showSocial: false,
  }

  const linksSettings: LinksComponentSettings = {
    layout: 'list',
    buttonStyle: 'filled',
    showIcons: true,
    animation: 'none',
  }

  const donationSettings = {
    showButton: true,
    buttonText: 'Support Me',
    showSuggestedAmounts: true,
    suggestedAmounts: [5, 10, 20],
  }

  return (
    <div className="max-w-lg p-4 mx-auto space-y-6">
      <HeaderComponent settings={headerSettings} profile={profile} editable={false} />

      <DonationComponent settings={donationSettings} profile={profile} editable={false} />

      <LinksComponent settings={linksSettings} profile={profile} editable={false} />
    </div>
  )
}



================================================
FILE: components/templates/profile-template-renderer.tsx
================================================
'use client'

import React from 'react'
import {
  BioComponentSettings,
  ContactComponentSettings,
  DonationComponentSettings,
  GalleryComponentSettings,
  HeaderComponentSettings,
  ItemsComponentSettings,
  LinksComponentSettings,
  SocialComponentSettings,
} from '@/types/template'
import { HeaderComponent } from './components/header-component'
import { LinksComponent } from './components/links-component'
import { BioComponent } from './components/bio-component'
import { SocialComponent } from './components/social-component'
import { GalleryComponent } from './components/gallery-component'
import { ItemsComponent } from './components/items-component'
import { ContactComponent } from './components/contact-component'
import { DonationComponent } from './components/donation-component'
import { getContainerClasses, getSpacingClasses } from '@/lib/template-mappings'
import { DefaultProfileLayout } from './default-profile-layout'
import { ProfileComplete } from '@/types/profile'

interface ProfileTemplateRendererProps {
  profile: ProfileComplete
  editable?: boolean
  onComponentUpdate?: (componentType: string, settings: Record<string, unknown>) => void
}

export function ProfileTemplateRenderer({
  profile,
  editable = false,
  onComponentUpdate,
}: ProfileTemplateRendererProps) {
  const { template, componentSettings = {} } = profile

  // If no template, render default layout
  if (!template) {
    return <DefaultProfileLayout profile={profile} />
  }

  // Sort components by order
  const sortedComponents = [...template.components].sort((a, b) => a.order - b.order)

  // Only show enabled components
  const enabledComponents = sortedComponents.filter((comp) => comp.isEnabled)

  // Apply user's component overrides if they exist
  const componentsWithOverrides = enabledComponents.map((component) => {
    const userOverrides = componentSettings[component.type] || {}
    return {
      ...component,
      settings: {
        ...component.settings,
        ...userOverrides,
      },
    }
  })

  return (
    <div className="profile-template">
      {/* Apply custom CSS if it exists */}
      {template.customizations?.customCss && (
        <style dangerouslySetInnerHTML={{ __html: template.customizations.customCss }} />
      )}

      {/* Container with spacing from template */}
      <div className={getContainerClasses(template.customizations)}>
        <div className={getSpacingClasses(template.customizations)}>
          {componentsWithOverrides.map((component, index) => (
            <div key={`${component.type}-${index}`}>
              {renderComponent(component, profile, editable, onComponentUpdate)}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

function renderComponent(
  component: {
    type: string
    settings:
      | HeaderComponentSettings
      | BioComponentSettings
      | LinksComponentSettings
      | SocialComponentSettings
      | ContactComponentSettings
      | GalleryComponentSettings
      | ItemsComponentSettings
      | DonationComponentSettings
  },
  profile: ProfileComplete,
  editable: boolean,
  onComponentUpdate?: (componentType: string, settings: Record<string, unknown>) => void,
) {
  switch (component.type) {
    case 'header':
      return (
        <HeaderComponent
          settings={component.settings as HeaderComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('header', settings) : undefined}
        />
      )
    case 'bio':
      return (
        <BioComponent
          settings={component.settings as BioComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('bio', settings) : undefined}
        />
      )
    case 'links':
      return (
        <LinksComponent
          settings={component.settings as LinksComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('links', settings) : undefined}
        />
      )
    case 'social':
      return (
        <SocialComponent
          settings={component.settings as SocialComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('social', settings) : undefined}
        />
      )
    case 'gallery':
      return (
        <GalleryComponent
          settings={component.settings as GalleryComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('gallery', settings) : undefined}
        />
      )
    case 'items':
      return (
        <ItemsComponent
          settings={component.settings as ItemsComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('items', settings) : undefined}
        />
      )
    case 'contact':
      return (
        <ContactComponent
          settings={component.settings as ContactComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('contact', settings) : undefined}
        />
      )
    case 'donation':
      return (
        <DonationComponent
          settings={component.settings as DonationComponentSettings}
          profile={profile}
          editable={editable}
          onUpdate={editable ? (settings) => onComponentUpdate?.('donation', settings) : undefined}
        />
      )
    default:
      return null
  }
}



================================================
FILE: components/templates/components/bio-component.tsx
================================================
'use client'

import React, { useState } from 'react'
import { BioComponentSettings } from '@/types/template'
import { Card } from '@/components/ui/card'
import { Switch } from '@/components/ui/switch'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'
import { ChevronDown, ChevronUp } from 'lucide-react'
import { getFontClasses } from '@/lib/template-mappings'
import { ProfileComplete } from '@/types/profile'

interface BioComponentProps {
  settings: BioComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<BioComponentSettings>) => void
}

export function BioComponent({ settings, profile, editable = false, onUpdate }: BioComponentProps) {
  const {
    showTitle = true,
    titleText = 'About Me',
    maxLength = 150,
    showReadMore = true,
  } = settings

  const [expanded, setExpanded] = useState(false)

  // Get template customizations
  const customizations = profile.template?.customizations

  // If no bio and not in edit mode, don't render anything
  if (!profile.bio && !editable) {
    return null
  }

  const bioText = profile.bio || ''
  const needsReadMore = bioText.length > maxLength && showReadMore

  const renderBioContent = () => {
    if (!bioText) {
      return <p className="italic text-muted-foreground">No bio added yet</p>
    }

    if (!needsReadMore || expanded) {
      return <p className={`${getFontClasses('body', customizations)}`}>{bioText}</p>
    }

    return (
      <>
        <p className={`${getFontClasses('body', customizations)}`}>
          {bioText.substring(0, maxLength)}...
        </p>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setExpanded(true)}
          className="h-auto px-2 py-1 mt-1 text-xs"
        >
          Read more <ChevronDown className="w-3 h-3 ml-1" />
        </Button>
      </>
    )
  }

  return (
    <div>
      {showTitle && (
        <h2 className={`${getFontClasses('heading', customizations)} text-lg font-medium mb-2`}>
          {titleText}
        </h2>
      )}

      <div className="space-y-2">
        {renderBioContent()}

        {expanded && needsReadMore && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setExpanded(false)}
            className="h-auto px-2 py-1 mt-1 text-xs"
          >
            Show less <ChevronUp className="w-3 h-3 ml-1" />
          </Button>
        )}
      </div>

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Bio Settings</h3>
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span>Show Title</span>
              <Switch
                checked={showTitle}
                onCheckedChange={(checked) => onUpdate?.({ showTitle: checked })}
              />
            </div>

            {showTitle && (
              <div>
                <Label htmlFor="titleText">Title Text</Label>
                <Input
                  id="titleText"
                  value={titleText}
                  onChange={(e) => onUpdate?.({ titleText: e.target.value })}
                />
              </div>
            )}

            <div>
              <Label htmlFor="maxLength">Max Length Before &quot;Read More&quot;</Label>
              <Input
                id="maxLength"
                type="number"
                min="50"
                max="500"
                value={maxLength}
                onChange={(e) => onUpdate?.({ maxLength: Number(e.target.value) })}
              />
            </div>

            <div className="flex items-center justify-between">
              <span>Show &quot;Read More&quot; Button</span>
              <Switch
                checked={showReadMore}
                onCheckedChange={(checked) => onUpdate?.({ showReadMore: checked })}
              />
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/contact-component.tsx
================================================
'use client'

import React, { useState } from 'react'
import { ContactComponentSettings } from '@/types/template'
import { Card } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Button } from '@/components/ui/button'
import { Switch } from '@/components/ui/switch'
import { getFontClasses } from '@/lib/template-mappings'
import { CheckCircle2 } from 'lucide-react'
import { ProfileComplete } from '@/types/profile'

interface ContactComponentProps {
  settings: ContactComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<ContactComponentSettings>) => void
}

export function ContactComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: ContactComponentProps) {
  const {
    showTitle = true,
    titleText = 'Contact Me',
    fields = ['name', 'email', 'message'],
    buttonText = 'Send Message',
  } = settings

  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
    message: '',
  })
  const [isSubmitted, setIsSubmitted] = useState(false)

  // Get customizations
  const customizations = profile.template?.customizations

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target
    setFormData((prev) => ({ ...prev, [name]: value }))
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    // In a real app, send the form data to the server
    console.log('Form submitted:', formData)
    setIsSubmitted(true)
  }

  // Define field labels and types
  const fieldConfig = {
    name: { label: 'Name', type: 'text' },
    email: { label: 'Email', type: 'email' },
    phone: { label: 'Phone', type: 'tel' },
    message: { label: 'Message', type: 'textarea' },
  }

  // Check if a field should be rendered
  const shouldRenderField = (fieldName: keyof typeof fieldConfig) => {
    return fields.includes(fieldName)
  }

  return (
    <div>
      {showTitle && (
        <h2 className={`${getFontClasses('heading', customizations)} text-lg font-medium mb-3`}>
          {titleText}
        </h2>
      )}

      {!isSubmitted ? (
        <form onSubmit={handleSubmit} className="space-y-4">
          {shouldRenderField('name') && (
            <div>
              <Label htmlFor="name">{fieldConfig.name.label}</Label>
              <Input
                id="name"
                name="name"
                type={fieldConfig.name.type}
                value={formData.name}
                onChange={handleInputChange}
                required
              />
            </div>
          )}

          {shouldRenderField('email') && (
            <div>
              <Label htmlFor="email">{fieldConfig.email.label}</Label>
              <Input
                id="email"
                name="email"
                type={fieldConfig.email.type}
                value={formData.email}
                onChange={handleInputChange}
                required
              />
            </div>
          )}

          {shouldRenderField('phone') && (
            <div>
              <Label htmlFor="phone">{fieldConfig.phone.label}</Label>
              <Input
                id="phone"
                name="phone"
                type={fieldConfig.phone.type}
                value={formData.phone}
                onChange={handleInputChange}
              />
            </div>
          )}

          {shouldRenderField('message') && (
            <div>
              <Label htmlFor="message">{fieldConfig.message.label}</Label>
              <Textarea
                id="message"
                name="message"
                value={formData.message}
                onChange={handleInputChange}
                rows={4}
                required
              />
            </div>
          )}

          <Button type="submit" className="w-full">
            {buttonText}
          </Button>
        </form>
      ) : (
        <div className="flex flex-col items-center justify-center py-8 text-center">
          <CheckCircle2 className="w-12 h-12 mb-2 text-green-500" />
          <h3 className={`${getFontClasses('heading', customizations)} text-lg font-medium`}>
            Message Sent!
          </h3>
          <p className={`${getFontClasses('body', customizations)} text-muted-foreground mt-1`}>
            Thanks for reaching out. I&apos;ll get back to you soon.
          </p>
        </div>
      )}

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Contact Form Settings</h3>
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span>Show Title</span>
              <Switch
                checked={showTitle}
                onCheckedChange={(checked) => onUpdate?.({ showTitle: checked })}
              />
            </div>

            {showTitle && (
              <div>
                <Label htmlFor="titleText">Title Text</Label>
                <Input
                  id="titleText"
                  value={titleText}
                  onChange={(e) => onUpdate?.({ titleText: e.target.value })}
                />
              </div>
            )}

            <div>
              <Label htmlFor="buttonText">Button Text</Label>
              <Input
                id="buttonText"
                value={buttonText}
                onChange={(e) => onUpdate?.({ buttonText: e.target.value })}
              />
            </div>

            <div>
              <Label className="block mb-1 text-sm">Form Fields</Label>
              <div className="space-y-2">
                {(Object.keys(fieldConfig) as Array<keyof typeof fieldConfig>).map((field) => (
                  <div key={field} className="flex items-center justify-between">
                    <span>{fieldConfig[field].label}</span>
                    <Switch
                      checked={fields.includes(field)}
                      onCheckedChange={(checked) => {
                        const newFields = checked
                          ? [...fields, field]
                          : fields.filter((f) => f !== field)
                        onUpdate?.({
                          fields: newFields as Array<'name' | 'email' | 'message' | 'phone'>,
                        })
                      }}
                    />
                  </div>
                ))}
              </div>
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/donation-component.tsx
================================================
'use client'

import React, { useState } from 'react'
import { DonationComponentSettings } from '@/types/template'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import { getFontClasses, getButtonClasses } from '@/lib/template-mappings'
import { getLinkButtonClasses } from '@/lib/theme-mappings'
import { Heart } from 'lucide-react'
import { useAction } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { ProfileComplete } from '@/types/profile'

interface DonationComponentProps {
  settings: DonationComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<DonationComponentSettings>) => void
}

export function DonationComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: DonationComponentProps) {
  const {
    showButton = true,
    buttonText = 'Support Me',
    description,
    showSuggestedAmounts = true,
    suggestedAmounts = [5, 10, 20],
  } = settings

  const [amount, setAmount] = useState<number>(suggestedAmounts[1] || 10)
  const [isCustomAmount, setIsCustomAmount] = useState(false)
  const [isDonationOpen, setIsDonationOpen] = useState(false)

  // Get theme settings and ensure they are properly typed
  const customizations = profile.template.customizations

  // Stripe checkout action
  const createCheckoutSession = useAction(api.payments.createDonationCheckoutSession)

  const handleDonate = async () => {
    if (!amount || amount <= 0) return

    try {
      const result = await createCheckoutSession({
        profileId: profile._id,
        amount: amount * 100, // Convert to cents
        email: '', // Email is required by the action but will be filled in checkout
      })

      if (result.checkoutUrl) {
        window.location.href = result.checkoutUrl
      }
    } catch (error) {
      console.error('Error creating checkout session:', error)
    }
  }

  const handleSuggestedAmountClick = (amount: number) => {
    setAmount(amount)
    setIsCustomAmount(false)
  }

  if (!profile.hasStripeConnected && !editable) {
    return null
  }

  return (
    <div>
      {!isDonationOpen ? (
        showButton && (
          <div className="text-center">
            <Button
              className={`${getButtonClasses(customizations)} ${getLinkButtonClasses(profile.theme.settings, 'filled')}`}
              onClick={() => setIsDonationOpen(true)}
            >
              <Heart className="w-4 h-4 mr-2" />
              {buttonText}
            </Button>
          </div>
        )
      ) : (
        <Card className="p-4">
          <div className="space-y-4">
            <div className="text-center">
              <h3 className={`${getFontClasses('heading', customizations)} text-lg font-medium`}>
                Support {profile.handle}
              </h3>

              {description && (
                <p
                  className={`${getFontClasses('body', customizations)} text-sm text-muted-foreground mt-1`}
                >
                  {description}
                </p>
              )}
            </div>

            {showSuggestedAmounts && (
              <div className="flex flex-wrap justify-center gap-2">
                {suggestedAmounts.map((amt) => (
                  <Button
                    key={amt}
                    type="button"
                    variant={amount === amt && !isCustomAmount ? 'default' : 'outline'}
                    className="min-w-[50px]"
                    onClick={() => handleSuggestedAmountClick(amt)}
                  >
                    ${amt}
                  </Button>
                ))}
                <Button
                  type="button"
                  variant={isCustomAmount ? 'default' : 'outline'}
                  onClick={() => setIsCustomAmount(true)}
                >
                  Custom
                </Button>
              </div>
            )}

            {isCustomAmount && (
              <div>
                <Label htmlFor="customAmount">Custom amount ($)</Label>
                <Input
                  id="customAmount"
                  type="number"
                  min="1"
                  step="1"
                  value={amount}
                  onChange={(e) => setAmount(Number(e.target.value))}
                />
              </div>
            )}

            <div className="flex gap-2">
              <Button className="flex-1" variant="outline" onClick={() => setIsDonationOpen(false)}>
                Cancel
              </Button>
              <Button className="flex-1" onClick={handleDonate} disabled={!amount || amount <= 0}>
                Donate ${amount}
              </Button>
            </div>
          </div>
        </Card>
      )}

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Donation Settings</h3>
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span>Show Button</span>
              <Switch
                checked={showButton}
                onCheckedChange={(checked) => onUpdate?.({ showButton: checked })}
              />
            </div>

            <div>
              <Label htmlFor="buttonText">Button Text</Label>
              <Input
                id="buttonText"
                value={buttonText}
                onChange={(e) => onUpdate?.({ buttonText: e.target.value })}
              />
            </div>

            <div>
              <Label htmlFor="description">Description (optional)</Label>
              <Input
                id="description"
                value={description || ''}
                onChange={(e) => onUpdate?.({ description: e.target.value })}
              />
            </div>

            <div className="flex items-center justify-between">
              <span>Show Suggested Amounts</span>
              <Switch
                checked={showSuggestedAmounts}
                onCheckedChange={(checked) => onUpdate?.({ showSuggestedAmounts: checked })}
              />
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/gallery-component.tsx
================================================
'use client'

import React from 'react'
import Image from 'next/image'
import { GalleryComponentSettings } from '@/types/template'
import { Card } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Switch } from '@/components/ui/switch'
import { getFontClasses } from '@/lib/template-mappings'
import { ProfileComplete } from '@/types/profile'

interface GalleryComponentProps {
  settings: GalleryComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<GalleryComponentSettings>) => void
}

export function GalleryComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: GalleryComponentProps) {
  const { layout = 'grid', itemsPerRow = 3, showCaptions = true, aspectRatio = 'square' } = settings

  // Mock gallery items - in a real app, these would come from the database
  const mockGalleryItems = [
    {
      id: '1',
      title: 'Image 1',
      imageUrl: 'https://images.unsplash.com/photo-1605379399642-870262d3d051',
    },
    {
      id: '2',
      title: 'Image 2',
      imageUrl: 'https://images.unsplash.com/photo-1556740749-887f6717d7e4',
    },
    {
      id: '3',
      title: 'Image 3',
      imageUrl: 'https://images.unsplash.com/photo-1572177812156-58036aae439c',
    },
    {
      id: '4',
      title: 'Image 4',
      imageUrl: 'https://images.unsplash.com/photo-1526628953301-3e589a6a8b74',
    },
  ]

  // Get customizations
  const customizations = profile.template?.customizations

  // Get container classes based on layout and items per row
  const getContainerClasses = () => {
    if (layout === 'carousel') {
      return 'flex overflow-x-auto space-x-4 pb-4 snap-x'
    } else if (layout === 'masonry') {
      return 'columns-1 sm:columns-2 md:columns-3 gap-4 space-y-4'
    } else {
      // Grid layout
      const cols = {
        1: 'grid-cols-1',
        2: 'grid-cols-1 sm:grid-cols-2',
        3: 'grid-cols-1 sm:grid-cols-2 md:grid-cols-3',
        4: 'grid-cols-2 sm:grid-cols-3 md:grid-cols-4',
      }
      return `grid ${cols[itemsPerRow as keyof typeof cols]} gap-4`
    }
  }

  // Get item classes based on layout
  const getItemClasses = () => {
    if (layout === 'carousel') {
      return 'flex-shrink-0 w-60 sm:w-80 snap-center'
    } else if (layout === 'masonry') {
      return 'mb-4 break-inside-avoid'
    }
    return ''
  }

  // Get aspect ratio classes
  const getAspectRatioClass = () => {
    switch (aspectRatio) {
      case 'landscape':
        return 'aspect-video'
      case 'portrait':
        return 'aspect-[3/4]'
      case 'original':
        return 'aspect-auto'
      default:
        return 'aspect-square'
    }
  }

  return (
    <div>
      <div className={getContainerClasses()}>
        {mockGalleryItems.map((item) => (
          <div key={item.id} className={getItemClasses()}>
            <div
              className={`relative ${getAspectRatioClass()} bg-muted rounded-md overflow-hidden`}
            >
              <Image
                src={item.imageUrl}
                alt={item.title}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                className="object-cover"
              />
            </div>

            {showCaptions && (
              <p className={`${getFontClasses('body', customizations)} text-sm mt-1`}>
                {item.title}
              </p>
            )}
          </div>
        ))}
      </div>

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Gallery Settings</h3>
          <div className="space-y-3">
            <div>
              <label className="block mb-1 text-sm">Layout</label>
              <Select
                value={layout}
                onValueChange={(value: 'grid' | 'carousel' | 'masonry') =>
                  onUpdate?.({ layout: value })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select layout" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="grid">Grid</SelectItem>
                  <SelectItem value="carousel">Carousel</SelectItem>
                  <SelectItem value="masonry">Masonry</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {layout === 'grid' && (
              <div>
                <label className="block mb-1 text-sm">Items Per Row</label>
                <Select
                  value={itemsPerRow.toString()}
                  onValueChange={(value) =>
                    onUpdate?.({ itemsPerRow: parseInt(value) as 1 | 2 | 3 | 4 })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select count" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="1">1</SelectItem>
                    <SelectItem value="2">2</SelectItem>
                    <SelectItem value="3">3</SelectItem>
                    <SelectItem value="4">4</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}

            <div className="flex items-center justify-between">
              <span>Show Captions</span>
              <Switch
                checked={showCaptions}
                onCheckedChange={(checked) => onUpdate?.({ showCaptions: checked })}
              />
            </div>

            <div>
              <label className="block mb-1 text-sm">Image Aspect Ratio</label>
              <Select
                value={aspectRatio}
                onValueChange={(value: 'square' | 'landscape' | 'portrait' | 'original') =>
                  onUpdate?.({ aspectRatio: value })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select aspect ratio" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="square">Square (1:1)</SelectItem>
                  <SelectItem value="landscape">Landscape (16:9)</SelectItem>
                  <SelectItem value="portrait">Portrait (3:4)</SelectItem>
                  <SelectItem value="original">Original</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/header-component.tsx
================================================
'use client'

import React from 'react'
import Image from 'next/image'
import { UserIcon, PencilIcon } from 'lucide-react'
import { Badge } from '@/components/ui/badge'
import { Switch } from '@/components/ui/switch'
import { Card } from '@/components/ui/card'
import { getFontClasses } from '@/lib/template-mappings'
import { HeaderComponentSettings } from '@/types/template'
import { ProfileComplete } from '@/types/profile'

interface HeaderComponentProps {
  settings: HeaderComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<HeaderComponentSettings>) => void
}

export function HeaderComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: HeaderComponentProps) {
  const {
    showAvatar = true,
    avatarSize = 'medium',
    showBio = true,
    alignment = 'center',
    // showSocial = true,
  } = settings

  // Derive classes based on theme and template customizations
  const theme = profile.theme.settings
  const customizations = profile.template?.customizations

  // Get size classes for avatar
  const getAvatarSizeClass = () => {
    switch (avatarSize) {
      case 'small':
        return 'w-16 h-16'
      case 'large':
        return 'w-32 h-32'
      default:
        return 'w-24 h-24' // medium
    }
  }

  // Get alignment classes
  const getAlignmentClass = () => {
    switch (alignment) {
      case 'left':
        return 'items-start text-left'
      case 'right':
        return 'items-end text-right'
      default:
        return 'items-center text-center'
    }
  }

  return (
    <div className={`flex flex-col ${getAlignmentClass()} space-y-3`}>
      {/* Avatar */}
      {showAvatar && (
        <div className="relative">
          {profile.avatarUrl ? (
            <Image
              src={profile.avatarUrl}
              alt={profile.handle}
              width={avatarSize === 'small' ? 64 : avatarSize === 'large' ? 128 : 96}
              height={avatarSize === 'small' ? 64 : avatarSize === 'large' ? 128 : 96}
              className={`${getAvatarSizeClass()} rounded-full object-cover border-4 ${getBorderColorClass(theme.color)}`}
            />
          ) : (
            <div
              className={`${getAvatarSizeClass()} rounded-full bg-muted flex items-center justify-center`}
            >
              <UserIcon className="w-1/2 h-1/2 text-muted-foreground" />
            </div>
          )}

          {/* Edit button shown only in editable mode */}
          {editable && (
            <button
              className="absolute bottom-0 right-0 p-1 text-white rounded-full bg-primary"
              onClick={() => {
                // Implement avatar upload logic
              }}
            >
              <PencilIcon className="w-4 h-4" />
            </button>
          )}
        </div>
      )}

      {/* Handle */}
      <h1
        className={`${getFontClasses('heading', customizations)} ${avatarSize === 'large' ? 'text-2xl' : 'text-xl'}`}
      >
        {profile.handle}
      </h1>

      {/* Bio */}
      {showBio && profile.bio && (
        <p className={`${getFontClasses('body', customizations)} text-muted-foreground max-w-md`}>
          {profile.bio}
        </p>
      )}

      {/* Badge with link */}
      <Badge variant="outline" className={`${getBadgeClass(theme.color)}`}>
        @{profile.handle}
      </Badge>

      {/* Editable controls */}
      {editable && (
        <Card className="w-full p-3 mt-4">
          <h3 className="mb-2 font-medium">Header Settings</h3>
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <span>Show Avatar</span>
              <Switch
                checked={showAvatar}
                onCheckedChange={(checked) => onUpdate?.({ showAvatar: checked })}
              />
            </div>
            <div className="flex items-center justify-between">
              <span>Show Bio</span>
              <Switch
                checked={showBio}
                onCheckedChange={(checked) => onUpdate?.({ showBio: checked })}
              />
            </div>
            {/* Add more controls for other settings */}
          </div>
        </Card>
      )}
    </div>
  )
}

// Helper functions for theme-specific classes
function getBorderColorClass(color: string): string {
  switch (color) {
    case 'blue':
      return 'border-blue-200'
    case 'purple':
      return 'border-purple-200'
    case 'green':
      return 'border-green-200'
    case 'pink':
      return 'border-pink-200'
    case 'orange':
      return 'border-orange-200'
    default:
      return 'border-indigo-200'
  }
}

function getBadgeClass(color: string): string {
  switch (color) {
    case 'blue':
      return 'bg-blue-100 text-blue-800'
    case 'purple':
      return 'bg-purple-100 text-purple-800'
    case 'green':
      return 'bg-green-100 text-green-800'
    case 'pink':
      return 'bg-pink-100 text-pink-800'
    case 'orange':
      return 'bg-orange-100 text-orange-800'
    default:
      return 'bg-indigo-100 text-indigo-800'
  }
}



================================================
FILE: components/templates/components/items-component.tsx
================================================
'use client'

import React from 'react'
import { ItemsComponentSettings } from '@/types/template'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Switch } from '@/components/ui/switch'
import { Package, ShoppingCart, ExternalLink } from 'lucide-react'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { getFontClasses } from '@/lib/template-mappings'
import { Doc } from '@/convex/_generated/dataModel'
import { ProfileComplete } from '@/types/profile'

interface ItemsComponentProps {
  settings: ItemsComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<ItemsComponentSettings>) => void
}

export function ItemsComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: ItemsComponentProps) {
  const { layout = 'grid', itemsPerRow = 2, showPrices = true, showDescriptions = true } = settings

  // Fetch items for this profile
  const items = useQuery(api.items.list, { profileId: profile._id }) || []

  // Get customizations
  const customizations = profile.template?.customizations

  // Get container classes based on layout and items per row
  const getContainerClasses = () => {
    if (layout === 'carousel') {
      return 'flex overflow-x-auto space-x-4 pb-4 snap-x'
    } else if (layout === 'list') {
      return 'flex flex-col space-y-4'
    } else {
      // Grid layout
      const cols = {
        1: 'grid-cols-1',
        2: 'grid-cols-1 sm:grid-cols-2',
        3: 'grid-cols-1 sm:grid-cols-2 md:grid-cols-3',
      }
      return `grid ${cols[itemsPerRow as keyof typeof cols]} gap-4`
    }
  }

  // Get item classes based on layout
  const getItemClasses = () => {
    if (layout === 'carousel') {
      return 'flex-shrink-0 w-60 sm:w-80 snap-center'
    }
    return ''
  }

  // Format price
  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(price / 100)
  }

  // Get button or price tag based on item type
  const getItemAction = (item: Doc<'items'>) => {
    if (item.type.kind === 'paid') {
      return (
        <Button size="sm" className="w-full">
          <ShoppingCart className="w-4 h-4 mr-2" />
          {showPrices ? `Buy (${formatPrice(item.type.price)})` : 'Buy Now'}
        </Button>
      )
    } else if (item.type.kind === 'free') {
      return (
        <Button size="sm" variant="outline" className="w-full">
          <Package className="w-4 h-4 mr-2" />
          Download Free
        </Button>
      )
    } else if (item.type.kind === 'link') {
      return (
        <Button size="sm" variant="secondary" className="w-full">
          <ExternalLink className="w-4 h-4 mr-2" />
          Visit Link
        </Button>
      )
    }
  }

  return (
    <div>
      {items.length > 0 ? (
        <div className={getContainerClasses()}>
          {items.map((item) => (
            <Card key={item._id} className={getItemClasses()}>
              <CardHeader className="p-4 pb-0">
                <CardTitle className={`${getFontClasses('heading', customizations)} text-lg`}>
                  {item.title}
                </CardTitle>

                {item.type.kind === 'paid' && showPrices && (
                  <Badge className="mt-2">{formatPrice(item.type.price)}</Badge>
                )}
              </CardHeader>

              <CardContent className="p-4">
                {showDescriptions && (
                  <p
                    className={`${getFontClasses('body', customizations)} text-sm text-muted-foreground`}
                  >
                    {item.description}
                  </p>
                )}
              </CardContent>

              <CardFooter className="p-4 pt-0">{getItemAction(item)}</CardFooter>
            </Card>
          ))}
        </div>
      ) : (
        <div className="p-8 text-center border border-dashed rounded-md text-muted-foreground">
          <Package className="w-12 h-12 mx-auto mb-2 opacity-50" />
          <p>No items added yet</p>
        </div>
      )}

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Items Settings</h3>
          <div className="space-y-3">
            <div>
              <label className="block mb-1 text-sm">Layout</label>
              <Select
                value={layout}
                onValueChange={(value: 'grid' | 'list' | 'carousel') =>
                  onUpdate?.({ layout: value })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select layout" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="grid">Grid</SelectItem>
                  <SelectItem value="list">List</SelectItem>
                  <SelectItem value="carousel">Carousel</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {layout === 'grid' && (
              <div>
                <label className="block mb-1 text-sm">Items Per Row</label>
                <Select
                  value={itemsPerRow.toString()}
                  onValueChange={(value) =>
                    onUpdate?.({ itemsPerRow: parseInt(value) as 1 | 2 | 3 })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select count" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="1">1</SelectItem>
                    <SelectItem value="2">2</SelectItem>
                    <SelectItem value="3">3</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}

            <div className="flex items-center justify-between">
              <span>Show Prices</span>
              <Switch
                checked={showPrices}
                onCheckedChange={(checked) => onUpdate?.({ showPrices: checked })}
              />
            </div>

            <div className="flex items-center justify-between">
              <span>Show Descriptions</span>
              <Switch
                checked={showDescriptions}
                onCheckedChange={(checked) => onUpdate?.({ showDescriptions: checked })}
              />
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/links-component.tsx
================================================
'use client'

import React from 'react'
import { LinksComponentSettings } from '@/types/template'
import { getLinkButtonClasses } from '@/lib/theme-mappings'
import { getThemeSettings } from '@/lib/theme-defaults'
import { Card } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Switch } from '@/components/ui/switch'
import { Link2, ExternalLink } from 'lucide-react'
import { useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { ProfileComplete } from '@/types/profile'

interface LinksComponentProps {
  settings: LinksComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<LinksComponentSettings>) => void
}

export function LinksComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: LinksComponentProps) {
  const { layout = 'list', buttonStyle = 'filled', showIcons = true, animation = 'none' } = settings

  // Fetch links for this profile
  const links = useQuery(api.links.list, { profileId: profile._id }) || []

  // Get theme settings
  const theme = getThemeSettings(profile.theme)
  const customizations = profile.template?.customizations

  // Get container classes based on layout
  const getContainerClasses = () => {
    if (layout === 'grid') {
      return 'grid grid-cols-2 gap-3'
    }
    return 'flex flex-col space-y-3'
  }

  // Get animation classes
  const getAnimationClasses = () => {
    switch (animation) {
      case 'fade':
        return 'transition-opacity hover:opacity-90'
      case 'slide':
        return 'transition-transform hover:-translate-y-1'
      case 'bounce':
        return 'transition-transform hover:scale-105 active:scale-95'
      default:
        return ''
    }
  }

  return (
    <div>
      <div className={getContainerClasses()}>
        {links.map((link) => (
          <a
            key={link._id}
            href={link.url}
            target="_blank"
            rel="noopener noreferrer"
            className={`${getLinkButtonClasses(theme, buttonStyle, customizations)} ${getAnimationClasses()}`}
          >
            {showIcons && (
              <span className="inline-flex items-center">
                <ExternalLink className="w-4 h-4 mr-2" />
              </span>
            )}
            {link.title}
          </a>
        ))}
      </div>

      {/* No links message */}
      {links.length === 0 && (
        <div className="p-4 text-center border border-dashed rounded-md text-muted-foreground">
          <Link2 className="w-8 h-8 mx-auto mb-2 opacity-50" />
          <p>No links added yet</p>
        </div>
      )}

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Links Settings</h3>
          <div className="space-y-3">
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="block mb-1 text-sm">Layout</label>
                <Select
                  value={layout}
                  onValueChange={(value) =>
                    onUpdate?.({ layout: value as LinksComponentSettings['layout'] })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Layout" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="list">List</SelectItem>
                    <SelectItem value="grid">Grid</SelectItem>
                    <SelectItem value="compact">Compact</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <label className="block mb-1 text-sm">Button Style</label>
                <Select
                  value={buttonStyle}
                  onValueChange={(value) =>
                    onUpdate?.({ buttonStyle: value as LinksComponentSettings['buttonStyle'] })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Button Style" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="filled">Filled</SelectItem>
                    <SelectItem value="outlined">Outlined</SelectItem>
                    <SelectItem value="subtle">Subtle</SelectItem>
                    <SelectItem value="text">Text Only</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>

            <div className="flex items-center justify-between">
              <span>Show Icons</span>
              <Switch
                checked={showIcons}
                onCheckedChange={(checked) => onUpdate?.({ showIcons: checked })}
              />
            </div>

            <div>
              <label className="block mb-1 text-sm">Animation</label>
              <Select
                value={animation}
                onValueChange={(value) =>
                  onUpdate?.({ animation: value as LinksComponentSettings['animation'] })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Animation" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">None</SelectItem>
                  <SelectItem value="fade">Fade</SelectItem>
                  <SelectItem value="slide">Slide</SelectItem>
                  <SelectItem value="bounce">Bounce</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/templates/components/social-component.tsx
================================================
'use client'

import React from 'react'
import { SocialComponentSettings } from '@/types/template'
import { Card } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Switch } from '@/components/ui/switch'
import { Instagram, Twitter, Facebook, Linkedin } from 'lucide-react'
import { getFontClasses } from '@/lib/template-mappings'
import { ProfileComplete } from '@/types/profile'

interface SocialComponentProps {
  settings: SocialComponentSettings
  profile: ProfileComplete
  editable?: boolean
  onUpdate?: (settings: Partial<SocialComponentSettings>) => void
}

export function SocialComponent({
  settings,
  profile,
  editable = false,
  onUpdate,
}: SocialComponentProps) {
  const { layout = 'horizontal', showLabels = false, iconSize = 'medium' } = settings

  // Mock social media accounts - in a real app, these would come from the database
  const socialAccounts = [
    { type: 'instagram', url: 'https://instagram.com/' + profile.handle, icon: Instagram },
    { type: 'twitter', url: 'https://twitter.com/' + profile.handle, icon: Twitter },
    { type: 'facebook', url: 'https://facebook.com/' + profile.handle, icon: Facebook },
    { type: 'linkedin', url: 'https://linkedin.com/in/' + profile.handle, icon: Linkedin },
  ]

  // Get customizations
  const customizations = profile.template?.customizations

  // Get container classes based on layout
  const getContainerClasses = () => {
    if (layout === 'grid') {
      return 'grid grid-cols-2 sm:grid-cols-4 gap-2'
    } else if (layout === 'vertical') {
      return 'flex flex-col space-y-2'
    }
    return 'flex flex-wrap justify-center gap-4'
  }

  // Get icon size classes
  const getIconSizeClass = () => {
    switch (iconSize) {
      case 'small':
        return 'w-4 h-4'
      case 'large':
        return 'w-8 h-8'
      default:
        return 'w-6 h-6'
    }
  }

  // Get link classes
  const getLinkClasses = () => {
    const baseClasses =
      'flex items-center gap-2 text-muted-foreground hover:text-foreground transition-colors'

    if (layout === 'vertical') {
      return `${baseClasses} justify-start`
    } else if (layout === 'grid') {
      return `${baseClasses} flex-col justify-center p-2 border rounded-md`
    }

    return baseClasses
  }

  return (
    <div>
      <div className={getContainerClasses()}>
        {socialAccounts.map((social) => (
          <a
            key={social.type}
            href={social.url}
            target="_blank"
            rel="noopener noreferrer"
            className={getLinkClasses()}
          >
            <social.icon className={getIconSizeClass()} />
            {showLabels && (
              <span className={getFontClasses('body', customizations)}>
                {social.type.charAt(0).toUpperCase() + social.type.slice(1)}
              </span>
            )}
          </a>
        ))}
      </div>

      {/* Edit controls */}
      {editable && (
        <Card className="p-3 mt-4">
          <h3 className="mb-2 font-medium">Social Media Settings</h3>
          <div className="space-y-3">
            <div>
              <label className="block mb-1 text-sm">Layout</label>
              <Select
                value={layout}
                onValueChange={(value: 'horizontal' | 'vertical' | 'grid') =>
                  onUpdate?.({ layout: value })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select layout" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="horizontal">Horizontal</SelectItem>
                  <SelectItem value="vertical">Vertical</SelectItem>
                  <SelectItem value="grid">Grid</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="flex items-center justify-between">
              <span>Show Labels</span>
              <Switch
                checked={showLabels}
                onCheckedChange={(checked) => onUpdate?.({ showLabels: checked })}
              />
            </div>

            <div>
              <label className="block mb-1 text-sm">Icon Size</label>
              <Select
                value={iconSize}
                onValueChange={(value: 'small' | 'medium' | 'large') =>
                  onUpdate?.({ iconSize: value })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select size" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="small">Small</SelectItem>
                  <SelectItem value="medium">Medium</SelectItem>
                  <SelectItem value="large">Large</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </Card>
      )}
    </div>
  )
}



================================================
FILE: components/ui/accordion.tsx
================================================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



================================================
FILE: components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
        warning:
          "border-orange-500/50 text-orange-600 dark:border-orange-500 [&>svg]:text-orange-600",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


================================================
FILE: components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: components/ui/badge.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }


================================================
FILE: components/ui/button.tsx
================================================
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

const buttonVariants = cva(
  `inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-[10px] text-sm font-medium transition-all disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none cursor-pointer hover:translate-y-[1px] hover:scale-[0.98] active:translate-y-[2px] active:scale-[0.97] disabled:shadow-none disabled:hover:translate-y-0 disabled:hover:scale-100`,
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground hover:bg-primary/90 disabled:bg-muted disabled:text-muted-foreground disabled:hover:bg-muted [box-shadow:_0_1px_2px_hsl(0,_0%,_38%),_0_3px_3px_hsl(0,0%,82%),_0_-2px_rgba(0,0,0,0.05)_inset] hover:[box-shadow:_0_1px_2px_hsl(0,_0%,_38%)]',
        destructive:
          'bg-destructive text-destructive-foreground hover:bg-destructive/90 disabled:bg-muted disabled:text-muted-foreground disabled:hover:bg-muted [box-shadow:_0_1px_2px_hsl(0,_40%,_38%),_0_3px_3px_hsl(0,40%,82%),_0_-2px_rgba(0,0,0,0.05)_inset] hover:[box-shadow:_0_1px_2px_hsl(0,_40%,_38%)]',
        outline:
          'border border-border bg-background text-foreground hover:bg-accent hover:text-accent-foreground  disabled:bg-muted disabled:text-muted-foreground disabled:hover:bg-muted dark:bg-input/30 dark:border-input dark:hover:bg-input/50 [box-shadow:_0_1px_2px_hsl(0,_0%,_88%),_0_3px_3px_hsl(0,0%,82%),_0_-2px_rgba(0,0,0,0.05)_inset] hover:[box-shadow:_0_1px_1px_hsl(0,_0%,_88%)]',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80  disabled:bg-muted disabled:text-muted-foreground disabled:hover:bg-muted [box-shadow:_0_1px_2px_hsl(0,_0%,_38%),_0_3px_3px_hsl(0,0%,82%),_0_-2px_rgba(0,0,0,0.05)_inset] hover:[box-shadow:_0_1px_2px_hsl(0,_0%,_38%)]',
        ghost: 'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 px-8 has-[>svg]:px-4',
        huge: 'h-16 px-8 has-[>svg]:pr-7 text-base',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: components/ui/card.tsx
================================================
import * as React from 'react'

import { cn } from '@/lib/utils'

function Card({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card"
      className={cn(
        'bg-card text-card-foreground flex flex-col gap-6 rounded-md border border-border py-6',
        className,
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        '@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6',
        className,
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-title"
      className={cn('leading-none font-semibold', className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-action"
      className={cn('col-start-2 row-span-2 row-start-1 self-start justify-self-end', className)}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-content" className={cn('px-6', className)} {...props} />
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-footer"
      className={cn('flex items-center px-6 [.border-t]:pt-6', className)}
      {...props}
    />
  )
}

export { Card, CardHeader, CardFooter, CardTitle, CardAction, CardDescription, CardContent }



================================================
FILE: components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }



================================================
FILE: components/ui/dialog.tsx
================================================
'use client'

import * as React from 'react'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { XIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({ ...props }: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className,
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border border-border p-6 shadow-lg duration-200 sm:max-w-lg',
          className,
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn('flex flex-col-reverse gap-2 sm:flex-row sm:justify-end', className)}
      {...props}
    />
  )
}

function DialogTitle({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: components/ui/dropdown-menu.tsx
================================================
'use client'

import * as React from 'react'
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function DropdownMenu({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      className="cursor-pointer"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border border-border p-1 shadow-md',
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
}

function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-pointer items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-pointer items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return <DropdownMenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} />
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-pointer items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn('px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)}
      {...props}
    />
  )
}

function DropdownMenuSub({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-pointer items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8',
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border border-border p-1 shadow-lg',
        className,
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: components/ui/input.tsx
================================================
import * as React from 'react'

import { cn } from '@/lib/utils'

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/10 focus-visible:ring-1',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className,
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: components/ui/label.tsx
================================================
'use client'

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'

import { cn } from '@/lib/utils'

function Label({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        'flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50',
        className,
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: components/ui/progress.tsx
================================================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }



================================================
FILE: components/ui/radio-group.tsx
================================================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }



================================================
FILE: components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: components/ui/select.tsx
================================================
'use client'

import * as React from 'react'
import * as SelectPrimitive from '@radix-ui/react-select'
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({ ...props }: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = 'default',
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: 'sm' | 'default'
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = 'popper',
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md',
          position === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            'p-1',
            position === 'popper' &&
              'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1',
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn('text-muted-foreground px-2 py-1.5 text-xs', className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-pointer items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className,
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn('bg-border pointer-events-none -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn('flex cursor-pointer items-center justify-center py-1', className)}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn('flex cursor-pointer items-center justify-center py-1', className)}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: components/ui/slider.tsx
================================================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }



================================================
FILE: components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: components/ui/switch.tsx
================================================
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }



================================================
FILE: components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: convex/auth.config.ts
================================================
const authConfig = {
  providers: [
    {
      domain: process.env.CONVEX_SITE_URL,
      applicationID: "convex",
    },
  ],
};

export default authConfig;



================================================
FILE: convex/auth.ts
================================================
import { convexAuth, getAuthUserId } from "@convex-dev/auth/server";
import Resend from "@auth/core/providers/resend";
import Google from "@auth/core/providers/google";
import { Password } from "@convex-dev/auth/providers/Password";
import { query, internalQuery } from "./_generated/server";
import { v } from "convex/values";
import { Doc } from "./_generated/dataModel";

export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({
  providers: [Password, Google, Resend],
});

export const loggedInUser = query({
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }
    const user = await ctx.db.get(userId);
    if (!user) {
      return null;
    }
    return user;
  },
});

// Get a user by their ID
export const getUserById = internalQuery({
  args: { userId: v.id("users") },
  returns: v.union(
    v.object({
      _id: v.id("users"),
      _creationTime: v.number(),
      name: v.optional(v.string()),
      email: v.optional(v.string()),
      emailVerificationTime: v.optional(v.float64()),
      image: v.optional(v.string()),
    }),
    v.null()
  ),
  handler: async (ctx, { userId }) => {
    const user = await ctx.db.get(userId);
    return user as (Doc<"users"> | null);
  },
});



================================================
FILE: convex/files.ts
================================================
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getUrl = query({
  args: { storageId: v.id("_storage") },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId);
  },
});


================================================
FILE: convex/http.ts
================================================
import { auth } from "./auth";
import router from "./router";

const http = router;

auth.addHttpRoutes(http);

export default http;



================================================
FILE: convex/items.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";
import { Id } from "./_generated/dataModel";
import { canCreateItem } from "./helpers/subscriptions/limitHelpers";

export const list = query({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("items")
      .withIndex("by_profile", (q) => q.eq("profileId", args.profileId))
      .collect();
  },
});

export const add = mutation({
  args: {
    profileId: v.id("profiles"),
    title: v.string(),
    description: v.string(),
    type: v.union(
      v.object({ kind: v.literal("paid"), price: v.number(), fileId: v.id("_storage") }),
      v.object({ kind: v.literal("free"), fileId: v.id("_storage") }),
      v.object({ kind: v.literal("link"), url: v.string() })
    ),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const profile = await ctx.db.get(args.profileId);
    if (!profile || profile.userId !== userId) throw new Error("Unauthorized");

    // Check if user has reached their item limit for this profile
    const itemLimitCheck = await canCreateItem(ctx.db, args.profileId, userId);
    if (!itemLimitCheck.allowed) {
      throw new Error(`Item limit reached: You can create up to ${itemLimitCheck.limit} items per profile on your current plan. This profile currently has ${itemLimitCheck.current} items.`);
    }

    await ctx.db.insert("items", {
      profileId: args.profileId,
      title: args.title,
      description: args.description,
      type: args.type,
    });
  },
});

export const remove = mutation({
  args: { itemId: v.id("items") },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const item = await ctx.db.get(args.itemId);
    if (!item) {
      throw new Error("Item not found");
    }

    const profile = await ctx.db.get(item.profileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Unauthorized");
    }

    await ctx.db.delete(args.itemId);
  },
});

export const generateUploadUrl = mutation({
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    return await ctx.storage.generateUploadUrl();
  },
});

export const requestDownload = mutation({
  args: {
    itemId: v.id("items"),
    email: v.string(),
  },
  handler: async (ctx, args) => {
    const item = await ctx.db.get(args.itemId);
    if (!item) throw new Error("Item not found");

    if (item.type.kind === "link") {
      throw new Error("Link items don't have downloadable files");
    }

    const fileId = item.type.fileId as Id<'_storage'>;
    const downloadUrl = await ctx.storage.getUrl(fileId);
    if (!downloadUrl) throw new Error("File not found");

    const profile = await ctx.db.get(item.profileId);
    if (!profile) throw new Error("Profile not found");

    if (item.type.kind === "paid") {
      await ctx.db.insert("purchases", {
        userId: profile.userId,
        itemId: args.itemId,
        email: args.email,
        downloadUrl,
      });
    } else if (item.type.kind === "free") {
      await ctx.db.insert("leads", {
        userId: profile.userId,
        itemId: args.itemId,
        email: args.email,
      });
    }

    return { success: true };
  },
});



================================================
FILE: convex/links.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";
import { canCreateLink } from "./helpers/subscriptions/limitHelpers";

export const list = query({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("links")
      .withIndex("by_profile", (q) => q.eq("profileId", args.profileId))
      .collect();
  },
});

export const add = mutation({
  args: {
    profileId: v.id("profiles"),
    title: v.string(),
    url: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const profile = await ctx.db.get(args.profileId);
    if (!profile || profile.userId !== userId) throw new Error("Unauthorized");

    // Check if user has reached their link limit for this profile
    const linkLimitCheck = await canCreateLink(ctx.db, args.profileId, userId);
    if (!linkLimitCheck.allowed) {
      throw new Error(`Link limit reached: You can create up to ${linkLimitCheck.limit} links per profile on your current plan. This profile currently has ${linkLimitCheck.current} links.`);
    }

    await ctx.db.insert("links", {
      profileId: args.profileId,
      title: args.title,
      url: args.url,
    });
  },
});

export const remove = mutation({
  args: { linkId: v.id("links") },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const link = await ctx.db.get(args.linkId);
    if (!link) {
      throw new Error("Link not found");
    }

    const profile = await ctx.db.get(link.profileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Unauthorized");
    }

    await ctx.db.delete(args.linkId);
  },
});



================================================
FILE: convex/payments.ts
================================================
import { v } from "convex/values";
import { action, ActionCtx, internalMutation, query } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";
import { ConvexError } from "convex/values";
import { stripe } from "./lib/stripe";
import { api, internal } from "./_generated/api";
import { BASE_URL } from "./helpers/common/url";
import Stripe from "stripe";
import { Id } from "./_generated/dataModel";

export const create = internalMutation({
  args: {
    userId: v.id("users"),
    amount: v.number(),
    status: v.union(
      v.literal("created"),
      v.literal("pending"),
      v.literal("completed"),
      v.literal("failed")
    ),
    stripeSessionId: v.string(),
    createdAt: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("payments", args);
  },
});

export const markPending = internalMutation({
  args: { paymentId: v.id("payments"), stripeId: v.string() },
  handler: async (ctx, { paymentId, stripeId }) => {
    await ctx.db.patch(paymentId, {
      stripeId,
      status: "pending",
      createdAt: Date.now()
    });
  },
});

export const fulfillBySessionId = internalMutation({
  args: { stripeSessionId: v.string() },
  handler: async (ctx, { stripeSessionId }) => {
    console.log("Looking for payment with session ID:", stripeSessionId);
    const payment = await ctx.db
      .query("payments")
      .withIndex("stripeSessionId", (q) => q.eq("stripeSessionId", stripeSessionId))
      .unique();

    if (payment) {
      console.log("Found payment, updating status to completed.");
      await ctx.db.patch(payment._id, {
        status: "completed",
        completedAt: Date.now(),
      });
    } else {
      console.error("No payment found for session ID:", stripeSessionId);
    }
  }
});

export const listByUser = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);

    if (!userId) return [];

    return await ctx.db
      .query("payments")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .order("desc")
      .collect();
  },
});

export const createDonationCheckoutSession = action({
  args: {
    profileId: v.id("profiles"),
    amount: v.number(),
    email: v.string(),
  },
  handler: async (
    ctx: ActionCtx,
    args: { profileId: Id<"profiles">; amount: number; email: string }
  ) => {
    // Get the profile
    const profile = await ctx.runQuery(api.profiles.getById, {
      profileId: args.profileId
    });

    if (!profile) {
      throw new ConvexError("Profile not found");
    }

    // Get the connected Stripe account for this profile
    const connectedAccount = await ctx.runQuery(api.stripeConnect.getConnectAccountForProfile, {
      profileId: args.profileId,
    });

    if (!connectedAccount || !connectedAccount.isOnboarded) {
      throw new ConvexError("This creator does not have a connected payment account");
    }

    // Create a checkout session in Stripe
    try {
      const session: Stripe.Checkout.Session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: "usd",
              product_data: {
                name: `Donation to ${profile.handle}`,
                description: "Thank you for your support!",
              },
              unit_amount: args.amount,
            },
            quantity: 1,
          },
        ],
        mode: "payment",
        success_url: `${BASE_URL}/${profile.handle}?donation=success`,
        cancel_url: `${BASE_URL}/${profile.handle}?donation=canceled`,
        payment_intent_data: {
          application_fee_amount: Math.round(args.amount * 0.05), // 5% platform fee
          transfer_data: {
            destination: connectedAccount.stripeConnectAccountId,
          },
        },
        customer_email: args.email,
        metadata: {
          profileId: args.profileId,
          donationType: "one_time",
        },
      });

      // Create a payment record in the database
      const userId = profile.userId;
      await ctx.runMutation(internal.payments.create, {
        userId,
        amount: args.amount,
        status: "created",
        stripeSessionId: session.id,
        createdAt: Date.now(),
      });

      return {
        success: true,
        checkoutUrl: session.url,
      };
    } catch (error) {
      console.error("Error creating donation checkout session:", error);
      throw new ConvexError("Failed to create checkout session");
    }
  },
});


================================================
FILE: convex/profileLayouts.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { sectionConfig } from "./types/profileSections";
import { getAuthUserId } from "@convex-dev/auth/server";
import { getDefaultSections } from "./helpers/profiles/utils";

export const updateProfileSections = mutation({
  args: {
    profileId: v.id("profiles"),
    sections: v.array(sectionConfig),
  },
  returns: v.boolean(),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const profile = await ctx.db.get(args.profileId);
    if (!profile) {
      throw new Error("Profile not found");
    }

    if (profile.userId !== userId) {
      throw new Error("Not authorized to update this profile");
    }

    await ctx.db.patch(args.profileId, {
      componentSettings: {
        ...profile.componentSettings,
        sections: args.sections,
      },
    });

    return true;
  },
});

export const getProfileSections = query({
  args: {
    profileId: v.id("profiles"),
  },
  returns: v.array(sectionConfig),
  handler: async (ctx, args) => {
    const profile = await ctx.db.get(args.profileId);

    if (!profile || !profile.componentSettings?.sections) {
      return getDefaultSections();
    }

    return profile.componentSettings.sections;
  },
});


================================================
FILE: convex/profiles.ts
================================================
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";
import { getDefaultTheme, getDefaultTemplate, getDefaultSections } from "./helpers/profiles/utils";
import { canCreateProfile } from "./helpers/subscriptions/limitHelpers";

export const getById = query({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.profileId);
  },
});

export const getByHandle = query({
  args: { handle: v.string() },
  returns: v.union(v.object({}), v.null()),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("profiles")
      .withIndex("by_handle", (q) => q.eq("handle", args.handle))
      .first();
  },
});

export const create = mutation({
  args: {
    handle: v.string(),
    name: v.optional(v.string()),
    bio: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
  },
  returns: v.id("profiles"),
  handler: async (ctx, args) => {

    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Check if user has reached their profile limit
    const profileLimitCheck = await canCreateProfile(ctx.db, userId);
    if (!profileLimitCheck.allowed) {
      throw new Error(`Profile limit reached: You can create up to ${profileLimitCheck.limit} profiles on your current plan. You currently have ${profileLimitCheck.current} profiles.`);
    }

    const existing = await ctx.db
      .query("profiles")
      .withIndex("by_handle", (q) => q.eq("handle", args.handle))
      .unique();

    if (existing) throw new Error("Handle already taken");

    const defaultTheme = await ctx.db
      .query("profileThemes")
      .filter((q) => q.eq(q.field("isDefault"), true))
      .first();

    if (!defaultTheme) throw new Error("No default theme found");

    const defaultTemplate = await ctx.db
      .query("profileTemplates")
      .filter((q) => q.eq(q.field("isDefault"), true))
      .first();

    if (!defaultTemplate) throw new Error("No default template found");

    return await ctx.db.insert("profiles", {
      userId,
      handle: args.handle,
      name: args.name,
      bio: args.bio,
      avatarUrl: args.avatarUrl ?? undefined,
      profileThemeId: defaultTheme._id,
      profileTemplateId: defaultTemplate._id,
    });
  },
});


export const update = mutation({
  args: {
    profileId: v.id("profiles"),
    avatarUrl: v.optional(v.string()),
    name: v.optional(v.string()),
    bio: v.optional(v.string()),
    handle: v.optional(v.string()),
    profileThemeId: v.optional(v.id("profileThemes")),
    profileTemplateId: v.optional(v.id("profileTemplates")),
  },
  handler: async (ctx, args) => {

    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const profile = await ctx.db.get(args.profileId);
    if (!profile) throw new Error("Profile not found");

    if (profile.userId !== userId) {
      throw new Error("Not authorized to update this profile");
    }

    if (args.profileThemeId) {
      const theme = await ctx.db.get(args.profileThemeId);
      if (!theme) {
        throw new Error("Selected theme not found");
      }

      if (!theme.isPublic &&
        (theme.creatorProfileId === undefined ||
          theme.creatorProfileId.toString() !== args.profileId.toString())) {
        throw new Error("Selected theme is not available for use");
      }
    }

    if (args.profileTemplateId) {
      const template = await ctx.db.get(args.profileTemplateId);
      if (!template) {
        throw new Error("Selected template not found");
      }

      if (!template.isPublic &&
        (template.creatorProfileId === undefined ||
          template.creatorProfileId.toString() !== args.profileId.toString())) {
        throw new Error("Selected template is not available for use");
      }
    }

    if (args.handle && args.handle !== profile.handle) {
      const existing = await ctx.db
        .query("profiles")
        .withIndex("by_handle", (q) => q.eq("handle", args.handle!))
        .first();

      if (existing) throw new Error("Handle already taken");
    }

    await ctx.db.patch(args.profileId, { ...args });

    return { success: true };
  },
});

export const listByUser = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    return await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();
  },
});

export const listByUserWithThemesAndTemplates = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const profiles = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();

    const profilesWithData = await Promise.all(
      profiles.map(async (profile) => {
        let theme = null;
        if (profile.profileThemeId) {
          theme = await ctx.db.get(profile.profileThemeId);
        }

        if (!theme) {
          theme = await getDefaultTheme(ctx.db);
          if (!theme) throw new Error("Default theme not found in database.");
        }

        let template = null;
        if (profile.profileTemplateId) {
          template = await ctx.db.get(profile.profileTemplateId);
        }

        if (!template) {
          template = await getDefaultTemplate(ctx.db);
          if (!template) throw new Error("Default template not found in database.");
        }

        return { ...profile, theme, template };
      })
    );

    return profilesWithData;
  },
});

export const hasStripeConnected = query({
  args: {
    profileId: v.id("profiles"),
  },
  returns: v.boolean(),
  handler: async (ctx, args) => {
    const stripeConnected = await ctx.db
      .query("stripeConnectAccounts")
      .withIndex("by_profile", (q) => q.eq("profileId", args.profileId))
      .filter((q) => q.eq(q.field("isOnboarded"), true))
      .unique();

    return !!stripeConnected;
  },
});

export const getComplete = query({
  args: {
    profileId: v.optional(v.id("profiles")),
    handle: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    if (!args.profileId && !args.handle) {
      throw new Error("Either profileId or handle must be provided");
    }

    let profile;

    if (args.profileId) {
      profile = await ctx.db.get(args.profileId);
    } else if (args.handle) {
      profile = await ctx.db
        .query("profiles")
        .withIndex("by_handle", (q) => q.eq("handle", args.handle!))
        .first();
    }

    if (!profile) return null

    let theme;
    let template;

    [theme, template] = await Promise.all([
      profile.profileThemeId ? ctx.db.get(profile.profileThemeId) : null,
      profile.profileTemplateId ? ctx.db.get(profile.profileTemplateId) : null
    ]);

    if (!theme) {
      theme = await getDefaultTheme(ctx.db);
      if (!theme) throw new Error("Default theme not found in database.");
    }

    if (!template) {
      template = await getDefaultTemplate(ctx.db);
      if (!template) throw new Error("Default template not found in database.");
    }

    const [items, links, stripeConnected] = await Promise.all([
      ctx.db
        .query("items")
        .withIndex("by_profile", (q) => q.eq("profileId", profile._id))
        .collect(),
      ctx.db
        .query("links")
        .withIndex("by_profile", (q) => q.eq("profileId", profile._id))
        .collect(),
      ctx.db
        .query("stripeConnectAccounts")
        .withIndex("by_profile", (q) => q.eq("profileId", profile._id))
        .filter((q) => q.eq(q.field("isOnboarded"), true))
        .first()
    ]);

    const sections = profile.componentSettings?.sections || getDefaultSections();

    return {
      ...profile,
      theme,
      template,
      items,
      links,
      sections,
      hasStripeConnected: !!stripeConnected
    };
  },
});


================================================
FILE: convex/profileTemplates.ts
================================================
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";

export const getById = query({
  args: { profileTemplateId: v.id("profileTemplates") },
  returns: v.union(v.object({}), v.null()),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.profileTemplateId);
  },
});

export const listPublic = query({
  args: { category: v.optional(v.string()) },
  returns: v.array(v.object({})),
  handler: async (ctx, args) => {
    let q = ctx.db
      .query("profileTemplates")
      .withIndex("public_templates", (q) => q.eq("isPublic", true));

    // Apply category filter if provided
    // TODO: on backend?
    if (args.category && args.category !== 'all') {
      q = q.filter((q) => q.eq(q.field("category"), args.category));
    }

    return await q.collect();
  },
});

export const create = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
    creatorProfileId: v.id("profiles"),
    isPublic: v.boolean(),
    category: v.string(),
    themeId: v.optional(v.id("profileThemes")),
    components: v.array(
      v.object({
        type: v.string(),
        order: v.number(),
        isEnabled: v.boolean(),
        settings: v.object({}),
      })
    ),
    customizations: v.optional(
      v.object({
        fonts: v.optional(
          v.object({
            heading: v.optional(v.string()),
            body: v.optional(v.string()),
            display: v.optional(v.string()),
          })
        ),
        spacing: v.optional(
          v.object({
            cardPadding: v.optional(v.string()),
            elementSpacing: v.optional(v.string()),
            sectionSpacing: v.optional(v.string()),
          })
        ),
        shape: v.optional(
          v.object({
            cardBorderRadius: v.optional(v.string()),
            buttonBorderRadius: v.optional(v.string()),
            imageBorderRadius: v.optional(v.string()),
          })
        ),
        shadows: v.optional(
          v.object({
            cardShadow: v.optional(v.string()),
            buttonShadow: v.optional(v.string()),
          })
        ),
        customCss: v.optional(v.string()),
      })
    ),
    previewImage: v.optional(v.string()),
  },
  returns: v.id("profileTemplates"),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify the creator profile belongs to the current user
    const profile = await ctx.db.get(args.creatorProfileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Not authorized to create templates for this profile");
    }

    const timestamp = Date.now();

    const profileTemplateId = await ctx.db.insert("profileTemplates", {
      ...args,
      customizations: args.customizations ?? {},
      createdAt: timestamp,
      updatedAt: timestamp
    });

    return profileTemplateId;
  },
});

export const update = mutation({
  args: {
    profileTemplateId: v.id("profileTemplates"),
    name: v.optional(v.string()),
    description: v.optional(v.string()),
    isPublic: v.optional(v.boolean()),
    isDefault: v.optional(v.boolean()),
    category: v.optional(v.string()),
    themeId: v.optional(v.id("profileThemes")),
    components: v.optional(
      v.array(
        v.object({
          type: v.string(),
          order: v.number(),
          isEnabled: v.boolean(),
          settings: v.object({}),
        })
      )
    ),
    customizations: v.optional(
      v.object({
        fonts: v.optional(
          v.object({
            heading: v.optional(v.string()),
            body: v.optional(v.string()),
            display: v.optional(v.string()),
          })
        ),
        spacing: v.optional(
          v.object({
            cardPadding: v.optional(v.string()),
            elementSpacing: v.optional(v.string()),
            sectionSpacing: v.optional(v.string()),
          })
        ),
        shape: v.optional(
          v.object({
            cardBorderRadius: v.optional(v.string()),
            buttonBorderRadius: v.optional(v.string()),
            imageBorderRadius: v.optional(v.string()),
          })
        ),
        shadows: v.optional(
          v.object({
            cardShadow: v.optional(v.string()),
            buttonShadow: v.optional(v.string()),
          })
        ),
        customCss: v.optional(v.string()),
      })
    ),
    previewImage: v.optional(v.string()),
  },
  returns: v.id("profileTemplates"),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const template = await ctx.db.get(args.profileTemplateId);
    if (!template) throw new Error("Template not found");

    // Verify the creator profile belongs to the current user
    if (template.creatorProfileId) {
      const profile = await ctx.db.get(template.creatorProfileId);
      if (!profile || profile.userId !== userId) {
        throw new Error("Not authorized to update this template");
      }
    }

    const timestamp = Date.now();

    await ctx.db.patch(args.profileTemplateId, {
      ...args,
      updatedAt: timestamp
    });

    return args.profileTemplateId;
  },
});

export const setProfileTemplate = mutation({
  args: {
    profileId: v.id("profiles"),
    profileTemplateId: v.id("profileTemplates"),
  },
  returns: v.object({
    success: v.boolean(),
    profileId: v.id("profiles"),
    templateId: v.id("profileTemplates"),
  }),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify the profile belongs to the current user
    const profile = await ctx.db.get(args.profileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Not authorized to update this profile");
    }

    const template = await ctx.db.get(args.profileTemplateId);
    if (!template) throw new Error("Template not found");

    // Ensure template is either public or created by the user
    if (
      !template.isPublic &&
      (template.creatorProfileId === undefined ||
        template.creatorProfileId.toString() !== args.profileId.toString())
    ) {
      throw new Error("Template is not available for use");
    }

    await ctx.db.patch(args.profileId, {
      profileTemplateId: args.profileTemplateId,
    });

    return {
      success: true,
      profileId: args.profileId,
      templateId: args.profileTemplateId,
    };
  },
});

export const remove = mutation({
  args: {
    profileTemplateId: v.id("profileTemplates"),
  },
  returns: v.object({ success: v.boolean() }),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const template = await ctx.db.get(args.profileTemplateId);
    if (!template) throw new Error("Template not found");

    // Verify the creator profile belongs to the current user
    if (template.creatorProfileId) {
      const profile = await ctx.db.get(template.creatorProfileId);
      if (!profile || profile.userId !== userId) {
        throw new Error("Not authorized to delete this template");
      }
    }

    // Find profiles using this template and unset it
    const profilesWithTemplate = await ctx.db
      .query("profiles")
      .filter((q) => q.eq(q.field("profileTemplateId"), args.profileTemplateId))
      .collect();

    for (const profile of profilesWithTemplate) {
      await ctx.db.patch(profile._id, {
        profileTemplateId: undefined,
        componentSettings: undefined,
      });
    }

    await ctx.db.delete(args.profileTemplateId);

    return { success: true };
  },
});

export const updateComponentSettings = mutation({
  args: {
    profileId: v.id("profiles"),
    componentType: v.string(),
    settings: v.object({}),
  },
  returns: v.object({
    success: v.boolean(),
    profileId: v.id("profiles"),
    componentType: v.string(),
  }),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify the profile belongs to the current user
    const profile = await ctx.db.get(args.profileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Not authorized to update this profile");
    }

    // Get current component settings or initialize empty object
    const currentSettings = profile.componentSettings || {};

    // Update the specific component settings
    const updatedSettings = {
      ...currentSettings,
      [args.componentType]: args.settings,
    };

    await ctx.db.patch(args.profileId, {
      componentSettings: updatedSettings,
    });

    return {
      success: true,
      profileId: args.profileId,
      componentType: args.componentType,
    };
  },
});


================================================
FILE: convex/profileThemes.ts
================================================
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";

export const getById = query({
  args: { profileThemeId: v.id("profileThemes") },
  returns: v.union(v.object({}), v.null()),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.profileThemeId);
  },
});

export const listPublic = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db
      .query("profileThemes")
      .withIndex("public_themes", (q) => q.eq("isPublic", true))
      .collect();
  },
});

export const listByCreator = query({
  args: { creatorProfileId: v.id("profiles") },
  returns: v.array(v.object({})),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("profileThemes")
      .withIndex("by_creator", (q) => q.eq("creatorProfileId", args.creatorProfileId))
      .collect();
  },
});

export const create = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
    creatorProfileId: v.id("profiles"),
    isPublic: v.boolean(),
    settings: v.object({
      color: v.string(),
      style: v.string(),
      layout: v.string(),
    }),
    previewImage: v.optional(v.string()),
  },
  returns: v.id("profileThemes"),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify the creator profile belongs to the current user
    const profile = await ctx.db.get(args.creatorProfileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Not authorized to create themes for this profile");
    }

    const timestamp = Date.now();

    const profileThemeId = await ctx.db.insert("profileThemes", {
      name: args.name,
      description: args.description,
      creatorProfileId: args.creatorProfileId,
      isPublic: args.isPublic,
      isDefault: false,
      settings: args.settings,
      previewImage: args.previewImage,
      createdAt: timestamp,
      updatedAt: timestamp,
    });

    return profileThemeId;
  },
});

/**
 * Update an existing profile theme
 */
export const update = mutation({
  args: {
    profileThemeId: v.id("profileThemes"),
    name: v.optional(v.string()),
    description: v.optional(v.string()),
    isPublic: v.optional(v.boolean()),
    settings: v.optional(v.object({
      color: v.optional(v.string()),
      style: v.optional(v.string()),
      layout: v.optional(v.string()),
    })),
    previewImage: v.optional(v.string()),
  },
  returns: v.object({}),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const theme = await ctx.db.get(args.profileThemeId);
    if (!theme) throw new Error("Theme not found");

    // Verify the creator profile belongs to the current user
    if (theme.creatorProfileId) {
      const profile = await ctx.db.get(theme.creatorProfileId);
      if (!profile || profile.userId !== userId) {
        throw new Error("Not authorized to update this theme");
      }
    }

    let newSettings = theme.settings;

    if (args.settings) {
      newSettings = { ...theme.settings, ...args.settings };
    }

    await ctx.db.patch(args.profileThemeId, {
      ...args,
      settings: newSettings,
      updatedAt: Date.now()
    });

    return { success: true };
  },
});

export const setProfileTheme = mutation({
  args: {
    profileId: v.id("profiles"),
    profileThemeId: v.id("profileThemes"),
  },
  returns: v.object({}),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify the profile belongs to the current user
    const profile = await ctx.db.get(args.profileId);
    if (!profile || profile.userId !== userId) {
      throw new Error("Not authorized to update this profile");
    }

    // Verify the theme exists
    const theme = await ctx.db.get(args.profileThemeId);
    if (!theme) throw new Error("Theme not found");

    // Ensure theme is either public or created by the user
    if (!theme.isPublic &&
      (theme.creatorProfileId === undefined ||
        theme.creatorProfileId.toString() !== args.profileId.toString())) {
      throw new Error("Theme is not available for use");
    }

    await ctx.db.patch(args.profileId, {
      profileThemeId: args.profileThemeId
    });

    return { success: true };
  },
});

export const remove = mutation({
  args: {
    profileThemeId: v.id("profileThemes"),
  },
  returns: v.object({}),
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const theme = await ctx.db.get(args.profileThemeId);
    if (!theme) throw new Error("Theme not found");

    // Verify the creator profile belongs to the current user
    if (theme.creatorProfileId) {
      const profile = await ctx.db.get(theme.creatorProfileId);
      if (!profile || profile.userId !== userId) {
        throw new Error("Not authorized to delete this theme");
      }
    }

    // TODO: this is bad and incorrect
    if (theme.isDefault && theme.creatorProfileId) {
      await ctx.db.patch(theme.creatorProfileId, {
        profileThemeId: undefined
      });
    }

    await ctx.db.delete(args.profileThemeId);

    return { success: true };
  },
});


================================================
FILE: convex/router.ts
================================================
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { getAuthUserId } from "@convex-dev/auth/server";

const http = httpRouter();

http.route({
  path: "/stripe",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    const signature = request.headers.get("stripe-signature");

    if (!signature) {
      return new Response(JSON.stringify({}), { status: 400, headers: { "Content-Type": "application/json" } });
    }

    const result = await ctx.runAction(internal.stripe.fulfill, {
      signature,
      payload: await request.text(),
    });

    console.log("[STRIPE HOOK] EVENT RESULT", result);

    if (!result.success) {
      console.error("[STRIPE HOOK] Error processing event", result.error);
    }

    return new Response(JSON.stringify({ received: true }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }),
});

http.route({
  path: "/success",
  method: "GET",
  handler: httpAction(async (ctx) => {
    // Authenticate user
    const userId = await getAuthUserId(ctx);

    if (!userId) {
      return new Response(null, { status: 302, headers: { Location: "/" } });
    }

    // Get Stripe customer ID from Convex
    const stripeCustomerId = await ctx.runQuery(internal.stripe.getStripeCustomerId, { userId });
    if (!stripeCustomerId) {
      return new Response(null, { status: 302, headers: { Location: "/" } });
    }

    // Sync Stripe data to Convex
    await ctx.runAction(internal.stripe.syncStripeDataToConvex, { customerId: stripeCustomerId });

    // Redirect to home
    return new Response(null, { status: 302, headers: { Location: "/" } });
  }),
});

export default http;



================================================
FILE: convex/schema.ts
================================================
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { authTables } from "@convex-dev/auth/server";

export default defineSchema({
  ...authTables,

  stripeCustomers: defineTable({
    userId: v.id("users"),
    stripeCustomerId: v.string(),
  }).index("by_user", ["userId"]),

  stripeConnectAccounts: defineTable({
    userId: v.id("users"),
    profileId: v.optional(v.id("profiles")),
    stripeConnectAccountId: v.string(),
    isOnboarded: v.boolean(),
    capabilities: v.optional(v.object({
      card_payments: v.optional(v.string()),
      transfers: v.optional(v.string()),
    })),
    payoutsEnabled: v.optional(v.boolean()),
    createdAt: v.number(),
    updatedAt: v.optional(v.number()),
  }).index("by_user", ["userId"])
    .index("by_profile", ["profileId"]),

  stripeAccountBalances: defineTable({
    accountId: v.string(),
    available: v.array(v.object({
      amount: v.number(),
      currency: v.string(),
    })),
    pending: v.array(v.object({
      amount: v.number(),
      currency: v.string(),
    })),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_accountId", ["accountId"]),

  stripePayouts: defineTable({
    accountId: v.string(),
    payoutId: v.string(),
    amount: v.number(),
    currency: v.string(),
    status: v.string(),
    arrivalDate: v.optional(v.number()),
    createdAt: v.number(),
  }).index("by_accountId", ["accountId"])
    .index("by_payoutId", ["payoutId"]),

  stripeSubscriptions: defineTable({
    customerId: v.string(),
    subscriptionId: v.optional(v.string()),
    status: v.string(),
    priceId: v.optional(v.string()),
    planType: v.optional(v.union(
      v.literal("STARTER"),
      v.literal("PRO"),
      v.literal("BUSINESS")
    )),
    currentPeriodStart: v.optional(v.number()),
    currentPeriodEnd: v.optional(v.number()),
    cancelAtPeriodEnd: v.optional(v.boolean()),
    paymentMethod: v.optional(
      v.object({
        brand: v.optional(v.string()),
        last4: v.optional(v.string()),
      })
    ),
  }).index("by_customerId", ["customerId"]),

  payments: defineTable({
    userId: v.id("users"),
    amount: v.number(),
    status: v.union(
      v.literal("created"),
      v.literal("pending"),
      v.literal("completed"),
      v.literal("failed")
    ),
    stripeSessionId: v.string(),
    createdAt: v.number(),
    completedAt: v.optional(v.number()),
    stripeId: v.optional(v.string()),
  })
    .index("stripeSessionId", ["stripeSessionId"])
    .index("stripeId", ["stripeId"])
    .index("by_user", ["userId"]),

  profiles: defineTable({
    userId: v.id("users"),
    handle: v.string(),
    name: v.optional(v.string()),
    bio: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
    profileThemeId: v.id("profileThemes"),
    profileTemplateId: v.id("profileTemplates"),
    componentSettings: v.optional(v.any()),
  }).index("by_handle", ["handle"])
    .index("by_user", ["userId"]),

  // Profile Themes (specific to profile appearances)
  profileThemes: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    creatorProfileId: v.optional(v.id("profiles")),
    isPublic: v.boolean(),
    isDefault: v.optional(v.boolean()),
    settings: v.object({
      color: v.string(), // default, blue, purple, green, pink, orange
      style: v.string(), // minimal, gradient, soft, outlined
      layout: v.string(), // standard, compact, expanded
    }),
    previewImage: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.optional(v.number()),
  }).index("by_creator", ["creatorProfileId"])
    .index("public_themes", ["isPublic"]),

  profileTemplates: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    creatorProfileId: v.optional(v.id("profiles")),
    isPublic: v.boolean(),
    isDefault: v.optional(v.boolean()),
    category: v.string(), // e.g., "business", "creator", "portfolio"
    previewImage: v.optional(v.string()),
    themeId: v.optional(v.id("profileThemes")), // Associated theme
    components: v.array(
      v.object({
        type: v.string(), // e.g., "header", "links", "bio", "social", "gallery"
        order: v.number(),
        isEnabled: v.boolean(),
        settings: v.any() // Accept any settings structure
      })
    ),
    customizations: v.object({
      fonts: v.optional(
        v.object({
          heading: v.optional(v.string()),
          body: v.optional(v.string()),
          display: v.optional(v.string())
        })
      ),
      spacing: v.optional(
        v.object({
          cardPadding: v.optional(v.string()),
          elementSpacing: v.optional(v.string()),
          sectionSpacing: v.optional(v.string())
        })
      ),
      shape: v.optional(
        v.object({
          cardBorderRadius: v.optional(v.string()),
          buttonBorderRadius: v.optional(v.string()),
          imageBorderRadius: v.optional(v.string())
        })
      ),
      shadows: v.optional(
        v.object({
          cardShadow: v.optional(v.string()),
          buttonShadow: v.optional(v.string())
        })
      ),
      customCss: v.optional(v.string())
    }),
    createdAt: v.number(),
    updatedAt: v.optional(v.number()),
  }).index("by_creator", ["creatorProfileId"])
    .index("public_templates", ["isPublic"])
    .index("by_category", ["category"]),

  items: defineTable({
    profileId: v.id("profiles"),
    title: v.string(),
    description: v.string(),
    type: v.union(
      v.object({ kind: v.literal("paid"), price: v.number(), fileId: v.id("_storage") }),
      v.object({ kind: v.literal("free"), fileId: v.id("_storage") }),
      v.object({ kind: v.literal("link"), url: v.string() })
    ),
  }).index("by_profile", ["profileId"]),

  links: defineTable({
    profileId: v.id("profiles"),
    title: v.string(),
    url: v.string(),
  }).index("by_profile", ["profileId"]),

  purchases: defineTable({
    userId: v.id("users"),
    itemId: v.id("items"),
    email: v.string(),
    downloadUrl: v.string(),
  }),

  leads: defineTable({
    userId: v.id("users"),
    itemId: v.id("items"),
    email: v.string(),
  }),

  // Landing Pages for a profile
  pages: defineTable({
    profileId: v.id("profiles"),
    title: v.string(),
    slug: v.string(), // for public URL
    templateId: v.optional(v.id("pageTemplates")),
    themeId: v.optional(v.id("pageThemes")),
    status: v.union(
      v.literal("draft"),
      v.literal("published"),
      v.literal("archived")
    ),
    meta: v.optional(
      v.object({
        description: v.optional(v.string()),
        image: v.optional(v.string()),
        keywords: v.optional(v.array(v.string())),
      })
    ),
    publishedAt: v.optional(v.number()),
    updatedAt: v.number(),
    createdAt: v.number(),
  }).index("by_profile", ["profileId"]),

  // Page Templates
  pageTemplates: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    previewImage: v.optional(v.string()),
    creatorProfileId: v.optional(v.id("profiles")),
    isPublic: v.boolean(),
    category: v.string(),
    createdAt: v.number(),
  }),

  // Themes (for styles, colors, fonts, etc.)
  pageThemes: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    creatorProfileId: v.optional(v.id("profiles")),
    isPublic: v.boolean(),
    style: v.object({
      colors: v.object({
        primary: v.string(),
        secondary: v.string(),
        background: v.string(),
        text: v.string(),
        accent: v.optional(v.string()),
        // Add more as needed
      }),
      fonts: v.object({
        heading: v.id("fonts"),
        body: v.id("fonts"),
        // Add more roles as needed
      }),
      borderRadius: v.optional(v.string()),
      spacing: v.optional(v.string()),
      // Add more style tokens as needed
    }),
    previewImage: v.optional(v.string()),
    createdAt: v.number(),
  }),

  // Landing Page Sections/Blocks
  pageSections: defineTable({
    pageId: v.id("pages"),
    type: v.union(
      v.literal("hero"),
      v.literal("features"),
      v.literal("cta"),
      v.literal("custom")
      // Add more as needed
    ),
    order: v.number(), // for ordering sections
    data: v.any(), // JSON blob for section-specific data (text, images, etc.)
    style: v.optional(v.any()), // Section-level style overrides
  }),

  // Fonts 
  fonts: defineTable({
    family: v.string(), // e.g., "Inter"
    variants: v.array(v.string()), // e.g., ["400", "700", "400italic"]
    subsets: v.array(v.string()), // e.g., ["latin", "latin-ext"]
    category: v.string(), // e.g., "sans-serif"
    cssUrl: v.string(), // e.g., "https://fonts.googleapis.com/css?family=Inter:400,700&display=swap"
    previewImage: v.optional(v.string()), // Optional: URL to a preview image
  }),

  pageVersions: defineTable({
    landingPageId: v.id("pages"),
    snapshot: v.any(), // Full page snapshot (sections, styles, etc.)
    createdAt: v.number(),
    createdBy: v.id("users"),
    message: v.optional(v.string()), // e.g. "Initial version", "Added hero section"
  }),
});


================================================
FILE: convex/stripe.ts
================================================
import Stripe from "stripe";
import { ConvexError, v } from "convex/values";
import { internalAction, internalQuery, internalMutation } from "./_generated/server";
import { internal, api } from "./_generated/api";
import { allowedEvents } from "./helpers/stripe/eventHelpers";
import { SubscriptionWithPeriods } from "./helpers/stripe/types";
import { extractPaymentMethod, mapStripePriceToInternalPlan } from "./helpers/stripe/paymentHelpers";
import { stripe } from "./lib/stripe";

export const fulfill = internalAction({
  args: { signature: v.string(), payload: v.string() },
  handler: async (ctx, { signature, payload }) => {
    const webhookSecret = process.env.STRIPE_WEBHOOKS_SECRET as string;
    try {
      const event = await stripe.webhooks.constructEventAsync(
        payload,
        signature,
        webhookSecret
      );

      if (!allowedEvents.includes(event.type)) {
        return { success: true }; // Ignore untracked events
      }

      // Special handling for checkout.session.completed
      if (event.type === "checkout.session.completed") {
        const session = event.data.object as Stripe.Checkout.Session;
        const stripeSessionId = session.id;
        console.log("Webhook session ID:", stripeSessionId);
        await ctx.runMutation(internal.payments.fulfillBySessionId, { stripeSessionId });
        return { success: true };
      }

      // For other events, try to extract customerId and sync
      const dataObject = event.data.object as { customer?: string };
      const customerId = dataObject.customer;

      if (typeof customerId === "string") {
        await ctx.runAction(internal.stripe.syncStripeDataToConvex, { customerId });
      }

      return { success: true };
    } catch (err) {
      console.error(err);
      return { success: false, error: (err as { message: string }).message };
    }
  },
});

// Get Stripe customer ID for a user
export const getStripeCustomerId = internalQuery({
  args: { userId: v.id("users") },
  returns: v.union(v.string(), v.null()),
  handler: async (ctx, { userId }) => {
    const stripeCustomer = await ctx.db
      .query("stripeCustomers")
      .withIndex("by_user", q => q.eq("userId", userId))
      .unique();

    return stripeCustomer ? stripeCustomer.stripeCustomerId : null;
  },
});

// Store Stripe customer ID for a user
export const storeStripeCustomerId = internalMutation({
  args: { userId: v.id("users"), stripeCustomerId: v.string() },
  returns: v.null(),
  handler: async (ctx, { userId, stripeCustomerId }) => {
    // Check if there's already a record
    const existing = await ctx.db
      .query("stripeCustomers")
      .withIndex("by_user", q => q.eq("userId", userId))
      .unique();

    if (existing) {
      // Update existing record
      await ctx.db.patch(existing._id, { stripeCustomerId });
    } else {
      // Create new record
      await ctx.db.insert("stripeCustomers", {
        userId,
        stripeCustomerId
      });
    }

    return null;
  },
});

export const syncStripeDataToConvex = internalAction({
  args: { customerId: v.string() },
  returns: v.any(),
  handler: async ({ runMutation, runQuery }, { customerId }) => {
    try {
      // Fetch the subscription plans to get the price IDs
      const SUBSCRIPTION_PLANS = await runQuery(api.subscriptions.getSubscriptionPlans, {});

      // Fetch latest subscription data from Stripe
      const subscriptions = await stripe.subscriptions.list({
        customer: customerId,
        limit: 1,
        status: "all",
        expand: ["data.default_payment_method", "data.items.data.price"],
      });

      // Handle case with no subscription
      if (subscriptions.data.length === 0) {
        const emptySubData = { status: "none" };
        await runMutation(internal.stripe.storeSubscriptionData, {
          customerId,
          subData: emptySubData,
        });
        return emptySubData;
      }

      // Extract subscription data
      const subscription = subscriptions.data[0] as SubscriptionWithPeriods;
      const stripePriceId = subscription.items.data[0].price.id;
      const unitAmount = subscription.items.data[0].price.unit_amount;

      // Determine plan type and map to our price ID
      const { priceId, planType } = mapStripePriceToInternalPlan(
        stripePriceId,
        unitAmount,
        subscription.metadata,
        SUBSCRIPTION_PLANS
      );

      // Create subscription data object
      const subData = {
        subscriptionId: subscription.id,
        status: subscription.status,
        priceId,
        planType,
        currentPeriodEnd: subscription.current_period_end,
        currentPeriodStart: subscription.current_period_start,
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        paymentMethod: extractPaymentMethod(subscription.default_payment_method),
      };

      // Store the data in Convex DB
      await runMutation(internal.stripe.storeSubscriptionData, {
        customerId,
        subData,
      });

      return subData;
    } catch (err) {
      console.error("Failed to sync Stripe data:", err);
      throw new ConvexError("Failed to sync Stripe data");
    }
  },
});


export const storeSubscriptionData = internalMutation({
  args: {
    customerId: v.string(),
    subData: v.any(),
  },
  handler: async (ctx, { customerId, subData }) => {
    const existing = await ctx.db
      .query("stripeSubscriptions")
      .withIndex("by_customerId", (q) => q.eq("customerId", customerId))
      .unique();

    if (existing) {
      await ctx.db.patch(existing._id, { ...subData });
    } else {
      await ctx.db.insert("stripeSubscriptions", {
        customerId,
        ...subData,
      });
    }
  },
});



================================================
FILE: convex/stripeConnect.ts
================================================
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { action, internalMutation, query } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";
import { internal, api } from "./_generated/api";
import { stripe } from "./lib/stripe";
import { BASE_URL } from "./helpers/common/url";

// Create a new Stripe Connect account
export const createConnectAccount = action({
  args: {
    profileId: v.optional(v.id("profiles")),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    if (!args.profileId) {
      throw new ConvexError("No account selected");
    }

    try {
      // Create a Stripe Connect Express account
      const account = await stripe.accounts.create({
        type: "express",
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
        },
        business_type: "individual",
        metadata: {
          userId: userId,
          profileId: args.profileId,
        },
      });

      // Store the account ID in our database
      await ctx.runMutation(internal.stripeConnect.storeConnectAccount, {
        userId,
        profileId: args.profileId,
        stripeConnectAccountId: account.id,
      });

      // Generate an account link for onboarding
      const accountLink = await stripe.accountLinks.create({
        account: account.id,
        refresh_url: `${BASE_URL}/dashboard/${args.profileId}?refresh=true`,
        return_url: `${BASE_URL}/dashboard/${args.profileId}?success=true`,
        type: "account_onboarding",
      });

      return {
        accountId: account.id,
        accountLinkUrl: accountLink.url,
      };
    } catch (error) {
      console.error("Error creating Stripe Connect account:", error);
      throw new ConvexError("Failed to create Stripe Connect account");
    }
  },
});

// Store a new Stripe Connect account in the database
export const storeConnectAccount = internalMutation({
  args: {
    userId: v.id("users"),
    profileId: v.optional(v.id("profiles")),
    stripeConnectAccountId: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("stripeConnectAccounts", {
      userId: args.userId,
      profileId: args.profileId,
      stripeConnectAccountId: args.stripeConnectAccountId,
      isOnboarded: false,
      createdAt: Date.now(),
    });
  },
});

// Get the account link for a Connect account (used for reconnecting to onboarding)
export const getAccountLink = action({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    try {
      // Check if the account belongs to the user
      const connectAccount = await ctx.runQuery(api.stripeConnect.getConnectAccountById, {
        accountId: args.accountId,
      });

      if (!connectAccount || connectAccount.userId !== userId) {
        throw new ConvexError("Connect account not found or unauthorized");
      }

      // Generate a new account link
      const accountLink = await stripe.accountLinks.create({
        account: args.accountId,
        refresh_url: `${BASE_URL}/dashboard/${connectAccount.profileId}?refresh=true`,
        return_url: `${BASE_URL}/dashboard/${connectAccount.profileId}?success=true`,
        type: "account_onboarding",
      });

      return {
        accountLinkUrl: accountLink.url,
      };
    } catch (error) {
      console.error("Error creating account link:", error);
      throw new ConvexError("Failed to create account link");
    }
  },
});

// Get a Connect account by ID
export const getConnectAccountById = query({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }

    return await ctx.db
      .query("stripeConnectAccounts")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("stripeConnectAccountId"), args.accountId))
      .unique();
  },
});

// Get Connect accounts for the current user
export const listConnectAccounts = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }

    return await ctx.db
      .query("stripeConnectAccounts")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();
  },
});

// Get Connect account for a specific profile
export const getConnectAccountForProfile = query({
  args: {
    profileId: v.id("profiles"),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }

    return await ctx.db
      .query("stripeConnectAccounts")
      .withIndex("by_profile", (q) => q.eq("profileId", args.profileId))
      .filter((q) => q.eq(q.field("userId"), userId))
      .unique();
  },
});

// Sync Connect account details from Stripe
export const syncConnectAccountDetails = action({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    try {
      // Get the account from Stripe
      const account = await stripe.accounts.retrieve(args.accountId);

      // Update our database with the latest details
      await ctx.runMutation(internal.stripeConnect.updateConnectAccount, {
        accountId: args.accountId,
        isOnboarded: account.details_submitted,
        capabilities: account.capabilities,
        payoutsEnabled: account.payouts_enabled,
      });

      return {
        success: true,
        account: {
          id: account.id,
          isOnboarded: account.details_submitted,
          capabilities: account.capabilities,
          payoutsEnabled: account.payouts_enabled,
        },
      };
    } catch (error) {
      console.error("Error syncing Connect account details:", error);
      throw new ConvexError("Failed to sync Connect account details");
    }
  },
});

// Update Connect account details in our database
export const updateConnectAccount = internalMutation({
  args: {
    accountId: v.string(),
    isOnboarded: v.boolean(),
    capabilities: v.optional(v.any()),
    payoutsEnabled: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const connectAccount = await ctx.db
      .query("stripeConnectAccounts")
      .filter((q) => q.eq(q.field("stripeConnectAccountId"), args.accountId))
      .unique();

    if (!connectAccount) {
      throw new ConvexError("Connect account not found");
    }

    await ctx.db.patch(connectAccount._id, {
      isOnboarded: args.isOnboarded,
      capabilities: args.capabilities,
      payoutsEnabled: args.payoutsEnabled,
      updatedAt: Date.now(),
    });
  },
});

// Get account balance
export const getAccountBalance = query({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    // Verify the user owns this account
    const account = await ctx.db
      .query("stripeConnectAccounts")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("stripeConnectAccountId"), args.accountId))
      .unique();

    if (!account) {
      throw new ConvexError("Connect account not found or unauthorized");
    }

    // Get the balance data if it exists
    const balanceData = await ctx.db
      .query("stripeAccountBalances")
      .filter((q) => q.eq(q.field("accountId"), args.accountId))
      .unique();

    if (!balanceData) {
      // If no balance data exists yet, return empty balance
      return {
        available: [{ amount: 0, currency: "usd" }],
        pending: [{ amount: 0, currency: "usd" }],
        lastUpdated: null
      };
    }

    return {
      available: balanceData.available,
      pending: balanceData.pending,
      lastUpdated: balanceData.updatedAt
    };
  },
});

// Sync account balance from Stripe
export const syncAccountBalance = action({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    try {
      // Verify the user owns this account
      const account = await ctx.runQuery(api.stripeConnect.getConnectAccountById, {
        accountId: args.accountId,
      });

      if (!account || account.userId !== userId) {
        throw new ConvexError("Connect account not found or unauthorized");
      }

      // Get the account balance from Stripe
      const balance = await stripe.balance.retrieve({
        stripeAccount: args.accountId,
      });

      // Store the balance in our database
      await ctx.runMutation(internal.stripeConnect.storeAccountBalance, {
        accountId: args.accountId,
        available: balance.available.map(({ amount, currency }) => ({ amount, currency })),
        pending: balance.pending.map(({ amount, currency }) => ({ amount, currency })),
      });

      return {
        success: true,
        balance: {
          available: balance.available,
          pending: balance.pending,
        },
      };
    } catch (error) {
      console.error("Error syncing account balance:", error);
      throw new ConvexError("Failed to sync account balance");
    }
  },
});

// Store account balance
export const storeAccountBalance = internalMutation({
  args: {
    accountId: v.string(),
    available: v.array(v.object({
      amount: v.number(),
      currency: v.string(),
    })),
    pending: v.array(v.object({
      amount: v.number(),
      currency: v.string(),
    })),
  },
  handler: async (ctx, args) => {
    const existingBalance = await ctx.db
      .query("stripeAccountBalances")
      .filter((q) => q.eq(q.field("accountId"), args.accountId))
      .unique();

    const now = Date.now();

    if (existingBalance) {
      await ctx.db.patch(existingBalance._id, {
        available: args.available,
        pending: args.pending,
        updatedAt: now,
      });
    } else {
      await ctx.db.insert("stripeAccountBalances", {
        accountId: args.accountId,
        available: args.available,
        pending: args.pending,
        createdAt: now,
        updatedAt: now,
      });
    }
  },
});

// Create a payout
export const createPayout = action({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new ConvexError("Unauthorized");
    }

    try {
      // Verify the user owns this account
      const account = await ctx.runQuery(api.stripeConnect.getConnectAccountById, {
        accountId: args.accountId,
      });

      if (!account || account.userId !== userId) {
        throw new ConvexError("Connect account not found or unauthorized");
      }

      const balance = await stripe.balance.retrieve({ stripeAccount: args.accountId });
      const availableAmount = balance.available[0]?.amount ?? 0;

      // Create the payout through Stripe
      const payout = await stripe.payouts.create(
        {
          amount: availableAmount,
          currency: "usd",
          description: "Monolink earnings payout",
        },
        {
          stripeAccount: args.accountId,
        }
      );

      // Save the payout to our database
      await ctx.runMutation(internal.stripeConnect.storePayout, {
        accountId: args.accountId,
        payoutId: payout.id,
        amount: payout.amount,
        currency: payout.currency,
        status: payout.status,
        arrivalDate: payout.arrival_date,
        createdAt: payout.created,
      });

      return {
        success: true,
        payout: {
          id: payout.id,
          amount: payout.amount,
          status: payout.status,
        },
      };
    } catch (error) {
      console.error("Error creating payout:", error);
      throw new ConvexError("Failed to create payout: " + (error as Error).message);
    }
  },
});

// Store payout information
export const storePayout = internalMutation({
  args: {
    accountId: v.string(),
    payoutId: v.string(),
    amount: v.number(),
    currency: v.string(),
    status: v.string(),
    arrivalDate: v.optional(v.number()),
    createdAt: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("stripePayouts", {
      accountId: args.accountId,
      payoutId: args.payoutId,
      amount: args.amount,
      currency: args.currency,
      status: args.status,
      arrivalDate: args.arrivalDate,
      createdAt: args.createdAt,
    });
  },
});

// Get payout history
export const getPayoutHistory = action({
  args: {
    accountId: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }

    // Verify the user owns this account
    const account = await ctx.runQuery(api.stripeConnect.getConnectAccountById, {
      accountId: args.accountId,
    });

    if (!account) {
      return [];
    }

    // Get payout history from Stripe
    try {
      const payouts = await stripe.payouts.list(
        {
          limit: 10,
        },
        {
          stripeAccount: args.accountId,
        }
      );

      return payouts.data.map(payout => ({
        id: payout.id,
        amount: payout.amount,
        status: payout.status,
        created: payout.created,
        arrival_date: payout.arrival_date,
        currency: payout.currency,
      }));
    } catch (error) {
      console.error("Error fetching payout history:", error);
      return [];
    }
  },
});


================================================
FILE: convex/subscriptions.ts
================================================
import { v } from "convex/values";
import { action, query } from "./_generated/server";
import { api, internal } from "./_generated/api";
import { getAuthUserId } from "@convex-dev/auth/server";
import { BASE_URL } from "./helpers/common/url";
import { PlanType, SUBSCRIPTION_PLANS, PLAN_TYPES } from "./lib/plans";
import { SubscriptionData, SubscriptionResult } from "./helpers/subscriptions/types";
import { stripe } from "./lib/stripe";
import { planTypeValidator } from "./helpers/subscriptions/validators";

// Get available subscription plans
export const getSubscriptionPlans = query({
  args: {},
  returns: v.any(),
  handler: async () => {
    return SUBSCRIPTION_PLANS;
  },
});

// Start subscription checkout
export const subscribe = action({
  args: {
    planType: planTypeValidator
  },
  returns: v.union(v.string(), v.null()),
  handler: async (ctx, { planType }): Promise<string | null> => {
    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new Error("Not authenticated");
    }

    const plan = SUBSCRIPTION_PLANS[planType as PlanType];

    if (!plan) {
      throw new Error("Invalid plan type");
    }

    const user = await ctx.runQuery(internal.auth.getUserById, { userId });
    if (!user?.email) {
      throw new Error("User email not found");
    }

    // Get or create Stripe customer
    let stripeCustomerId: string | null = await ctx.runQuery(internal.stripe.getStripeCustomerId, { userId });
    if (!stripeCustomerId) {
      const newCustomer = await stripe.customers.create({
        email: user.email,
        metadata: { userId },
      });

      await ctx.runMutation(internal.stripe.storeStripeCustomerId, {
        userId,
        stripeCustomerId: newCustomer.id,
      });

      stripeCustomerId = newCustomer.id;
    }

    // Create checkout session
    const session = await stripe.checkout.sessions.create({
      customer: stripeCustomerId,
      payment_method_types: ["card"],
      line_items: [
        {
          price_data: {
            currency: "USD",
            unit_amount: plan.price,
            recurring: {
              interval: "month",
            },
            product_data: {
              name: `${plan.name} Subscription`,
              description: `Monolink ${plan.name} subscription`,
              metadata: {
                monolink_plan_type: planType,
                monolink_plan_price: plan.price.toString()
              }
            }
          },
          quantity: 1,
        },
      ],
      mode: "subscription",
      success_url: `${BASE_URL}/dashboard?subscription=success`,
      cancel_url: `${BASE_URL}/dashboard?subscription=cancel`,
      metadata: {
        userId: userId,
        planType: planType,
        planPrice: plan.price.toString()
      },
      subscription_data: {
        metadata: {
          monolink_plan_type: planType,
          monolink_plan_price: plan.price.toString()
        }
      }
    });

    return session.url;
  },
});

// Get user's active subscription
export const getUserSubscription = query({
  args: {},
  returns: v.union(v.any(), v.null()),
  handler: async (ctx): Promise<SubscriptionResult | null> => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return null;

    const stripeCustomerId: string | null = await ctx.db
      .query("stripeCustomers")
      .withIndex("by_user", q => q.eq("userId", userId))
      .unique()
      .then(customer => customer?.stripeCustomerId || null);
    if (!stripeCustomerId) return null;

    // Get subscription from database
    const subscription: SubscriptionData | null = await ctx.db
      .query("stripeSubscriptions")
      .withIndex("by_customerId", (q) => q.eq("customerId", stripeCustomerId))
      .unique();

    // If subscription exists and is active
    if (subscription && ['active', 'trialing'].includes(subscription.status)) {
      // Only use planType from the subscription data
      if (
        subscription.planType &&
        PLAN_TYPES.includes(subscription.planType)
      ) {
        const planType = subscription.planType;
        return {
          ...subscription,
          planType,
          plan: SUBSCRIPTION_PLANS[planType],
        };
      }
      // If planType is missing or invalid, return null (or handle as needed)
      return null;
    }

    return null;
  },
});

// Cancel subscription
export const cancelSubscription = action({
  args: {},
  returns: v.object({ success: v.boolean() }),
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new Error("Not authenticated");
    }

    const stripeCustomerId: string | null = await ctx.runQuery(internal.stripe.getStripeCustomerId, { userId });
    if (!stripeCustomerId) {
      throw new Error("No subscription found");
    }

    const subscription: SubscriptionResult | null = await ctx.runQuery(api.subscriptions.getUserSubscription, {});
    if (!subscription || !subscription.subscriptionId) {
      throw new Error("No active subscription found");
    }

    // Cancel subscription at period end
    await stripe.subscriptions.update(subscription.subscriptionId, {
      cancel_at_period_end: true,
    });

    // Sync data
    await ctx.runAction(internal.stripe.syncStripeDataToConvex, { customerId: stripeCustomerId });

    return { success: true };
  },
});

// Reactivate a subscription that was set to cancel at period end
export const reactivateSubscription = action({
  args: {},
  returns: v.object({ success: v.boolean() }),
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const stripeCustomerId: string | null = await ctx.runQuery(internal.stripe.getStripeCustomerId, { userId });
    if (!stripeCustomerId) {
      throw new Error("No subscription found");
    }

    const subscription: SubscriptionResult | null = await ctx.runQuery(api.subscriptions.getUserSubscription, {});
    if (!subscription || !subscription.subscriptionId) {
      throw new Error("No active subscription found");
    }

    if (!subscription.cancelAtPeriodEnd) {
      throw new Error("Subscription is not scheduled for cancellation");
    }

    // Reactivate subscription
    await stripe.subscriptions.update(subscription.subscriptionId, {
      cancel_at_period_end: false,
    });

    // Sync data
    await ctx.runAction(internal.stripe.syncStripeDataToConvex, { customerId: stripeCustomerId });

    return { success: true };
  },
});

// Create a customer portal session for managing subscription
export const createCustomerPortalSession = action({
  args: {},
  returns: v.union(v.string(), v.null()),
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const stripeCustomerId: string | null = await ctx.runQuery(internal.stripe.getStripeCustomerId, { userId });
    if (!stripeCustomerId) {
      return null;
    }

    try {
      // Create a customer portal session
      const session = await stripe.billingPortal.sessions.create({
        customer: stripeCustomerId,
        return_url: `${BASE_URL}/dashboard/subscription`,
      });

      return session.url;
    } catch (error) {
      console.error("Error creating customer portal session:", error);
      throw new Error("Failed to create customer portal session");
    }
  },
});


================================================
FILE: convex/tsconfig.json
================================================
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}



================================================
FILE: convex/_generated/api.d.ts
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as auth from "../auth.js";
import type * as files from "../files.js";
import type * as helpers_common_auth from "../helpers/common/auth.js";
import type * as helpers_common_url from "../helpers/common/url.js";
import type * as helpers_profiles_utils from "../helpers/profiles/utils.js";
import type * as helpers_stripe_eventHelpers from "../helpers/stripe/eventHelpers.js";
import type * as helpers_stripe_paymentHelpers from "../helpers/stripe/paymentHelpers.js";
import type * as helpers_stripe_types from "../helpers/stripe/types.js";
import type * as helpers_subscriptions_limitHelpers from "../helpers/subscriptions/limitHelpers.js";
import type * as helpers_subscriptions_types from "../helpers/subscriptions/types.js";
import type * as helpers_subscriptions_validators from "../helpers/subscriptions/validators.js";
import type * as http from "../http.js";
import type * as items from "../items.js";
import type * as lib_plans from "../lib/plans.js";
import type * as lib_stripe from "../lib/stripe.js";
import type * as links from "../links.js";
import type * as payments from "../payments.js";
import type * as profileLayouts from "../profileLayouts.js";
import type * as profileTemplates from "../profileTemplates.js";
import type * as profileThemes from "../profileThemes.js";
import type * as profiles from "../profiles.js";
import type * as router from "../router.js";
import type * as seed_index from "../seed/index.js";
import type * as seed_profileTemplates from "../seed/profileTemplates.js";
import type * as seed_profileThemes from "../seed/profileThemes.js";
import type * as seed_seeder from "../seed/seeder.js";
import type * as stripe from "../stripe.js";
import type * as stripeConnect from "../stripeConnect.js";
import type * as subscriptions from "../subscriptions.js";
import type * as types_profileSections from "../types/profileSections.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  auth: typeof auth;
  files: typeof files;
  "helpers/common/auth": typeof helpers_common_auth;
  "helpers/common/url": typeof helpers_common_url;
  "helpers/profiles/utils": typeof helpers_profiles_utils;
  "helpers/stripe/eventHelpers": typeof helpers_stripe_eventHelpers;
  "helpers/stripe/paymentHelpers": typeof helpers_stripe_paymentHelpers;
  "helpers/stripe/types": typeof helpers_stripe_types;
  "helpers/subscriptions/limitHelpers": typeof helpers_subscriptions_limitHelpers;
  "helpers/subscriptions/types": typeof helpers_subscriptions_types;
  "helpers/subscriptions/validators": typeof helpers_subscriptions_validators;
  http: typeof http;
  items: typeof items;
  "lib/plans": typeof lib_plans;
  "lib/stripe": typeof lib_stripe;
  links: typeof links;
  payments: typeof payments;
  profileLayouts: typeof profileLayouts;
  profileTemplates: typeof profileTemplates;
  profileThemes: typeof profileThemes;
  profiles: typeof profiles;
  router: typeof router;
  "seed/index": typeof seed_index;
  "seed/profileTemplates": typeof seed_profileTemplates;
  "seed/profileThemes": typeof seed_profileThemes;
  "seed/seeder": typeof seed_seeder;
  stripe: typeof stripe;
  stripeConnect: typeof stripeConnect;
  subscriptions: typeof subscriptions;
  "types/profileSections": typeof types_profileSections;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;



================================================
FILE: convex/_generated/api.js
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;



================================================
FILE: convex/_generated/dataModel.d.ts
================================================
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;



================================================
FILE: convex/_generated/server.d.ts
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;



================================================
FILE: convex/_generated/server.js
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;



================================================
FILE: convex/helpers/common/auth.ts
================================================
import { Id, TableNames } from "../../_generated/dataModel";
import { getAuthUserId } from "@convex-dev/auth/server";
import { QueryCtx } from "../../_generated/server";

type ServerCtx = QueryCtx;

/**
 * Verifies that the user is authenticated
 * @param ctx - Convex context
 * @returns User ID if authenticated
 * @throws Error if not authenticated
 */
export async function requireAuth(ctx: ServerCtx) {
  const userId = await getAuthUserId(ctx);
  if (!userId) {
    throw new Error("Not authenticated");
  }
  return userId;
}

/**
 * Verifies that the user is authorized to access a resource
 * @param ctx - Convex context
 * @param resourceId - ID of the resource to check
 * @param tableName - Table name where the resource is stored
 * @param ownerField - Field name that contains the owner ID (default: "userId")
 * @returns The resource if authorized
 * @throws Error if not authorized
 */
export async function requireOwnership<T extends TableNames>(
  ctx: ServerCtx,
  resourceId: Id<T>,
  tableName: T,
  ownerField: string = "userId"
) {
  const userId = await requireAuth(ctx);
  const resource = await ctx.db.get(resourceId);

  if (!resource) {
    throw new Error("Resource not found");
  }

  if (resource[ownerField] !== userId) {
    throw new Error("Not authorized to access this resource");
  }

  return resource;
}

/**
 * Count the number of results from a specific index query
 * @param ctx - Convex context
 * @param tableName - Table name to query
 * @param indexName - Index name to use
 * @param filter - Filter criteria with field and value
 * @returns Number of matching records
 */
export async function countResultsFromIndex<T extends TableNames>(
  ctx: ServerCtx,
  tableName: T,
  indexName: string,
  filter: { field: string; value: any }
) {
  const results = await ctx.db
    .query(tableName)
    .withIndex(indexName, (q) => q.eq(filter.field, filter.value))
    .collect();
  
  return results.length;
}


================================================
FILE: convex/helpers/common/url.ts
================================================
export const BASE_URL =
  process.env.VERCEL_PROJECT_PRODUCTION_URL
    ? `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`
    : process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}`
      : "http://localhost:3000";


================================================
FILE: convex/helpers/profiles/utils.ts
================================================
import { DatabaseReader } from "../../_generated/server";

/**
 * Generates a random string with specified length
 * @param length - Length of the string to generate (default: 8)
 * @returns Random alphanumeric string
 */
export function generateRandomString(length = 8) {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

export async function getDefaultTheme(db: DatabaseReader) {
  const defaultTheme = await db
    .query("profileThemes")
    .filter((q) => q.eq(q.field("isDefault"), true))
    .first();

  if (!defaultTheme) {
    throw new Error("No default theme found. Please seed the database first.");
  }

  return defaultTheme;
}

export async function getDefaultTemplate(db: DatabaseReader) {
  const defaultTemplate = await db
    .query("profileTemplates")
    .filter((q) => q.eq(q.field("isDefault"), true))
    .first();

  if (!defaultTemplate) {
    throw new Error("No default template found. Please seed the database first.");
  }

  return defaultTemplate;
}


export interface Section {
  id: string;
  type: string;
  visible: boolean;
  order: number;
}

export function getDefaultSections(): Section[] {
  return [
    { id: "donation-section", type: "donation", visible: true, order: 1 },
    { id: "links-section", type: "links", visible: true, order: 2 },
    { id: "items-section", type: "items", visible: true, order: 3 },
  ];
}


================================================
FILE: convex/helpers/stripe/eventHelpers.ts
================================================
import Stripe from "stripe";

// List of Stripe events that we handle
export const allowedEvents: Stripe.Event.Type[] = [
  "checkout.session.completed",
  "customer.subscription.created",
  "customer.subscription.updated",
  "customer.subscription.deleted",
  "customer.subscription.paused",
  "customer.subscription.resumed",
  "customer.subscription.pending_update_applied",
  "customer.subscription.pending_update_expired",
  "customer.subscription.trial_will_end",
  "invoice.paid",
  "invoice.payment_failed",
  "invoice.payment_action_required",
  "invoice.upcoming",
  "invoice.marked_uncollectible",
  "invoice.payment_succeeded",
  "payment_intent.succeeded",
  "payment_intent.payment_failed",
  "payment_intent.canceled",
];


================================================
FILE: convex/helpers/stripe/paymentHelpers.ts
================================================
import Stripe from "stripe";
import { PlanType, SubscriptionPlan } from "../../lib/plans";

// Helper function to extract payment method details
export function extractPaymentMethod(paymentMethod: Stripe.PaymentMethod | string | null) {
  if (!paymentMethod || typeof paymentMethod === "string") {
    return null;
  }

  return {
    brand: paymentMethod.card?.brand ?? null,
    last4: paymentMethod.card?.last4 ?? null,
  };
}

// Helper function to map Stripe price to internal plan
export function mapStripePriceToInternalPlan(
  stripePriceId: string,
  unitAmount: number | null,
  metadata: Stripe.Metadata | null,
  SUBSCRIPTION_PLANS: Record<PlanType, SubscriptionPlan>
) {
  // Default to the original Stripe price ID
  let priceId = stripePriceId;
  let planType = null;

  // First try to determine plan from metadata
  if (metadata) {
    if (metadata.monolink_plan_type &&
      ["STARTER", "PRO", "BUSINESS"].includes(metadata.monolink_plan_type)) {
      planType = metadata.monolink_plan_type;
    } else if (metadata.planType &&
      ["STARTER", "PRO", "BUSINESS"].includes(metadata.planType)) {
      planType = metadata.planType;
    }
  }

  // If no plan type from metadata, determine by unit amount
  if (unitAmount && !planType) {
    if (unitAmount === SUBSCRIPTION_PLANS.STARTER.price) {
      priceId = SUBSCRIPTION_PLANS.STARTER.priceId;
      planType = "STARTER";
    } else if (unitAmount === SUBSCRIPTION_PLANS.PRO.price) {
      priceId = SUBSCRIPTION_PLANS.PRO.priceId;
      planType = "PRO";
    } else if (unitAmount === SUBSCRIPTION_PLANS.BUSINESS.price) {
      priceId = SUBSCRIPTION_PLANS.BUSINESS.priceId;
      planType = "BUSINESS";
    }
  }

  // If we have a plan type but no price ID mapping yet
  if (planType && priceId === stripePriceId) {
    switch (planType) {
      case "STARTER":
        priceId = SUBSCRIPTION_PLANS.STARTER.priceId;
        break;
      case "PRO":
        priceId = SUBSCRIPTION_PLANS.PRO.priceId;
        break;
      case "BUSINESS":
        priceId = SUBSCRIPTION_PLANS.BUSINESS.priceId;
        break;
    }
  }

  return { priceId, planType };
}


================================================
FILE: convex/helpers/stripe/types.ts
================================================
import Stripe from "stripe";

export interface SubscriptionWithPeriods extends Stripe.Subscription {
  current_period_end: number;
  current_period_start: number;
  cancel_at_period_end: boolean;
}


================================================
FILE: convex/helpers/subscriptions/limitHelpers.ts
================================================
import { DatabaseReader } from "../../_generated/server";
import { Id } from "../../_generated/dataModel";
import { PlanLimits, PlanType, SUBSCRIPTION_PLANS } from "../../lib/plans";

// Default limits for users without a subscription (free tier)
export const DEFAULT_LIMITS: PlanLimits = {
  profiles: 1,
  linksPerProfile: 5,
  itemsPerProfile: 2,
  customThemes: false,
  analytics: "basic",
  removeMonolinkBranding: false
};

// Export a function to get default limits that can be called from the client
export const getDefaultLimits = () => DEFAULT_LIMITS;

/**
 * Get limits for a user based on their subscription plan
 */
export async function getUserLimits(
  db: DatabaseReader,
  userId: Id<"users">
): Promise<PlanLimits> {
  // Get customer ID for the user
  const customer = await db
    .query("stripeCustomers")
    .withIndex("by_user", (q) => q.eq("userId", userId))
    .unique();

  if (!customer) {
    return DEFAULT_LIMITS;
  }

  // Get subscription for the customer
  const subscription = await db
    .query("stripeSubscriptions")
    .withIndex("by_customerId", (q) => q.eq("customerId", customer.stripeCustomerId))
    .unique();

  // Return default limits if no subscription or subscription is not active
  if (!subscription || !['active', 'trialing'].includes(subscription.status)) {
    return DEFAULT_LIMITS;
  }

  // Return the limits for the user's plan, or default if no valid plan type
  if (subscription.planType) {
    const planType = subscription.planType as PlanType;
    return SUBSCRIPTION_PLANS[planType].limits;
  }

  return DEFAULT_LIMITS;
}

/**
 * Check if a user has reached their profile limit
 */
export async function canCreateProfile(
  db: DatabaseReader,
  userId: Id<"users">
): Promise<{ allowed: boolean; current: number; limit: number }> {
  // Get user's limits
  const limits = await getUserLimits(db, userId);
  
  // Count existing profiles
  const profiles = await db
    .query("profiles")
    .withIndex("by_user", (q) => q.eq("userId", userId))
    .collect();
  
  const current = profiles.length;
  const limit = limits.profiles;
  
  return { 
    allowed: current < limit, 
    current, 
    limit 
  };
}

/**
 * Check if a profile has reached its link limit
 */
export async function canCreateLink(
  db: DatabaseReader,
  profileId: Id<"profiles">,
  userId: Id<"users">
): Promise<{ allowed: boolean; current: number; limit: number }> {
  // Get user's limits
  const limits = await getUserLimits(db, userId);
  
  // Count existing links for this profile
  const links = await db
    .query("links")
    .withIndex("by_profile", (q) => q.eq("profileId", profileId))
    .collect();
  
  const current = links.length;
  const limit = limits.linksPerProfile;
  
  return { 
    allowed: current < limit, 
    current, 
    limit 
  };
}

/**
 * Check if a profile has reached its item limit
 */
export async function canCreateItem(
  db: DatabaseReader,
  profileId: Id<"profiles">,
  userId: Id<"users">
): Promise<{ allowed: boolean; current: number; limit: number }> {
  // Get user's limits
  const limits = await getUserLimits(db, userId);
  
  // Count existing items for this profile
  const items = await db
    .query("items")
    .withIndex("by_profile", (q) => q.eq("profileId", profileId))
    .collect();
  
  const current = items.length;
  const limit = limits.itemsPerProfile;
  
  return { 
    allowed: current < limit, 
    current, 
    limit 
  };
}

/**
 * Check if a user can create custom themes
 */
export async function canUseCustomThemes(
  db: DatabaseReader,
  userId: Id<"users">
): Promise<boolean> {
  const limits = await getUserLimits(db, userId);
  return limits.customThemes;
}

/**
 * Check if a user can remove Monolink branding
 */
export async function canRemoveMonolinkBranding(
  db: DatabaseReader,
  userId: Id<"users">
): Promise<boolean> {
  const limits = await getUserLimits(db, userId);
  return limits.removeMonolinkBranding;
}


================================================
FILE: convex/helpers/subscriptions/types.ts
================================================
import { Id } from "../../_generated/dataModel";
import { PlanType, SubscriptionPlan } from "../../lib/plans";

/**
 * Type for subscription data returned from database
 */
export type SubscriptionData = {
  _id: Id<"stripeSubscriptions">;
  customerId: string;
  subscriptionId?: string;
  status: string;
  priceId?: string;
  planType?: PlanType;
  currentPeriodStart?: number;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  paymentMethod?: {
    brand?: string;
    last4?: string;
  };
};

/**
 * Type for the subscription result
 */
export type SubscriptionResult = Omit<SubscriptionData, 'planType'> & {
  planType: PlanType | null;
  plan: SubscriptionPlan | null;
};


================================================
FILE: convex/helpers/subscriptions/validators.ts
================================================
import { v } from "convex/values";
import { PLAN_TYPES } from "../../lib/plans";

export const planTypeValidator = v.union(
  ...PLAN_TYPES.map((key) => v.literal(key))
);



================================================
FILE: convex/lib/plans.ts
================================================
export type PlanType = "STARTER" | "PRO" | "BUSINESS";

export interface PlanLimits {
  profiles: number;
  linksPerProfile: number;
  itemsPerProfile: number;
  customThemes: boolean;
  analytics: "basic" | "advanced" | "enterprise";
  removeMonolinkBranding: boolean;
}

export interface SubscriptionPlan {
  name: string;
  price: number;
  priceId: string;
  features: string[];
  limits: PlanLimits;
};

export const SUBSCRIPTION_PLANS: Record<PlanType, SubscriptionPlan> = {
  STARTER: {
    name: "Starter",
    price: 900,
    priceId: "price_1RNUdJI6RlBGcwzl21lO7zKX",
    features: [
      "Custom profile URL",
      "Up to 10 links",
      "Basic analytics",
      "Standard themes"
    ],
    limits: {
      profiles: 1,
      linksPerProfile: 10,
      itemsPerProfile: 5,
      customThemes: false,
      analytics: "basic",
      removeMonolinkBranding: false
    }
  },
  PRO: {
    name: "Pro",
    price: 1900,
    priceId: "price_1RNUdJI6RlBGcwzleVvbsWNS",
    features: [
      "Everything in Starter",
      "Unlimited links",
      "Advanced analytics",
      "Premium themes",
      "Remove branding",
      "Priority support"
    ],
    limits: {
      profiles: 3,
      linksPerProfile: 50,
      itemsPerProfile: 20,
      customThemes: true,
      analytics: "advanced",
      removeMonolinkBranding: true
    }
  },
  BUSINESS: {
    name: "Business",
    price: 4900,
    priceId: "price_1RNUdJI6RlBGcwzl8XxdJX35",
    features: [
      "Everything in Pro",
      "Team accounts (up to 5)",
      "Custom domain",
      "White label solution",
      "API access"
    ],
    limits: {
      profiles: 10,
      linksPerProfile: 100,
      itemsPerProfile: 50,
      customThemes: true,
      analytics: "enterprise",
      removeMonolinkBranding: true
    }
  },
};

export const PLAN_TYPES = Object.keys(SUBSCRIPTION_PLANS) as PlanType[];


================================================
FILE: convex/lib/stripe.ts
================================================
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY environment variable is not set");
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-04-30.basil",
});


================================================
FILE: convex/seed/index.ts
================================================
export * from "./profileTemplates";
export * from "./seeder";


================================================
FILE: convex/seed/profileTemplates.ts
================================================
/**
 * This file contains default template data used for initializing templates
 */

/**
 * Default template with basic components
 */
export const defaultTemplate = {
  name: "Standard Profile",
  description: "A clean, standard profile layout with all essential components",
  isPublic: true,
  isDefault: true,
  category: "minimal",
  components: [
    {
      type: "header",
      order: 0,
      isEnabled: true,
      settings: {
        showAvatar: true,
        avatarSize: "medium",
        showBio: true,
        alignment: "center",
        showSocial: false
      }
    },
    {
      type: "links",
      order: 1,
      isEnabled: true,
      settings: {
        layout: "list",
        buttonStyle: "filled",
        showIcons: true,
        animation: "none"
      }
    },
    {
      type: "donation",
      order: 2,
      isEnabled: true,
      settings: {
        showButton: true,
        buttonText: "Support Me",
        showSuggestedAmounts: true,
        suggestedAmounts: [5, 10, 20]
      }
    },
    {
      type: "bio",
      order: 3,
      isEnabled: true,
      settings: {
        showTitle: true,
        titleText: "About Me",
        maxLength: 150,
        showReadMore: true
      }
    }
  ],
  customizations: {
    spacing: {
      cardPadding: "medium",
      elementSpacing: "md",
      sectionSpacing: "standard"
    },
    shape: {
      cardBorderRadius: "medium",
      buttonBorderRadius: "medium",
      imageBorderRadius: "full"
    },
    shadows: {
      cardShadow: "medium",
      buttonShadow: "small"
    }
  }
};

/**
 * Business template focused on professional presentation
 */
export const businessTemplate = {
  name: "Business Profile",
  description: "Professional layout optimized for business users",
  isPublic: true,
  isDefault: false,
  category: "business",
  components: [
    {
      type: "header",
      order: 0,
      isEnabled: true,
      settings: {
        showAvatar: true,
        avatarSize: "large",
        showBio: true,
        alignment: "left",
        showSocial: true
      }
    },
    {
      type: "bio",
      order: 1,
      isEnabled: true,
      settings: {
        showTitle: true,
        titleText: "About Us",
        maxLength: 200,
        showReadMore: true
      }
    },
    {
      type: "links",
      order: 2,
      isEnabled: true,
      settings: {
        layout: "grid",
        buttonStyle: "outlined",
        showIcons: true,
        animation: "fade"
      }
    },
    {
      type: "contact",
      order: 3,
      isEnabled: true,
      settings: {
        showTitle: true,
        titleText: "Get In Touch",
        fields: ["name", "email", "message"],
        buttonText: "Send Message"
      }
    }
  ],
  customizations: {
    fonts: {
      heading: "montserrat",
      body: "inter"
    },
    spacing: {
      cardPadding: "large",
      elementSpacing: "lg",
      sectionSpacing: "comfortable"
    },
    shape: {
      cardBorderRadius: "small",
      buttonBorderRadius: "small"
    },
    shadows: {
      cardShadow: "small"
    }
  }
};

/**
 * Creator template optimized for content creators
 */
export const creatorTemplate = {
  name: "Creator Profile",
  description: "Dynamic layout for content creators and influencers",
  isPublic: true,
  isDefault: false,
  category: "creator",
  components: [
    {
      type: "header",
      order: 0,
      isEnabled: true,
      settings: {
        showAvatar: true,
        avatarSize: "large",
        showBio: true,
        alignment: "center",
        showSocial: true
      }
    },
    {
      type: "links",
      order: 1,
      isEnabled: true,
      settings: {
        layout: "list",
        buttonStyle: "filled",
        showIcons: true,
        animation: "bounce"
      }
    },
    {
      type: "gallery",
      order: 2,
      isEnabled: true,
      settings: {
        layout: "grid",
        itemsPerRow: 3,
        showCaptions: true,
        aspectRatio: "square"
      }
    },
    {
      type: "donation",
      order: 3,
      isEnabled: true,
      settings: {
        showButton: true,
        buttonText: "Support My Work",
        description: "Help me continue creating great content!",
        showSuggestedAmounts: true,
        suggestedAmounts: [5, 10, 25, 50]
      }
    }
  ],
  customizations: {
    fonts: {
      heading: "playfair",
      body: "roboto"
    },
    spacing: {
      cardPadding: "medium",
      elementSpacing: "md"
    },
    shape: {
      cardBorderRadius: "medium",
      buttonBorderRadius: "full"
    },
    shadows: {
      cardShadow: "large",
      buttonShadow: "medium"
    }
  }
};


================================================
FILE: convex/seed/profileThemes.ts
================================================

/**
 * Default theme with basic styling
 */
export const defaultTheme = {
  name: "Default Theme",
  description: "A clean, simple theme with basic styling",
  isPublic: true,
  isDefault: true,
  settings: {
    color: "blue",
    style: "minimal",
    layout: "standard"
  },
  previewImage: undefined,
  createdAt: Date.now()
};


================================================
FILE: convex/seed/seeder.ts
================================================
import { DatabaseWriter, internalMutation } from "../_generated/server";
import { defaultTemplate, businessTemplate, creatorTemplate } from "./profileTemplates";
import { defaultTheme } from "./profileThemes";

export const seedAll = internalMutation({
  handler: async (ctx) => {
    const db = ctx.db;
    const results = {
      profileTemplates: await seedProfileTemplates(db),
      profileThemes: await seedProfileThemes(db)
    };

    return results;
  }
});

export const profileTemplates = internalMutation({
  handler: async (ctx) => {
    return await seedProfileTemplates(ctx.db);
  }
});

export const themes = internalMutation({
  handler: async (ctx) => {
    return await seedProfileThemes(ctx.db);
  }
});

async function seedProfileTemplates(db: DatabaseWriter) {
  // Check if there are already templates in the database
  const existingTemplates = await db.query("profileTemplates").collect();

  if (existingTemplates.length === 0) {
    console.log("Seeding default templates...");

    // Insert default template
    const timestamp = Date.now();

    await db.insert("profileTemplates", {
      ...defaultTemplate,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    await db.insert("profileTemplates", {
      ...businessTemplate,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    await db.insert("profileTemplates", {
      ...creatorTemplate,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    console.log("Default templates seeded successfully");
    return { success: true, templatesAdded: 3 };
  } else {
    console.log("Templates already exist, skipping seed");
    return { success: true, templatesAdded: 0 };
  }
}

async function seedProfileThemes(db: DatabaseWriter) {
  // Check if there are already themes in the database
  const existingThemes = await db.query("profileThemes").collect();

  if (existingThemes.length === 0) {
    console.log("Seeding default themes...");

    // Insert default theme
    const timestamp = Date.now();
    const defaultThemeId = await db.insert("profileThemes", {
      ...defaultTheme,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    console.log("Default themes seeded successfully");
    return {
      success: true,
      themesAdded: 1,
      defaultThemeId
    };
  } else {
    // Find default theme if it exists
    const defaultThemeRecord = await db
      .query("profileThemes")
      .filter(q => q.eq(q.field("isDefault"), true))
      .first();

    const defaultThemeId = defaultThemeRecord?._id;

    console.log("Themes already exist, skipping seed");
    return {
      success: true,
      themesAdded: 0,
      defaultThemeId
    };
  }
}


================================================
FILE: convex/types/profileSections.ts
================================================
import { v } from "convex/values";

export const sectionType = v.union(
  v.literal("avatar"),
  v.literal("links"),
  v.literal("items"),
  v.literal("donation")
);

export type SectionType = "avatar" | "links" | "items" | "donation";

export const sectionConfig = v.object({
  id: v.string(),
  type: sectionType,
  visible: v.boolean(),
  order: v.number(),
});

export type SectionConfig = {
  id: string;
  type: SectionType;
  visible: boolean;
  order: number;
};


================================================
FILE: hooks/useFileUpload.ts
================================================
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

export function useFileUpload() {
  const generateUploadUrl = useMutation(api.items.generateUploadUrl);

  const uploadFile = async (
    file: File,
    onProgress?: (percent: number) => void
  ) => {
    const uploadUrl = await generateUploadUrl();

    return new Promise<Id<"_storage">>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", uploadUrl);

      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable && onProgress) {
          const percent = Math.round((event.loaded / event.total) * 100);
          onProgress(percent);
        }
      };

      xhr.onload = () => {
        if (xhr.status === 200) {
          const { storageId } = JSON.parse(xhr.responseText);
          resolve(storageId);
        } else {
          reject(new Error("Upload failed"));
        }
      };

      xhr.onerror = () => reject(new Error("Upload failed"));
      xhr.setRequestHeader("Content-Type", file.type);
      xhr.send(file);
    });
  };

  return { uploadFile };
}


================================================
FILE: hooks/usePlanLimits.ts
================================================
import { useQuery } from 'convex/react';
import { api } from '@/convex/_generated/api';
import { Id } from '@/convex/_generated/dataModel';
import { DEFAULT_LIMITS } from '@/convex/helpers/subscriptions/limitHelpers';

/**
 * Hook to check if user can create more profiles based on their subscription
 */
export function useProfileLimits() {
  const profiles = useQuery(api.profiles.listByUser, {});
  const subscription = useQuery(api.subscriptions.getUserSubscription, {});

  const limits = subscription?.plan?.limits || DEFAULT_LIMITS;
  const currentCount = profiles?.length || 0;
  const maxProfiles = limits.profiles;

  return {
    canCreate: currentCount < maxProfiles,
    currentCount,
    maxProfiles,
    percentUsed: Math.round((currentCount / maxProfiles) * 100),
    remainingCount: maxProfiles - currentCount,
    isLoading: profiles === undefined || subscription === undefined
  };
}

/**
 * Hook to check if user can create more links on a specific profile
 */
export function useLinkLimits(profileId?: Id<"profiles">) {
  const links = useQuery(api.links.list, profileId ? { profileId } : "skip");
  const subscription = useQuery(api.subscriptions.getUserSubscription, {});

  const limits = subscription?.plan?.limits || DEFAULT_LIMITS;
  const currentCount = links?.length || 0;
  const maxLinks = limits.linksPerProfile;

  return {
    canCreate: currentCount < maxLinks,
    currentCount,
    maxLinks,
    percentUsed: Math.round((currentCount / maxLinks) * 100),
    remainingCount: maxLinks - currentCount,
    isLoading: links === undefined || subscription === undefined
  };
}

/**
 * Hook to check if user can create more items on a specific profile
 */
export function useItemLimits(profileId?: Id<"profiles">) {
  const items = useQuery(api.items.list, profileId ? { profileId } : "skip");
  const subscription = useQuery(api.subscriptions.getUserSubscription, {});

  const limits = subscription?.plan?.limits || DEFAULT_LIMITS;
  const currentCount = items?.length || 0;
  const maxItems = limits.itemsPerProfile;

  return {
    canCreate: currentCount < maxItems,
    currentCount,
    maxItems,
    percentUsed: Math.round((currentCount / maxItems) * 100),
    remainingCount: maxItems - currentCount,
    isLoading: items === undefined || subscription === undefined
  };
}


================================================
FILE: lib/server-functions.ts
================================================
"use server"

import { api } from "@/convex/_generated/api";
import { convexAuthNextjsToken, isAuthenticatedNextjs } from "@convex-dev/auth/nextjs/server";
import { fetchQuery } from "convex/nextjs";

export async function isAuthenticated() {
  return await isAuthenticatedNextjs();
}

export async function fetchUserProfiles() {
  const token = await convexAuthNextjsToken();

  const profiles = await fetchQuery(api.profiles.listByUser, {}, { token });

  return profiles;
}



================================================
FILE: lib/template-mappings.ts
================================================
/**
 * This file contains Tailwind class mappings for different template combinations
 */
import { TemplateCustomizations } from '@/types/template';

/**
 * Generate container classes based on template customizations
 */
export function getContainerClasses(customizations?: TemplateCustomizations): string {
  let classes = 'w-full';

  // Apply spacing
  if (customizations?.spacing?.cardPadding) {
    switch (customizations.spacing.cardPadding) {
      case 'none': classes += ' p-0'; break;
      case 'small': classes += ' p-2'; break;
      case 'medium': classes += ' p-4'; break;
      case 'large': classes += ' p-6'; break;
      case 'xlarge': classes += ' p-8'; break;
      default: classes += ' p-4'; // Default medium padding
    }
  } else {
    classes += ' p-4'; // Default medium padding
  }

  // Apply border radius
  if (customizations?.shape?.cardBorderRadius) {
    switch (customizations.shape.cardBorderRadius) {
      case 'none': classes += ' rounded-none'; break;
      case 'small': classes += ' rounded-sm'; break;
      case 'medium': classes += ' rounded-md'; break;
      case 'large': classes += ' rounded-lg'; break;
      case 'full': classes += ' rounded-full'; break;
      default: classes += ' rounded-md'; // Default medium radius
    }
  } else {
    classes += ' rounded-md'; // Default medium radius
  }

  // Apply shadows
  if (customizations?.shadows?.cardShadow) {
    switch (customizations.shadows.cardShadow) {
      case 'none': classes += ' shadow-none'; break;
      case 'small': classes += ' shadow-sm'; break;
      case 'medium': classes += ' shadow'; break;
      case 'large': classes += ' shadow-lg'; break;
      case 'xl': classes += ' shadow-xl'; break;
      default: classes += ' shadow'; // Default medium shadow
    }
  } else {
    classes += ' shadow'; // Default medium shadow
  }

  return classes;
}

/**
 * Generate button classes based purely on template customizations
 * (without theme color considerations)
 */
export function getButtonClasses(
  customizations?: TemplateCustomizations
): string {
  // Start with basic button classes
  let classes = 'w-full transition font-medium text-center py-2.5';

  // Apply border radius from customizations
  if (customizations?.shape?.buttonBorderRadius) {
    switch (customizations.shape.buttonBorderRadius) {
      case 'none': classes += ' rounded-none'; break;
      case 'small': classes += ' rounded-sm'; break;
      case 'medium': classes += ' rounded-md'; break;
      case 'large': classes += ' rounded-lg'; break;
      case 'full': classes += ' rounded-full'; break;
      default: classes += ' rounded-md';
    }
  } else {
    classes += ' rounded-md'; // Default
  }

  // Apply shadow from customizations
  if (customizations?.shadows?.buttonShadow) {
    switch (customizations.shadows.buttonShadow) {
      case 'none': classes += ' shadow-none'; break;
      case 'small': classes += ' shadow-sm'; break;
      case 'medium': classes += ' shadow'; break;
      case 'large': classes += ' shadow-lg'; break;
      default: classes += ' shadow';
    }
  } else {
    classes += ' shadow'; // Default
  }

  return classes;
}

/**
 * Generate font classes based on template customizations
 */
export function getFontClasses(type: 'heading' | 'body' | 'display', customizations?: TemplateCustomizations): string {
  let classes = '';

  if (!customizations?.fonts) {
    // Default fonts if none specified
    switch (type) {
      case 'heading':
        return 'font-sans font-bold';
      case 'body':
        return 'font-sans';
      case 'display':
        return 'font-sans font-extrabold';
    }
  }

  // Apply font family based on customizations
  const fontFamily = customizations.fonts[type];
  if (fontFamily) {
    // This mapping would depend on what fonts you've registered in your app
    switch (fontFamily) {
      case 'inter':
        classes += ' font-sans'; break;
      case 'roboto':
        classes += ' font-roboto'; break;
      case 'playfair':
        classes += ' font-playfair'; break;
      case 'montserrat':
        classes += ' font-montserrat'; break;
      case 'oswald':
        classes += ' font-oswald'; break;
      default:
        classes += ' font-sans'; // Default
    }
  } else {
    classes += ' font-sans'; // Default sans
  }

  // Add font weight based on type
  switch (type) {
    case 'heading':
      classes += ' font-bold';
      break;
    case 'body':
      classes += ' font-normal';
      break;
    case 'display':
      classes += ' font-extrabold';
      break;
  }

  return classes;
}

/**
 * Generate spacing classes based on template customizations
 */
export function getSpacingClasses(customizations?: TemplateCustomizations): string {
  if (!customizations?.spacing?.elementSpacing) {
    return 'space-y-4'; // Default spacing
  }

  switch (customizations.spacing.elementSpacing) {
    case 'none': return 'space-y-0';
    case 'xs': return 'space-y-1';
    case 'sm': return 'space-y-2';
    case 'md': return 'space-y-4';
    case 'lg': return 'space-y-6';
    case 'xl': return 'space-y-8';
    case '2xl': return 'space-y-12';
    default: return 'space-y-4';
  }
}




================================================
FILE: lib/theme-defaults.ts
================================================
/**
 * Default theme settings and utilities for themes
 */
import { ThemeSettings, ProfileTheme } from '@/types/theme';
import { normalizeThemeSettings } from './theme-mappings';

/**
 * Create a default ThemeSettings object
 */
export function getDefaultThemeSettings(): ThemeSettings {
  return {
    color: 'blue',
    style: 'minimal',
    layout: 'standard'
  };
}

/**
 * Get theme settings from a theme, with validation
 */
export function getThemeSettings(theme: ProfileTheme): ThemeSettings {
  if (!theme || !theme.settings) {
    return getDefaultThemeSettings();
  }

  return normalizeThemeSettings(theme.settings);
}


================================================
FILE: lib/theme-mappings.ts
================================================
/**
 * This file contains Tailwind class mappings for different theme combinations
 */
import { ThemeColor, ThemeSettings, themeSettingsSchema } from '@/types/theme';
import { TemplateCustomizations } from '@/types/template';
import { Doc } from '@/convex/_generated/dataModel';

/**
 * Validate and normalize theme settings
 */
export function normalizeThemeSettings(settings: Doc<"profileThemes">["settings"]): ThemeSettings {
  try {
    // Use the schema to validate and parse the input
    return themeSettingsSchema.parse(settings);
  } catch {
    // If validation fails, return default values
    return {
      color: 'default',
      style: 'minimal',
      layout: 'standard',
    };
  }
}

/**
 * Generate profile card classes based on theme themeSettings
 */
export function getProfileCardClasses(themeSettings: Doc<"profileThemes">["settings"]): string {
  // Normalize theme settings first
  const normalizedSettings = normalizeThemeSettings(themeSettings);
  // Base classes always applied
  let classes = '';

  // Add padding based on layout
  if (normalizedSettings.layout === 'compact') {
    classes += ' p-4';
  } else if (normalizedSettings.layout === 'expanded') {
    classes += ' p-8';
  } else {
    // standard
    classes += ' p-6';
  }

  // Apply style-specific classes
  switch (normalizedSettings.style) {
    case 'gradient':
      classes += ` ${getGradientBackground(normalizedSettings.color)}`;
      break;
    case 'soft':
      classes += ' bg-background/90 backdrop-blur-sm';
      break;
    case 'outlined':
      classes += ' border-2 border-border bg-background';
      if (normalizedSettings.color === 'blue') classes += ' border-blue-200';
      else if (normalizedSettings.color === 'purple') classes += ' border-purple-200';
      else if (normalizedSettings.color === 'green') classes += ' border-green-200';
      else if (normalizedSettings.color === 'pink') classes += ' border-pink-200';
      else if (normalizedSettings.color === 'orange') classes += ' border-orange-200';
      else classes += ' border-indigo-200';
      break;
    case 'minimal':
    default:
      classes += ' bg-background';
      break;
  }

  return classes;
}

/**
 * Generate avatar class based on theme themeSettings
 */
export function getAvatarClasses(themeSettings: Doc<"profileThemes">["settings"]): string {
  // Normalize theme settings first
  const normalizedSettings = normalizeThemeSettings(themeSettings);

  let classes = 'object-cover border-4 border-border rounded-full shadow';

  // Size based on layout
  if (normalizedSettings.layout === 'compact') {
    classes += ' w-16 h-16';
  } else if (normalizedSettings.layout === 'expanded') {
    classes += ' w-28 h-28';
  } else {
    // standard
    classes += ' w-24 h-24';
  }

  // Border color based on theme color
  if (normalizedSettings.color === 'blue') classes += ' border-blue-100';
  else if (normalizedSettings.color === 'purple') classes += ' border-purple-100';
  else if (normalizedSettings.color === 'green') classes += ' border-green-100';
  else if (normalizedSettings.color === 'pink') classes += ' border-pink-100';
  else if (normalizedSettings.color === 'orange') classes += ' border-orange-100';
  else classes += ' border-indigo-100';

  return classes;
}

/**
 * Generate avatar placeholder classes based on theme themeSettings
 */
export function getAvatarPlaceholderClasses(themeSettings: Doc<"profileThemes">["settings"]): string {
  // Normalize theme settings first
  const normalizedSettings = normalizeThemeSettings(themeSettings);

  let classes = 'flex items-center justify-center bg-background border-4 border-border rounded-full shadow';

  // Size based on layout
  if (normalizedSettings.layout === 'compact') {
    classes += ' w-16 h-16';
  } else if (normalizedSettings.layout === 'expanded') {
    classes += ' w-28 h-28';
  } else {
    // standard
    classes += ' w-24 h-24';
  }

  // Border color based on theme color
  if (normalizedSettings.color === 'blue') classes += ' border-blue-100';
  else if (normalizedSettings.color === 'purple') classes += ' border-purple-100';
  else if (normalizedSettings.color === 'green') classes += ' border-green-100';
  else if (normalizedSettings.color === 'pink') classes += ' border-pink-100';
  else if (normalizedSettings.color === 'orange') classes += ' border-orange-100';
  else classes += ' border-indigo-100';

  return classes;
}

/**
 * Generate link button classes based on theme themeSettings
 */
export function getLinkButtonClasses(
  themeSettings: Doc<"profileThemes">["settings"],
  buttonStyle: string = 'filled',
  customizations?: TemplateCustomizations
): string {
  // Normalize theme settings first
  const normalizedSettings = normalizeThemeSettings(themeSettings);

  let classes = 'font-semibold text-center transition hover:opacity-90';

  // Apply custom button border-radius if specified
  if (customizations?.shape?.buttonBorderRadius) {
    classes += ` rounded-${customizations.shape.buttonBorderRadius}`;
  } else {
    classes += ' rounded-md';
  }

  // Apply style variations
  if (normalizedSettings.style === 'soft' || buttonStyle === 'subtle') {
    // Soft style = light background, dark text
    if (normalizedSettings.color === 'blue') {
      classes += ' bg-blue-100 text-blue-800 hover:bg-blue-200';
    } else if (normalizedSettings.color === 'purple') {
      classes += ' bg-purple-100 text-purple-800 hover:bg-purple-200';
    } else if (normalizedSettings.color === 'green') {
      classes += ' bg-green-100 text-green-800 hover:bg-green-200';
    } else if (normalizedSettings.color === 'pink') {
      classes += ' bg-pink-100 text-pink-800 hover:bg-pink-200';
    } else if (normalizedSettings.color === 'orange') {
      classes += ' bg-orange-100 text-orange-800 hover:bg-orange-200';
    } else {
      classes += ' bg-indigo-100 text-indigo-800 hover:bg-indigo-200';
    }
  } else if (normalizedSettings.style === 'outlined' || buttonStyle === 'outlined') {
    // Outlined style = transparent bg, border, colored text
    if (normalizedSettings.color === 'blue') {
      classes += ' bg-transparent border-2 border-blue-500 text-blue-700 hover:bg-blue-50';
    } else if (normalizedSettings.color === 'purple') {
      classes += ' bg-transparent border-2 border-purple-500 text-purple-700 hover:bg-purple-50';
    } else if (normalizedSettings.color === 'green') {
      classes += ' bg-transparent border-2 border-green-500 text-green-700 hover:bg-green-50';
    } else if (normalizedSettings.color === 'pink') {
      classes += ' bg-transparent border-2 border-pink-500 text-pink-700 hover:bg-pink-50';
    } else if (normalizedSettings.color === 'orange') {
      classes += ' bg-transparent border-2 border-orange-500 text-orange-700 hover:bg-orange-50';
    } else {
      classes += ' bg-transparent border-2 border-indigo-500 text-indigo-700 hover:bg-indigo-50';
    }
  } else if (buttonStyle === 'text') {
    // Text style = no bg, no border, just text
    if (normalizedSettings.color === 'blue') {
      classes += ' bg-transparent text-blue-700 hover:bg-blue-50 shadow-none';
    } else if (normalizedSettings.color === 'purple') {
      classes += ' bg-transparent text-purple-700 hover:bg-purple-50 shadow-none';
    } else if (normalizedSettings.color === 'green') {
      classes += ' bg-transparent text-green-700 hover:bg-green-50 shadow-none';
    } else if (normalizedSettings.color === 'pink') {
      classes += ' bg-transparent text-pink-700 hover:bg-pink-50 shadow-none';
    } else if (normalizedSettings.color === 'orange') {
      classes += ' bg-transparent text-orange-700 hover:bg-orange-50 shadow-none';
    } else {
      classes += ' bg-transparent text-indigo-700 hover:bg-indigo-50 shadow-none';
    }
  } else {
    // Default/minimal/gradient/filled = solid color bg, white text
    if (normalizedSettings.color === 'blue') {
      classes += ' bg-blue-500 text-white hover:bg-blue-600';
    } else if (normalizedSettings.color === 'purple') {
      classes += ' bg-purple-500 text-white hover:bg-purple-600';
    } else if (normalizedSettings.color === 'green') {
      classes += ' bg-green-500 text-white hover:bg-green-600';
    } else if (normalizedSettings.color === 'pink') {
      classes += ' bg-pink-500 text-white hover:bg-pink-600';
    } else if (normalizedSettings.color === 'orange') {
      classes += ' bg-orange-500 text-white hover:bg-orange-600';
    } else {
      classes += ' bg-indigo-500 text-white hover:bg-indigo-600';
    }
  }

  // Apply padding
  if (buttonStyle === 'text') {
    classes += ' py-2 px-3'; // Less padding for text buttons
  } else {
    classes += ' py-3 px-4'; // Standard padding
  }

  // Add custom shadow if specified
  if (customizations?.shadows?.buttonShadow && buttonStyle !== 'text') {
    classes += ` ${customizations.shadows.buttonShadow}`;
  }

  return classes;
}

/**
 * Generate item card classes based on theme themeSettings
 */
export function getItemCardClasses(themeSettings: Doc<"profileThemes">["settings"]): string {
  // Normalize theme settings first
  const normalizedSettings = normalizeThemeSettings(themeSettings);

  let classes = '';

  if (normalizedSettings.style === 'soft') {
    classes = 'bg-background/80 backdrop-blur-sm';
  } else if (normalizedSettings.style === 'outlined') {
    if (normalizedSettings.color === 'blue') {
      classes = 'border-blue-200';
    } else if (normalizedSettings.color === 'purple') {
      classes = 'border-purple-200';
    } else if (normalizedSettings.color === 'green') {
      classes = 'border-green-200';
    } else if (normalizedSettings.color === 'pink') {
      classes = 'border-pink-200';
    } else if (normalizedSettings.color === 'orange') {
      classes = 'border-orange-200';
    } else {
      classes = 'border-indigo-200';
    }
  }

  return classes;
}

/**
 * Get font classes based on customizations
 */
export function getFontClasses(
  type: 'heading' | 'body' | 'display',
  customizations?: TemplateCustomizations
): string {
  if (!customizations?.fonts) return '';

  if (type === 'heading' && customizations.fonts.heading) {
    return `font-${customizations.fonts.heading}`;
  }
  if (type === 'body' && customizations.fonts.body) {
    return `font-${customizations.fonts.body}`;
  }
  if (type === 'display' && customizations.fonts.display) {
    return `font-${customizations.fonts.display}`;
  }

  return '';
}

/**
 * Get gradient background classes based on color
 * This is a private helper function
 */
function getGradientBackground(themeColor: ThemeColor): string {
  switch (themeColor) {
    case 'blue':
      return 'bg-gradient-to-b from-blue-100 to-white';
    case 'purple':
      return 'bg-gradient-to-b from-purple-100 to-white';
    case 'green':
      return 'bg-gradient-to-b from-green-100 to-white';
    case 'pink':
      return 'bg-gradient-to-b from-pink-100 to-white';
    case 'orange':
      return 'bg-gradient-to-b from-orange-100 to-white';
    default:
      return 'bg-gradient-to-b from-indigo-100 to-white';
  }
}


================================================
FILE: lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function toKebabCase(str: string) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-') // Replace spaces and non-alphanumerics with hyphens
    .replace(/--+/g, '-')        // Replace multiple hyphens with one
}

export const BASE_URL =
  process.env.VERCEL_PROJECT_PRODUCTION_URL
    ? `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`
    : process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}`
      : "http://localhost:3000";


================================================
FILE: types/profile.ts
================================================
/**
 * Profile-related type definitions
 */
import { Doc } from "@/convex/_generated/dataModel";

/**
 * Basic profile interface that leverages Convex generated types
 * This is a direct mapping to the Convex 'profiles' table
 */
export type Profile = Doc<"profiles">;

export type Section = Doc<"profiles">["componentSettings"]["section"]

/**
 * Profile with theme information
 * Used when displaying a profile with its theme
 */
export interface ProfileWithThemeAndTemplate extends Profile {
  theme: Doc<"profileThemes">;
  template: Doc<"profileTemplates">
}

/**
 * Profile with theme, links, items, and section layout
 * Used for comprehensive profile display
 */
export interface ProfileComplete extends Profile {
  theme: Doc<"profileThemes">;
  template: Doc<"profileTemplates">;
  items: Doc<"items">[];
  links: Doc<"links">[];
  sections: Section[];
  hasStripeConnected: boolean;
}

/**
 * Profile with stats
 * Used for analytics and dashboard displays
 */
export interface ProfileWithStats extends Profile {
  stats?: {
    views?: number;
    links?: number;
    items?: number;
  };
  theme: Doc<"profileThemes">;
}


================================================
FILE: types/template.ts
================================================
/**
 * Template-related type definitions
 */

export interface TemplateCustomizations {
  fonts?: {
    heading?: string;
    body?: string;
    display?: string;
  };
  spacing?: {
    cardPadding?: string;
    elementSpacing?: string;
    sectionSpacing?: string;
  };
  shape?: {
    cardBorderRadius?: string;
    buttonBorderRadius?: string;
    imageBorderRadius?: string;
  };
  shadows?: {
    cardShadow?: string;
    buttonShadow?: string;
  };
  customCss?: string;
}

// Component-specific setting types
export interface HeaderComponentSettings {
  showAvatar: boolean;
  avatarSize: 'small' | 'medium' | 'large';
  showBio: boolean;
  alignment: 'left' | 'center' | 'right';
  showSocial: boolean;
}

export interface LinksComponentSettings {
  layout: 'list' | 'grid' | 'compact';
  buttonStyle: 'filled' | 'outlined' | 'subtle' | 'text';
  showIcons: boolean;
  animation: 'none' | 'fade' | 'slide' | 'bounce';
}

export interface GalleryComponentSettings {
  layout: 'grid' | 'carousel' | 'masonry';
  itemsPerRow: 1 | 2 | 3 | 4;
  showCaptions: boolean;
  aspectRatio: 'square' | 'landscape' | 'portrait' | 'original';
}

export interface DonationComponentSettings {
  showButton: boolean;
  buttonText: string;
  description?: string;
  showSuggestedAmounts: boolean;
  suggestedAmounts?: number[];
}

export interface BioComponentSettings {
  showTitle: boolean;
  titleText?: string;
  maxLength?: number;
  showReadMore: boolean;
}

export interface SocialComponentSettings {
  layout: 'horizontal' | 'vertical' | 'grid';
  showLabels: boolean;
  iconSize: 'small' | 'medium' | 'large';
}

export interface ItemsComponentSettings {
  layout: 'grid' | 'list' | 'carousel';
  itemsPerRow: 1 | 2 | 3;
  showPrices: boolean;
  showDescriptions: boolean;
}

export interface ContactComponentSettings {
  showTitle: boolean;
  titleText?: string;
  fields: Array<'name' | 'email' | 'message' | 'phone'>;
  buttonText: string;
}


================================================
FILE: types/theme.ts
================================================
/**
 * Theme-related type definitions
 */
import { Doc } from "@/convex/_generated/dataModel";
import { z } from "zod";

/**
 * Define schema objects for theme settings
 */
const themeColorSchema = z.enum(['default', 'blue', 'purple', 'green', 'pink', 'orange']);
const themeStyleSchema = z.enum(['minimal', 'gradient', 'soft', 'outlined']);
const layoutStyleSchema = z.enum(['standard', 'compact', 'expanded']);

/**
 * Theme settings schema
 */
export const themeSettingsSchema = z.object({
  color: themeColorSchema.default('default'),
  style: themeStyleSchema.default('minimal'),
  layout: layoutStyleSchema.default('standard'),
}).passthrough(); // Allow additional properties

/**
 * Derived TypeScript types
 */
export type ThemeColor = z.infer<typeof themeColorSchema>;
export type ThemeStyle = z.infer<typeof themeStyleSchema>;
export type LayoutStyle = z.infer<typeof layoutStyleSchema>;
export type ThemeSettings = z.infer<typeof themeSettingsSchema>;

/**
 * Direct reference to the profileThemes table document type
 */
export type ProfileTheme = Doc<"profileThemes">;




================================================
FILE: .cursor/rules/convex_rules.mdc
================================================
---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx
alwaysApply: false
---

# Convex guidelines
## Function guidelines
### New function syntax
- ALWAYS use the new function syntax for Convex functions. For example:
      ```typescript
      import { query } from "./_generated/server";
      import { v } from "convex/values";
      export const f = query({
          args: {},
          returns: v.null(),
          handler: async (ctx, args) => {
          // Function body
          },
      });
      ```

### Http endpoint syntax
- HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator. For example:
      ```typescript
      import { httpRouter } from "convex/server";
      import { httpAction } from "./_generated/server";
      const http = httpRouter();
      http.route({
          path: "/echo",
          method: "POST",
          handler: httpAction(async (ctx, req) => {
          const body = await req.bytes();
          return new Response(body, { status: 200 });
          }),
      });
      ```
- HTTP endpoints are always registered at the exact path you specify in the `path` field. For example, if you specify `/api/someRoute`, the endpoint will be registered at `/api/someRoute`.

### Validators
- Below is an example of an array validator:
                            ```typescript
                            import { mutation } from "./_generated/server";
                            import { v } from "convex/values";

                            export default mutation({
                            args: {
                                simpleArray: v.array(v.union(v.string(), v.number())),
                            },
                            handler: async (ctx, args) => {
                                //...
                            },
                            });
                            ```
- Below is an example of a schema with validators that codify a discriminated union type:
                            ```typescript
                            import { defineSchema, defineTable } from "convex/server";
                            import { v } from "convex/values";

                            export default defineSchema({
                                results: defineTable(
                                    v.union(
                                        v.object({
                                            kind: v.literal("error"),
                                            errorMessage: v.string(),
                                        }),
                                        v.object({
                                            kind: v.literal("success"),
                                            value: v.number(),
                                        }),
                                    ),
                                )
                            });
                            ```
- Always use the `v.null()` validator when returning a null value. Below is an example query that returns a null value:
                                  ```typescript
                                  import { query } from "./_generated/server";
                                  import { v } from "convex/values";

                                  export const exampleQuery = query({
                                    args: {},
                                    returns: v.null(),
                                    handler: async (ctx, args) => {
                                        console.log("This query returns a null value");
                                        return null;
                                    },
                                  });
                                  ```
- Here are the valid Convex types along with their respective validators:
 Convex Type  | TS/JS type  |  Example Usage         | Validator for argument validation and schemas  | Notes                                                                                                                                                                                                 |
| ----------- | ------------| -----------------------| -----------------------------------------------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Id          | string      | `doc._id`              | `v.id(tableName)`                              |                                                                                                                                                                                                       |
| Null        | null        | `null`                 | `v.null()`                                     | JavaScript's `undefined` is not a valid Convex value. Functions the return `undefined` or do not return will return `null` when called from a client. Use `null` instead.                             |
| Int64       | bigint      | `3n`                   | `v.int64()`                                    | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports `bigint`s in most modern browsers.                                                                                              |
| Float64     | number      | `3.1`                  | `v.number()`                                   | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.                                                                      |
| Boolean     | boolean     | `true`                 | `v.boolean()`                                  |
| String      | string      | `"abc"`                | `v.string()`                                   | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.                                                         |
| Bytes       | ArrayBuffer | `new ArrayBuffer(8)`   | `v.bytes()`                                    | Convex supports first class bytestrings, passed in as `ArrayBuffer`s. Bytestrings must be smaller than the 1MB total size limit for Convex types.                                                     |
| Array       | Array]      | `[1, 3.2, "abc"]`      | `v.array(values)`                              | Arrays can have at most 8192 values.                                                                                                                                                                  |
| Object      | Object      | `{a: "abc"}`           | `v.object({property: value})`                  | Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "_". |
| Record      | Record      | `{"a": "1", "b": "2"}` | `v.record(keys, values)`                       | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with "$" or "_".                                                               |

### Function registration
- Use `internalQuery`, `internalMutation`, and `internalAction` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from `./_generated/server`.
- Use `query`, `mutation`, and `action` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use `query`, `mutation`, or `action` to register sensitive internal functions that should be kept private.
- You CANNOT register a function through the `api` or `internal` objects.
- ALWAYS include argument and return validators for all Convex functions. This includes all of `query`, `internalQuery`, `mutation`, `internalMutation`, `action`, and `internalAction`. If a function doesn't return anything, include `returns: v.null()` as its output validator.
- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns `null`.

### Function calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action.
- Use `ctx.runMutation` to call a mutation from a mutation or action.
- Use `ctx.runAction` to call an action from an action.
- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.
- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.
- All of these calls take in a `FunctionReference`. Do NOT try to pass the callee function directly into one of these calls.
- When using `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,
                            ```
                            export const f = query({
                              args: { name: v.string() },
                              returns: v.string(),
                              handler: async (ctx, args) => {
                                return "Hello " + args.name;
                              },
                            });

                            export const g = query({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
                                return null;
                              },
                            });
                            ```

### Function references
- Function references are pointers to registered Convex functions.
- Use the `api` object defined by the framework in `convex/_generated/api.ts` to call public functions registered with `query`, `mutation`, or `action`.
- Use the `internal` object defined by the framework in `convex/_generated/api.ts` to call internal (or private) functions registered with `internalQuery`, `internalMutation`, or `internalAction`.
- Convex uses file-based routing, so a public function defined in `convex/example.ts` named `f` has a function reference of `api.example.f`.
- A private function defined in `convex/example.ts` named `g` has a function reference of `internal.example.g`.
- Functions can also registered within directories nested within the `convex/` folder. For example, a public function `h` defined in `convex/messages/access.ts` has a function reference of `api.messages.access.h`.

### Api design
- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the `convex/` directory.
- Use `query`, `mutation`, and `action` to define public functions.
- Use `internalQuery`, `internalMutation`, and `internalAction` to define private, internal functions.

### Pagination
- Paginated queries are queries that return a list of results in incremental pages.
- You can define pagination using the following syntax:

                            ```ts
                            import { v } from "convex/values";
                            import { query, mutation } from "./_generated/server";
                            import { paginationOptsValidator } from "convex/server";
                            export const listWithExtraArg = query({
                                args: { paginationOpts: paginationOptsValidator, author: v.string() },
                                handler: async (ctx, args) => {
                                    return await ctx.db
                                    .query("messages")
                                    .filter((q) => q.eq(q.field("author"), args.author))
                                    .order("desc")
                                    .paginate(args.paginationOpts);
                                },
                            });
                            ```
                            Note: `paginationOpts` is an object with the following properties:
                            - `numItems`: the maximum number of documents to return (the validator is `v.number()`)
                            - `cursor`: the cursor to use to fetch the next page of documents (the validator is `v.union(v.string(), v.null())`)
- A query that ends in `.paginate()` returns an object that has the following properties:
                            - page (contains an array of documents that you fetches)
                            - isDone (a boolean that represents whether or not this is the last page of documents)
                            - continueCursor (a string that represents the cursor to use to fetch the next page of documents)


## Validator guidelines
- `v.bigint()` is deprecated for representing signed 64-bit integers. Use `v.int64()` instead.
- Use `v.record()` for defining a record type. `v.map()` and `v.set()` are not supported.

## Schema guidelines
- Always define your schema in `convex/schema.ts`.
- Always import the schema definition functions from `convex/server`:
- System fields are automatically added to all documents and are prefixed with an underscore. The two system fields that are automatically added to all documents are `_creationTime` which has the validator `v.number()` and `_id` which has the validator `v.id(tableName)`.
- Always include all index fields in the index name. For example, if an index is defined as `["field1", "field2"]`, the index name should be "by_field1_and_field2".
- Index fields must be queried in the same order they are defined. If you want to be able to query by "field1" then "field2" and by "field2" then "field1", you must create separate indexes.

## Typescript guidelines
- You can use the helper typescript type `Id` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use `Id<'users'>` to get the type of the id for that table.
- If you need to define a `Record` make sure that you correctly provide the type of the key and value in the type. For example a validator `v.record(v.id('users'), v.string())` would have the type `Record<Id<'users'>, string>`. Below is an example of using `Record` with an `Id` type in a query:
                    ```ts
                    import { query } from "./_generated/server";
                    import { Doc, Id } from "./_generated/dataModel";

                    export const exampleQuery = query({
                        args: { userIds: v.array(v.id("users")) },
                        returns: v.record(v.id("users"), v.string()),
                        handler: async (ctx, args) => {
                            const idToHandle: Record<Id<"users">, string> = {};
                            for (const userId of args.userIds) {
                                const user = await ctx.db.get(userId);
                                if (user) {
                                    users[user._id] = user.handle;
                                }
                            }

                            return idToHandle;
                        },
                    });
                    ```
- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in `Id<'users'>` rather than `string`.
- Always use `as const` for string literals in discriminated union types.
- When using the `Array` type, make sure to always define your arrays as `const array: Array<T> = [...];`
- When using the `Record` type, make sure to always define your records as `const record: Record<KeyType, ValueType> = {...};`
- Always add `@types/node` to your `package.json` when using any Node.js built-in modules.

## Full text search guidelines
- A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);

## Query guidelines
- Do NOT use `filter` in queries. Instead, define an index in the schema and use `withIndex` instead.
- Convex queries do NOT support `.delete()`. Instead, `.collect()` the results, iterate over them, and call `ctx.db.delete(row._id)` on each result.
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, don't use `.collect()` or `.take(n)` on the result of a query. Instead, use the `for await (const row of query)` syntax.
### Ordering
- By default Convex always returns documents in ascending `_creationTime` order.
- You can use `.order('asc')` or `.order('desc')` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.
- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.


## Mutation guidelines
- Use `ctx.db.replace` to fully replace an existing document. This method will throw an error if the document does not exist.
- Use `ctx.db.patch` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.

## Action guidelines
- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.db` inside of an action. Actions don't have access to the database.
- Below is an example of the syntax for an action:
                    ```ts
                    import { action } from "./_generated/server";

                    export const exampleAction = action({
                        args: {},
                        returns: v.null(),
                        handler: async (ctx, args) => {
                            console.log("This action does not return anything");
                            return null;
                        },
                    });
                    ```

## Scheduling guidelines
### Cron guidelines
- Only use the `crons.interval` or `crons.cron` methods to schedule cron jobs. Do NOT use the `crons.hourly`, `crons.daily`, or `crons.weekly` helpers.
- Both cron methods take in a FunctionReference. Do NOT try to pass the function directly into one of these methods.
- Define crons by declaring the top-level `crons` object, calling some methods on it, and then exporting it as default. For example,
                            ```ts
                            import { cronJobs } from "convex/server";
                            import { internal } from "./_generated/api";
                            import { internalAction } from "./_generated/server";

                            const empty = internalAction({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                console.log("empty");
                              },
                            });

                            const crons = cronJobs();

                            // Run `internal.crons.empty` every two hours.
                            crons.interval("delete inactive users", { hours: 2 }, internal.crons.empty, {});

                            export default crons;
                            ```
- You can register Convex functions within `crons.ts` just like any other file.
- If a cron calls an internal function, always import the `internal` object from '_generated/api`, even if the internal function is registered in the same file.


## File storage guidelines
- Convex includes file storage for large files like images, videos, and PDFs.
- The `ctx.storage.getUrl()` method returns a signed URL for a given file. It returns `null` if the file doesn't exist.
- Do NOT use the deprecated `ctx.storage.getMetadata` call for loading a file's metadata.

                    Instead, query the `_storage` system table. For example, you can use `ctx.db.system.get` to get an `Id<"_storage">`.
                    ```
                    import { query } from "./_generated/server";
                    import { Id } from "./_generated/dataModel";

                    type FileMetadata = {
                        _id: Id<"_storage">;
                        _creationTime: number;
                        contentType?: string;
                        sha256: string;
                        size: number;
                    }

                    export const exampleQuery = query({
                        args: { fileId: v.id("_storage") },
                        returns: v.null();
                        handler: async (ctx, args) => {
                            const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);
                            console.log(metadata);
                            return null;
                        },
                    });
                    ```
- Convex storage stores items as `Blob` objects. You must convert all items to/from a `Blob` when using Convex storage.


# Examples:
## Example: chat-app

### Task
```
Create a real-time chat application backend with AI responses. The app should:
- Allow creating users with names
- Support multiple chat channels
- Enable users to send messages to channels
- Automatically generate AI responses to user messages
- Show recent message history

The backend should provide APIs for:
1. User management (creation)
2. Channel management (creation)
3. Message operations (sending, listing)
4. AI response generation using OpenAI's GPT-4

Messages should be stored with their channel, author, and content. The system should maintain message order
and limit history display to the 10 most recent messages per channel.

```

### Analysis
1. Task Requirements Summary:
- Build a real-time chat backend with AI integration
- Support user creation
- Enable channel-based conversations
- Store and retrieve messages with proper ordering
- Generate AI responses automatically

2. Main Components Needed:
- Database tables: users, channels, messages
- Public APIs for user/channel management
- Message handling functions
- Internal AI response generation system
- Context loading for AI responses

3. Public API and Internal Functions Design:
Public Mutations:
- createUser:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({userId: v.id("users")})
  - purpose: Create a new user with a given name
- createChannel:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({channelId: v.id("channels")})
  - purpose: Create a new channel with a given name
- sendMessage:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), authorId: v.id("users"), content: v.string()}
  - returns: v.null()
  - purpose: Send a message to a channel and schedule a response from the AI

Public Queries:
- listMessages:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
    }))
  - purpose: List the 10 most recent messages from a channel in descending creation order

Internal Functions:
- generateResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.null()
  - purpose: Generate a response from the AI for a given channel
- loadContext:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }))
- writeAgentResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), content: v.string()}
  - returns: v.null()
  - purpose: Write an AI response to a given channel

4. Schema Design:
- users
  - validator: { name: v.string() }
  - indexes: <none>
- channels
  - validator: { name: v.string() }
  - indexes: <none>
- messages
  - validator: { channelId: v.id("channels"), authorId: v.optional(v.id("users")), content: v.string() }
  - indexes
    - by_channel: ["channelId"]

5. Background Processing:
- AI response generation runs asynchronously after each user message
- Uses OpenAI's GPT-4 to generate contextual responses
- Maintains conversation context using recent message history


### Implementation

#### package.json
```typescript
{
  "name": "chat-app",
  "description": "This example shows how to build a chat app without authentication.",
  "version": "1.0.0",
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0"
  },
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}
```

#### tsconfig.json
```typescript
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "exclude": ["convex"],
  "include": ["**/src/**/*.tsx", "**/src/**/*.ts", "next.config.ts"]
}
```

#### convex/index.ts
```typescript
import {
  query,
  mutation,
  internalQuery,
  internalMutation,
  internalAction,
} from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { internal } from "./_generated/api";

/**
 * Create a user with a given name.
 */
export const createUser = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("users", { name: args.name });
  },
});

/**
 * Create a channel with a given name.
 */
export const createChannel = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("channels"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("channels", { name: args.name });
  },
});

/**
 * List the 10 most recent messages from a channel in descending creation order.
 */
export const listMessages = query({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      _id: v.id("messages"),
      _creationTime: v.number(),
      channelId: v.id("channels"),
      authorId: v.optional(v.id("users")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);
    return messages;
  },
});

/**
 * Send a message to a channel and schedule a response from the AI.
 */
export const sendMessage = mutation({
  args: {
    channelId: v.id("channels"),
    authorId: v.id("users"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const user = await ctx.db.get(args.authorId);
    if (!user) {
      throw new Error("User not found");
    }
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      authorId: args.authorId,
      content: args.content,
    });
    await ctx.scheduler.runAfter(0, internal.index.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

export const generateResponse = internalAction({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.index.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("No content in response");
    }
    await ctx.runMutation(internal.index.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = internalQuery({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.db.get(message.authorId);
        if (!user) {
          throw new Error("User not found");
        }
        result.push({
          role: "user" as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: "assistant" as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = internalMutation({
  args: {
    channelId: v.id("channels"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

#### convex/schema.ts
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),

  users: defineTable({
    name: v.string(),
  }),

  messages: defineTable({
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }).index("by_channel", ["channelId"]),
});
```

#### src/App.tsx
```typescript
export default function App() {
  return <div>Hello World</div>;
}
```



